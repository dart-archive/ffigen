// ignore_for_file: non_constant_identifier_names, unused_import, camel_case_types

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:wasmjsgen`.

import 'dart:async' as dart_async;
import 'dart:convert' as dart_convert;
import 'dart:typed_data' as dart_typed;
import 'package:wasm_interop/wasm_interop.dart' as wasm_interop;

class Bindings {
  /// The symbol lookup function.
  T lookup<T>(String name) {
    return _wasmInstance.functions[name] as T;
  }

  wasm_interop.Memory get memory {
    return _wasmInstance.memories['memory']!;
  }

  dart_typed.Uint8List get memView {
    return _wasmInstance.memories['memory']!.buffer.asUint8List();
  }

  int get memBytes => memory.lengthInBytes;
  int get memPages => memory.lengthInPages;
  int get memPageSize => (memBytes / memPages).floor();
  int get memElemByteSize => memView.elementSizeInBytes;

  final wasm_interop.Instance _wasmInstance;
  Bindings(this._wasmInstance);

  // --- test1 ---
  late final Pointer<Int32> _test1 = lookup<Int32>('test1');

  int get test1 => _test1.value;

  set test1(int value) => _test1.value = value;

  // --- test2 ---
  late final Pointer<Pointer<Float>> _test2 = lookup<Pointer<Float>>('test2');

  Pointer<Float> get test2 => _test2.value;

  set test2(Pointer<Float> value) => _test2.value = value;

  // --- test5 ---
  late final Pointer<Pointer<Some>> _test5 = lookup<Pointer<Some>>('test5');

  Pointer<Some> get test5 => _test5.value;

  set test5(Pointer<Some> value) => _test5.value = value;

  // --- globalStruct ---
  late final Pointer<EmptyStruct> _globalStruct =
      lookup<EmptyStruct>('globalStruct');

  Pointer<EmptyStruct> get globalStruct => _globalStruct;

  @override
  String toString() {
    final functions = _wasmInstance.functions.keys.map((x) => '\n     $x');
    final elemSize = memElemByteSize;
    int bytesUsed = 0;
    for (int i = 0; i < memView.length; i += elemSize) {
      if (memView[i] != 0) bytesUsed++;
    }
    return '''Wasm NativeLibrary {
  Memory {
    Page Size:        $memPageSize
    Elem Byte Size:   $elemSize
    Pages:            $memPages
    Bytes Total:      $memBytes
    Bytes Used:       $bytesUsed
  }
  functions: $functions
  functionCount: ${functions.length}
}
''';
  }

  static Bindings? _instance;
  static Bindings get instance {
    assert(
        _instance != null, "need to Bindings.init() before accessing instance");
    return _instance!;
  }

  static Future<Bindings> init(dart_typed.Uint8List moduleData) async {
    final wasm_interop.Instance instance =
        await wasm_interop.Instance.fromBytesAsync(moduleData);
    _instance = Bindings(instance);
    return Bindings.instance;
  }
}

class Some extends Opaque {
  Some(int address) : super(address);
}

class EmptyStruct extends Opaque {
  EmptyStruct(int address) : super(address);
}

// Base for Native Types and Opaque Structs
class Opaque {
  final int _address;
  int get address => _address;
  Opaque(this._address);
}

// FFI Pointer Replacement
class Pointer<T extends Opaque> {
  final T _opaque;
  Pointer._(this._opaque);
  late final int? size;
  factory Pointer.fromAddress(T opaque) {
    return Pointer._(opaque);
  }
  int get address => _opaque.address;
  bool get isSized => size != null;
}

// Dart FFI Native Types
class Void extends Opaque {
  Void(int address) : super(address);
}

class Uint8 extends Opaque {
  Uint8(int address) : super(address);
}

class Int8 extends Opaque {
  Int8(int address) : super(address);
}

class Int16 extends Opaque {
  Int16(int address) : super(address);
}

class Int32 extends Opaque {
  Int32(int address) : super(address);
}

class Int64 extends Opaque {
  Int64(int address) : super(address);
}

class Uint16 extends Opaque {
  Uint16(int address) : super(address);
}

class Uint32 extends Opaque {
  Uint32(int address) : super(address);
}

class Uint64 extends Opaque {
  Uint64(int address) : super(address);
}

class Float extends Opaque {
  Float(int address) : super(address);
}

class Double extends Opaque {
  Double(int address) : super(address);
}

class IntPtr extends Opaque {
  IntPtr(int address) : super(address);
}

// --- JsBigInt and conversion ---
typedef JsBigInt = String;

// Only reliable way I found to convert JS BigInt to int.
// It is used to convert uint64_t and int64_t.
// Dart int is 64bit (signed). A u64 will not fit if it is larger than max i64.
// However in most scenarios we will not hit this max value.
//   Max u64 is 18,446,744,073,709,551,615
//   Max i64 is  9,223,372,036,854,775,807
// Thus we take a shortcut to avoid having to deal with Dart BigInt.
int jsBigIntToInt(JsBigInt n) {
  return int.parse(n);
}

// --- Pointer<Int8> to Dart String conversion ---
const dart_convert.Utf8Codec utf8Codec = dart_convert.Utf8Codec();
String toDartString(Pointer<Int8> ptr) {
  return _decodeUtf8ListString(Bindings.instance.memView, ptr.address);
}

String _decodeUtf8ListString(dart_typed.Uint8List codeUnits, int address) {
  final end = _end(codeUnits, address);
  return utf8Codec.decode(codeUnits.sublist(address, end));
}

int _end(dart_typed.Uint8List codeUnits, int start) {
  int end = start;
  while (codeUnits[end] != 0) {
    end++;
  }
  return end;
}
