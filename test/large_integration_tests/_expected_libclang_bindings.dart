// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to LibClang.
class LibClang {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  LibClang(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Retrieve the character data associated with the given string.
  ffi.Pointer<ffi.Int8> clang_getCString(
    CXString string,
  ) {
    return (_clang_getCString ??=
        _dylib.lookupFunction<_c_clang_getCString, _dart_clang_getCString>(
            'clang_getCString'))(
      string,
    );
  }

  _dart_clang_getCString? _clang_getCString;

  /// Free the given string.
  void clang_disposeString(
    CXString string,
  ) {
    return (_clang_disposeString ??= _dylib.lookupFunction<
        _c_clang_disposeString,
        _dart_clang_disposeString>('clang_disposeString'))(
      string,
    );
  }

  _dart_clang_disposeString? _clang_disposeString;

  /// Free the given string set.
  void clang_disposeStringSet(
    ffi.Pointer<CXStringSet> set_1,
  ) {
    return (_clang_disposeStringSet ??= _dylib.lookupFunction<
        _c_clang_disposeStringSet,
        _dart_clang_disposeStringSet>('clang_disposeStringSet'))(
      set_1,
    );
  }

  _dart_clang_disposeStringSet? _clang_disposeStringSet;

  /// Return the timestamp for use with Clang's -fbuild-session-timestamp=
  /// option.
  int clang_getBuildSessionTimestamp() {
    return (_clang_getBuildSessionTimestamp ??= _dylib.lookupFunction<
            _c_clang_getBuildSessionTimestamp,
            _dart_clang_getBuildSessionTimestamp>(
        'clang_getBuildSessionTimestamp'))();
  }

  _dart_clang_getBuildSessionTimestamp? _clang_getBuildSessionTimestamp;

  /// Create a CXVirtualFileOverlay object. Must be disposed with
  /// clang_VirtualFileOverlay_dispose().
  ffi.Pointer<CXVirtualFileOverlayImpl> clang_VirtualFileOverlay_create(
    int options,
  ) {
    return (_clang_VirtualFileOverlay_create ??= _dylib.lookupFunction<
            _c_clang_VirtualFileOverlay_create,
            _dart_clang_VirtualFileOverlay_create>(
        'clang_VirtualFileOverlay_create'))(
      options,
    );
  }

  _dart_clang_VirtualFileOverlay_create? _clang_VirtualFileOverlay_create;

  /// Map an absolute virtual file path to an absolute real one. The virtual
  /// path must be canonicalized (not contain "."/"..").
  int clang_VirtualFileOverlay_addFileMapping(
    ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
    ffi.Pointer<ffi.Int8> virtualPath,
    ffi.Pointer<ffi.Int8> realPath,
  ) {
    return (_clang_VirtualFileOverlay_addFileMapping ??= _dylib.lookupFunction<
            _c_clang_VirtualFileOverlay_addFileMapping,
            _dart_clang_VirtualFileOverlay_addFileMapping>(
        'clang_VirtualFileOverlay_addFileMapping'))(
      arg0,
      virtualPath,
      realPath,
    );
  }

  _dart_clang_VirtualFileOverlay_addFileMapping?
      _clang_VirtualFileOverlay_addFileMapping;

  /// Set the case sensitivity for the CXVirtualFileOverlay object. The
  /// CXVirtualFileOverlay object is case-sensitive by default, this option can
  /// be used to override the default.
  int clang_VirtualFileOverlay_setCaseSensitivity(
    ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
    int caseSensitive,
  ) {
    return (_clang_VirtualFileOverlay_setCaseSensitivity ??=
        _dylib.lookupFunction<_c_clang_VirtualFileOverlay_setCaseSensitivity,
                _dart_clang_VirtualFileOverlay_setCaseSensitivity>(
            'clang_VirtualFileOverlay_setCaseSensitivity'))(
      arg0,
      caseSensitive,
    );
  }

  _dart_clang_VirtualFileOverlay_setCaseSensitivity?
      _clang_VirtualFileOverlay_setCaseSensitivity;

  /// Write out the CXVirtualFileOverlay object to a char buffer.
  int clang_VirtualFileOverlay_writeToBuffer(
    ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
    int options,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
    ffi.Pointer<ffi.Uint32> out_buffer_size,
  ) {
    return (_clang_VirtualFileOverlay_writeToBuffer ??= _dylib.lookupFunction<
            _c_clang_VirtualFileOverlay_writeToBuffer,
            _dart_clang_VirtualFileOverlay_writeToBuffer>(
        'clang_VirtualFileOverlay_writeToBuffer'))(
      arg0,
      options,
      out_buffer_ptr,
      out_buffer_size,
    );
  }

  _dart_clang_VirtualFileOverlay_writeToBuffer?
      _clang_VirtualFileOverlay_writeToBuffer;

  /// free memory allocated by libclang, such as the buffer returned by
  /// CXVirtualFileOverlay() or clang_ModuleMapDescriptor_writeToBuffer().
  void clang_free(
    ffi.Pointer<ffi.Void> buffer,
  ) {
    return (_clang_free ??=
        _dylib.lookupFunction<_c_clang_free, _dart_clang_free>('clang_free'))(
      buffer,
    );
  }

  _dart_clang_free? _clang_free;

  /// Dispose a CXVirtualFileOverlay object.
  void clang_VirtualFileOverlay_dispose(
    ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  ) {
    return (_clang_VirtualFileOverlay_dispose ??= _dylib.lookupFunction<
            _c_clang_VirtualFileOverlay_dispose,
            _dart_clang_VirtualFileOverlay_dispose>(
        'clang_VirtualFileOverlay_dispose'))(
      arg0,
    );
  }

  _dart_clang_VirtualFileOverlay_dispose? _clang_VirtualFileOverlay_dispose;

  /// Create a CXModuleMapDescriptor object. Must be disposed with
  /// clang_ModuleMapDescriptor_dispose().
  ffi.Pointer<CXModuleMapDescriptorImpl> clang_ModuleMapDescriptor_create(
    int options,
  ) {
    return (_clang_ModuleMapDescriptor_create ??= _dylib.lookupFunction<
            _c_clang_ModuleMapDescriptor_create,
            _dart_clang_ModuleMapDescriptor_create>(
        'clang_ModuleMapDescriptor_create'))(
      options,
    );
  }

  _dart_clang_ModuleMapDescriptor_create? _clang_ModuleMapDescriptor_create;

  /// Sets the framework module name that the module.map describes.
  int clang_ModuleMapDescriptor_setFrameworkModuleName(
    ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return (_clang_ModuleMapDescriptor_setFrameworkModuleName ??=
        _dylib.lookupFunction<
                _c_clang_ModuleMapDescriptor_setFrameworkModuleName,
                _dart_clang_ModuleMapDescriptor_setFrameworkModuleName>(
            'clang_ModuleMapDescriptor_setFrameworkModuleName'))(
      arg0,
      name,
    );
  }

  _dart_clang_ModuleMapDescriptor_setFrameworkModuleName?
      _clang_ModuleMapDescriptor_setFrameworkModuleName;

  /// Sets the umbrealla header name that the module.map describes.
  int clang_ModuleMapDescriptor_setUmbrellaHeader(
    ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return (_clang_ModuleMapDescriptor_setUmbrellaHeader ??=
        _dylib.lookupFunction<_c_clang_ModuleMapDescriptor_setUmbrellaHeader,
                _dart_clang_ModuleMapDescriptor_setUmbrellaHeader>(
            'clang_ModuleMapDescriptor_setUmbrellaHeader'))(
      arg0,
      name,
    );
  }

  _dart_clang_ModuleMapDescriptor_setUmbrellaHeader?
      _clang_ModuleMapDescriptor_setUmbrellaHeader;

  /// Write out the CXModuleMapDescriptor object to a char buffer.
  int clang_ModuleMapDescriptor_writeToBuffer(
    ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
    int options,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
    ffi.Pointer<ffi.Uint32> out_buffer_size,
  ) {
    return (_clang_ModuleMapDescriptor_writeToBuffer ??= _dylib.lookupFunction<
            _c_clang_ModuleMapDescriptor_writeToBuffer,
            _dart_clang_ModuleMapDescriptor_writeToBuffer>(
        'clang_ModuleMapDescriptor_writeToBuffer'))(
      arg0,
      options,
      out_buffer_ptr,
      out_buffer_size,
    );
  }

  _dart_clang_ModuleMapDescriptor_writeToBuffer?
      _clang_ModuleMapDescriptor_writeToBuffer;

  /// Dispose a CXModuleMapDescriptor object.
  void clang_ModuleMapDescriptor_dispose(
    ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ) {
    return (_clang_ModuleMapDescriptor_dispose ??= _dylib.lookupFunction<
            _c_clang_ModuleMapDescriptor_dispose,
            _dart_clang_ModuleMapDescriptor_dispose>(
        'clang_ModuleMapDescriptor_dispose'))(
      arg0,
    );
  }

  _dart_clang_ModuleMapDescriptor_dispose? _clang_ModuleMapDescriptor_dispose;

  /// Provides a shared context for creating translation units.
  ffi.Pointer<ffi.Void> clang_createIndex(
    int excludeDeclarationsFromPCH,
    int displayDiagnostics,
  ) {
    return (_clang_createIndex ??=
        _dylib.lookupFunction<_c_clang_createIndex, _dart_clang_createIndex>(
            'clang_createIndex'))(
      excludeDeclarationsFromPCH,
      displayDiagnostics,
    );
  }

  _dart_clang_createIndex? _clang_createIndex;

  /// Destroy the given index.
  void clang_disposeIndex(
    ffi.Pointer<ffi.Void> index,
  ) {
    return (_clang_disposeIndex ??=
        _dylib.lookupFunction<_c_clang_disposeIndex, _dart_clang_disposeIndex>(
            'clang_disposeIndex'))(
      index,
    );
  }

  _dart_clang_disposeIndex? _clang_disposeIndex;

  /// Sets general options associated with a CXIndex.
  void clang_CXIndex_setGlobalOptions(
    ffi.Pointer<ffi.Void> arg0,
    int options,
  ) {
    return (_clang_CXIndex_setGlobalOptions ??= _dylib.lookupFunction<
            _c_clang_CXIndex_setGlobalOptions,
            _dart_clang_CXIndex_setGlobalOptions>(
        'clang_CXIndex_setGlobalOptions'))(
      arg0,
      options,
    );
  }

  _dart_clang_CXIndex_setGlobalOptions? _clang_CXIndex_setGlobalOptions;

  /// Gets the general options associated with a CXIndex.
  int clang_CXIndex_getGlobalOptions(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_CXIndex_getGlobalOptions ??= _dylib.lookupFunction<
            _c_clang_CXIndex_getGlobalOptions,
            _dart_clang_CXIndex_getGlobalOptions>(
        'clang_CXIndex_getGlobalOptions'))(
      arg0,
    );
  }

  _dart_clang_CXIndex_getGlobalOptions? _clang_CXIndex_getGlobalOptions;

  /// Sets the invocation emission path option in a CXIndex.
  void clang_CXIndex_setInvocationEmissionPathOption(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Int8> Path,
  ) {
    return (_clang_CXIndex_setInvocationEmissionPathOption ??=
        _dylib.lookupFunction<_c_clang_CXIndex_setInvocationEmissionPathOption,
                _dart_clang_CXIndex_setInvocationEmissionPathOption>(
            'clang_CXIndex_setInvocationEmissionPathOption'))(
      arg0,
      Path,
    );
  }

  _dart_clang_CXIndex_setInvocationEmissionPathOption?
      _clang_CXIndex_setInvocationEmissionPathOption;

  /// Retrieve the complete file and path name of the given file.
  CXString clang_getFileName(
    ffi.Pointer<ffi.Void> SFile,
  ) {
    return (_clang_getFileName ??=
        _dylib.lookupFunction<_c_clang_getFileName, _dart_clang_getFileName>(
            'clang_getFileName'))(
      SFile,
    );
  }

  _dart_clang_getFileName? _clang_getFileName;

  /// Retrieve the last modification time of the given file.
  int clang_getFileTime(
    ffi.Pointer<ffi.Void> SFile,
  ) {
    return (_clang_getFileTime ??=
        _dylib.lookupFunction<_c_clang_getFileTime, _dart_clang_getFileTime>(
            'clang_getFileTime'))(
      SFile,
    );
  }

  _dart_clang_getFileTime? _clang_getFileTime;

  /// Retrieve the unique ID for the given file.
  int clang_getFileUniqueID(
    ffi.Pointer<ffi.Void> file,
    ffi.Pointer<CXFileUniqueID> outID,
  ) {
    return (_clang_getFileUniqueID ??= _dylib.lookupFunction<
        _c_clang_getFileUniqueID,
        _dart_clang_getFileUniqueID>('clang_getFileUniqueID'))(
      file,
      outID,
    );
  }

  _dart_clang_getFileUniqueID? _clang_getFileUniqueID;

  /// Determine whether the given header is guarded against multiple inclusions,
  /// either with the conventional #ifndef/#define/#endif macro guards or with
  /// #pragma once.
  int clang_isFileMultipleIncludeGuarded(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Void> file,
  ) {
    return (_clang_isFileMultipleIncludeGuarded ??= _dylib.lookupFunction<
            _c_clang_isFileMultipleIncludeGuarded,
            _dart_clang_isFileMultipleIncludeGuarded>(
        'clang_isFileMultipleIncludeGuarded'))(
      tu,
      file,
    );
  }

  _dart_clang_isFileMultipleIncludeGuarded? _clang_isFileMultipleIncludeGuarded;

  /// Retrieve a file handle within the given translation unit.
  ffi.Pointer<ffi.Void> clang_getFile(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Int8> file_name,
  ) {
    return (_clang_getFile ??=
        _dylib.lookupFunction<_c_clang_getFile, _dart_clang_getFile>(
            'clang_getFile'))(
      tu,
      file_name,
    );
  }

  _dart_clang_getFile? _clang_getFile;

  /// Retrieve the buffer associated with the given file.
  ffi.Pointer<ffi.Int8> clang_getFileContents(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Void> file,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return (_clang_getFileContents ??= _dylib.lookupFunction<
        _c_clang_getFileContents,
        _dart_clang_getFileContents>('clang_getFileContents'))(
      tu,
      file,
      size,
    );
  }

  _dart_clang_getFileContents? _clang_getFileContents;

  /// Returns non-zero if the file1 and file2 point to the same file, or they
  /// are both NULL.
  int clang_File_isEqual(
    ffi.Pointer<ffi.Void> file1,
    ffi.Pointer<ffi.Void> file2,
  ) {
    return (_clang_File_isEqual ??=
        _dylib.lookupFunction<_c_clang_File_isEqual, _dart_clang_File_isEqual>(
            'clang_File_isEqual'))(
      file1,
      file2,
    );
  }

  _dart_clang_File_isEqual? _clang_File_isEqual;

  /// Returns the real path name of file.
  CXString clang_File_tryGetRealPathName(
    ffi.Pointer<ffi.Void> file,
  ) {
    return (_clang_File_tryGetRealPathName ??= _dylib.lookupFunction<
        _c_clang_File_tryGetRealPathName,
        _dart_clang_File_tryGetRealPathName>('clang_File_tryGetRealPathName'))(
      file,
    );
  }

  _dart_clang_File_tryGetRealPathName? _clang_File_tryGetRealPathName;

  /// Retrieve a NULL (invalid) source location.
  CXSourceLocation clang_getNullLocation() {
    return (_clang_getNullLocation ??= _dylib.lookupFunction<
        _c_clang_getNullLocation,
        _dart_clang_getNullLocation>('clang_getNullLocation'))();
  }

  _dart_clang_getNullLocation? _clang_getNullLocation;

  /// Determine whether two source locations, which must refer into the same
  /// translation unit, refer to exactly the same point in the source code.
  int clang_equalLocations(
    CXSourceLocation loc1,
    CXSourceLocation loc2,
  ) {
    return (_clang_equalLocations ??= _dylib.lookupFunction<
        _c_clang_equalLocations,
        _dart_clang_equalLocations>('clang_equalLocations'))(
      loc1,
      loc2,
    );
  }

  _dart_clang_equalLocations? _clang_equalLocations;

  /// Retrieves the source location associated with a given file/line/column in
  /// a particular translation unit.
  CXSourceLocation clang_getLocation(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Void> file,
    int line,
    int column,
  ) {
    return (_clang_getLocation ??=
        _dylib.lookupFunction<_c_clang_getLocation, _dart_clang_getLocation>(
            'clang_getLocation'))(
      tu,
      file,
      line,
      column,
    );
  }

  _dart_clang_getLocation? _clang_getLocation;

  /// Retrieves the source location associated with a given character offset in
  /// a particular translation unit.
  CXSourceLocation clang_getLocationForOffset(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Void> file,
    int offset,
  ) {
    return (_clang_getLocationForOffset ??= _dylib.lookupFunction<
        _c_clang_getLocationForOffset,
        _dart_clang_getLocationForOffset>('clang_getLocationForOffset'))(
      tu,
      file,
      offset,
    );
  }

  _dart_clang_getLocationForOffset? _clang_getLocationForOffset;

  /// Returns non-zero if the given source location is in a system header.
  int clang_Location_isInSystemHeader(
    CXSourceLocation location,
  ) {
    return (_clang_Location_isInSystemHeader ??= _dylib.lookupFunction<
            _c_clang_Location_isInSystemHeader,
            _dart_clang_Location_isInSystemHeader>(
        'clang_Location_isInSystemHeader'))(
      location,
    );
  }

  _dart_clang_Location_isInSystemHeader? _clang_Location_isInSystemHeader;

  /// Returns non-zero if the given source location is in the main file of the
  /// corresponding translation unit.
  int clang_Location_isFromMainFile(
    CXSourceLocation location,
  ) {
    return (_clang_Location_isFromMainFile ??= _dylib.lookupFunction<
        _c_clang_Location_isFromMainFile,
        _dart_clang_Location_isFromMainFile>('clang_Location_isFromMainFile'))(
      location,
    );
  }

  _dart_clang_Location_isFromMainFile? _clang_Location_isFromMainFile;

  /// Retrieve a NULL (invalid) source range.
  CXSourceRange clang_getNullRange() {
    return (_clang_getNullRange ??=
        _dylib.lookupFunction<_c_clang_getNullRange, _dart_clang_getNullRange>(
            'clang_getNullRange'))();
  }

  _dart_clang_getNullRange? _clang_getNullRange;

  /// Retrieve a source range given the beginning and ending source locations.
  CXSourceRange clang_getRange(
    CXSourceLocation begin,
    CXSourceLocation end,
  ) {
    return (_clang_getRange ??=
        _dylib.lookupFunction<_c_clang_getRange, _dart_clang_getRange>(
            'clang_getRange'))(
      begin,
      end,
    );
  }

  _dart_clang_getRange? _clang_getRange;

  /// Determine whether two ranges are equivalent.
  int clang_equalRanges(
    CXSourceRange range1,
    CXSourceRange range2,
  ) {
    return (_clang_equalRanges ??=
        _dylib.lookupFunction<_c_clang_equalRanges, _dart_clang_equalRanges>(
            'clang_equalRanges'))(
      range1,
      range2,
    );
  }

  _dart_clang_equalRanges? _clang_equalRanges;

  /// Returns non-zero if range is null.
  int clang_Range_isNull(
    CXSourceRange range,
  ) {
    return (_clang_Range_isNull ??=
        _dylib.lookupFunction<_c_clang_Range_isNull, _dart_clang_Range_isNull>(
            'clang_Range_isNull'))(
      range,
    );
  }

  _dart_clang_Range_isNull? _clang_Range_isNull;

  /// Retrieve the file, line, column, and offset represented by the given
  /// source location.
  void clang_getExpansionLocation(
    CXSourceLocation location,
    ffi.Pointer<ffi.Pointer<ffi.Void>> file,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
    ffi.Pointer<ffi.Uint32> offset,
  ) {
    return (_clang_getExpansionLocation ??= _dylib.lookupFunction<
        _c_clang_getExpansionLocation,
        _dart_clang_getExpansionLocation>('clang_getExpansionLocation'))(
      location,
      file,
      line,
      column,
      offset,
    );
  }

  _dart_clang_getExpansionLocation? _clang_getExpansionLocation;

  /// Retrieve the file, line and column represented by the given source
  /// location, as specified in a # line directive.
  void clang_getPresumedLocation(
    CXSourceLocation location,
    ffi.Pointer<CXString> filename,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
  ) {
    return (_clang_getPresumedLocation ??= _dylib.lookupFunction<
        _c_clang_getPresumedLocation,
        _dart_clang_getPresumedLocation>('clang_getPresumedLocation'))(
      location,
      filename,
      line,
      column,
    );
  }

  _dart_clang_getPresumedLocation? _clang_getPresumedLocation;

  /// Legacy API to retrieve the file, line, column, and offset represented by
  /// the given source location.
  void clang_getInstantiationLocation(
    CXSourceLocation location,
    ffi.Pointer<ffi.Pointer<ffi.Void>> file,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
    ffi.Pointer<ffi.Uint32> offset,
  ) {
    return (_clang_getInstantiationLocation ??= _dylib.lookupFunction<
            _c_clang_getInstantiationLocation,
            _dart_clang_getInstantiationLocation>(
        'clang_getInstantiationLocation'))(
      location,
      file,
      line,
      column,
      offset,
    );
  }

  _dart_clang_getInstantiationLocation? _clang_getInstantiationLocation;

  /// Retrieve the file, line, column, and offset represented by the given
  /// source location.
  void clang_getSpellingLocation(
    CXSourceLocation location,
    ffi.Pointer<ffi.Pointer<ffi.Void>> file,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
    ffi.Pointer<ffi.Uint32> offset,
  ) {
    return (_clang_getSpellingLocation ??= _dylib.lookupFunction<
        _c_clang_getSpellingLocation,
        _dart_clang_getSpellingLocation>('clang_getSpellingLocation'))(
      location,
      file,
      line,
      column,
      offset,
    );
  }

  _dart_clang_getSpellingLocation? _clang_getSpellingLocation;

  /// Retrieve the file, line, column, and offset represented by the given
  /// source location.
  void clang_getFileLocation(
    CXSourceLocation location,
    ffi.Pointer<ffi.Pointer<ffi.Void>> file,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
    ffi.Pointer<ffi.Uint32> offset,
  ) {
    return (_clang_getFileLocation ??= _dylib.lookupFunction<
        _c_clang_getFileLocation,
        _dart_clang_getFileLocation>('clang_getFileLocation'))(
      location,
      file,
      line,
      column,
      offset,
    );
  }

  _dart_clang_getFileLocation? _clang_getFileLocation;

  /// Retrieve a source location representing the first character within a
  /// source range.
  CXSourceLocation clang_getRangeStart(
    CXSourceRange range,
  ) {
    return (_clang_getRangeStart ??= _dylib.lookupFunction<
        _c_clang_getRangeStart,
        _dart_clang_getRangeStart>('clang_getRangeStart'))(
      range,
    );
  }

  _dart_clang_getRangeStart? _clang_getRangeStart;

  /// Retrieve a source location representing the last character within a source
  /// range.
  CXSourceLocation clang_getRangeEnd(
    CXSourceRange range,
  ) {
    return (_clang_getRangeEnd ??=
        _dylib.lookupFunction<_c_clang_getRangeEnd, _dart_clang_getRangeEnd>(
            'clang_getRangeEnd'))(
      range,
    );
  }

  _dart_clang_getRangeEnd? _clang_getRangeEnd;

  /// Retrieve all ranges that were skipped by the preprocessor.
  ffi.Pointer<CXSourceRangeList> clang_getSkippedRanges(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.Void> file,
  ) {
    return (_clang_getSkippedRanges ??= _dylib.lookupFunction<
        _c_clang_getSkippedRanges,
        _dart_clang_getSkippedRanges>('clang_getSkippedRanges'))(
      tu,
      file,
    );
  }

  _dart_clang_getSkippedRanges? _clang_getSkippedRanges;

  /// Retrieve all ranges from all files that were skipped by the preprocessor.
  ffi.Pointer<CXSourceRangeList> clang_getAllSkippedRanges(
    ffi.Pointer<CXTranslationUnitImpl> tu,
  ) {
    return (_clang_getAllSkippedRanges ??= _dylib.lookupFunction<
        _c_clang_getAllSkippedRanges,
        _dart_clang_getAllSkippedRanges>('clang_getAllSkippedRanges'))(
      tu,
    );
  }

  _dart_clang_getAllSkippedRanges? _clang_getAllSkippedRanges;

  /// Destroy the given CXSourceRangeList.
  void clang_disposeSourceRangeList(
    ffi.Pointer<CXSourceRangeList> ranges,
  ) {
    return (_clang_disposeSourceRangeList ??= _dylib.lookupFunction<
        _c_clang_disposeSourceRangeList,
        _dart_clang_disposeSourceRangeList>('clang_disposeSourceRangeList'))(
      ranges,
    );
  }

  _dart_clang_disposeSourceRangeList? _clang_disposeSourceRangeList;

  /// Determine the number of diagnostics in a CXDiagnosticSet.
  int clang_getNumDiagnosticsInSet(
    ffi.Pointer<ffi.Void> Diags,
  ) {
    return (_clang_getNumDiagnosticsInSet ??= _dylib.lookupFunction<
        _c_clang_getNumDiagnosticsInSet,
        _dart_clang_getNumDiagnosticsInSet>('clang_getNumDiagnosticsInSet'))(
      Diags,
    );
  }

  _dart_clang_getNumDiagnosticsInSet? _clang_getNumDiagnosticsInSet;

  /// Retrieve a diagnostic associated with the given CXDiagnosticSet.
  ffi.Pointer<ffi.Void> clang_getDiagnosticInSet(
    ffi.Pointer<ffi.Void> Diags,
    int Index,
  ) {
    return (_clang_getDiagnosticInSet ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticInSet,
        _dart_clang_getDiagnosticInSet>('clang_getDiagnosticInSet'))(
      Diags,
      Index,
    );
  }

  _dart_clang_getDiagnosticInSet? _clang_getDiagnosticInSet;

  /// Deserialize a set of diagnostics from a Clang diagnostics bitcode file.
  ffi.Pointer<ffi.Void> clang_loadDiagnostics(
    ffi.Pointer<ffi.Int8> file,
    ffi.Pointer<ffi.Int32> error,
    ffi.Pointer<CXString> errorString,
  ) {
    return (_clang_loadDiagnostics ??= _dylib.lookupFunction<
        _c_clang_loadDiagnostics,
        _dart_clang_loadDiagnostics>('clang_loadDiagnostics'))(
      file,
      error,
      errorString,
    );
  }

  _dart_clang_loadDiagnostics? _clang_loadDiagnostics;

  /// Release a CXDiagnosticSet and all of its contained diagnostics.
  void clang_disposeDiagnosticSet(
    ffi.Pointer<ffi.Void> Diags,
  ) {
    return (_clang_disposeDiagnosticSet ??= _dylib.lookupFunction<
        _c_clang_disposeDiagnosticSet,
        _dart_clang_disposeDiagnosticSet>('clang_disposeDiagnosticSet'))(
      Diags,
    );
  }

  _dart_clang_disposeDiagnosticSet? _clang_disposeDiagnosticSet;

  /// Retrieve the child diagnostics of a CXDiagnostic.
  ffi.Pointer<ffi.Void> clang_getChildDiagnostics(
    ffi.Pointer<ffi.Void> D,
  ) {
    return (_clang_getChildDiagnostics ??= _dylib.lookupFunction<
        _c_clang_getChildDiagnostics,
        _dart_clang_getChildDiagnostics>('clang_getChildDiagnostics'))(
      D,
    );
  }

  _dart_clang_getChildDiagnostics? _clang_getChildDiagnostics;

  /// Determine the number of diagnostics produced for the given translation
  /// unit.
  int clang_getNumDiagnostics(
    ffi.Pointer<CXTranslationUnitImpl> Unit,
  ) {
    return (_clang_getNumDiagnostics ??= _dylib.lookupFunction<
        _c_clang_getNumDiagnostics,
        _dart_clang_getNumDiagnostics>('clang_getNumDiagnostics'))(
      Unit,
    );
  }

  _dart_clang_getNumDiagnostics? _clang_getNumDiagnostics;

  /// Retrieve a diagnostic associated with the given translation unit.
  ffi.Pointer<ffi.Void> clang_getDiagnostic(
    ffi.Pointer<CXTranslationUnitImpl> Unit,
    int Index,
  ) {
    return (_clang_getDiagnostic ??= _dylib.lookupFunction<
        _c_clang_getDiagnostic,
        _dart_clang_getDiagnostic>('clang_getDiagnostic'))(
      Unit,
      Index,
    );
  }

  _dart_clang_getDiagnostic? _clang_getDiagnostic;

  /// Retrieve the complete set of diagnostics associated with a translation
  /// unit.
  ffi.Pointer<ffi.Void> clang_getDiagnosticSetFromTU(
    ffi.Pointer<CXTranslationUnitImpl> Unit,
  ) {
    return (_clang_getDiagnosticSetFromTU ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticSetFromTU,
        _dart_clang_getDiagnosticSetFromTU>('clang_getDiagnosticSetFromTU'))(
      Unit,
    );
  }

  _dart_clang_getDiagnosticSetFromTU? _clang_getDiagnosticSetFromTU;

  /// Destroy a diagnostic.
  void clang_disposeDiagnostic(
    ffi.Pointer<ffi.Void> Diagnostic,
  ) {
    return (_clang_disposeDiagnostic ??= _dylib.lookupFunction<
        _c_clang_disposeDiagnostic,
        _dart_clang_disposeDiagnostic>('clang_disposeDiagnostic'))(
      Diagnostic,
    );
  }

  _dart_clang_disposeDiagnostic? _clang_disposeDiagnostic;

  /// Format the given diagnostic in a manner that is suitable for display.
  CXString clang_formatDiagnostic(
    ffi.Pointer<ffi.Void> Diagnostic,
    int Options,
  ) {
    return (_clang_formatDiagnostic ??= _dylib.lookupFunction<
        _c_clang_formatDiagnostic,
        _dart_clang_formatDiagnostic>('clang_formatDiagnostic'))(
      Diagnostic,
      Options,
    );
  }

  _dart_clang_formatDiagnostic? _clang_formatDiagnostic;

  /// Retrieve the set of display options most similar to the default behavior
  /// of the clang compiler.
  int clang_defaultDiagnosticDisplayOptions() {
    return (_clang_defaultDiagnosticDisplayOptions ??= _dylib.lookupFunction<
            _c_clang_defaultDiagnosticDisplayOptions,
            _dart_clang_defaultDiagnosticDisplayOptions>(
        'clang_defaultDiagnosticDisplayOptions'))();
  }

  _dart_clang_defaultDiagnosticDisplayOptions?
      _clang_defaultDiagnosticDisplayOptions;

  /// Determine the severity of the given diagnostic.
  int clang_getDiagnosticSeverity(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticSeverity ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticSeverity,
        _dart_clang_getDiagnosticSeverity>('clang_getDiagnosticSeverity'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticSeverity? _clang_getDiagnosticSeverity;

  /// Retrieve the source location of the given diagnostic.
  CXSourceLocation clang_getDiagnosticLocation(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticLocation ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticLocation,
        _dart_clang_getDiagnosticLocation>('clang_getDiagnosticLocation'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticLocation? _clang_getDiagnosticLocation;

  /// Retrieve the text of the given diagnostic.
  CXString clang_getDiagnosticSpelling(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticSpelling ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticSpelling,
        _dart_clang_getDiagnosticSpelling>('clang_getDiagnosticSpelling'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticSpelling? _clang_getDiagnosticSpelling;

  /// Retrieve the name of the command-line option that enabled this diagnostic.
  CXString clang_getDiagnosticOption(
    ffi.Pointer<ffi.Void> Diag,
    ffi.Pointer<CXString> Disable,
  ) {
    return (_clang_getDiagnosticOption ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticOption,
        _dart_clang_getDiagnosticOption>('clang_getDiagnosticOption'))(
      Diag,
      Disable,
    );
  }

  _dart_clang_getDiagnosticOption? _clang_getDiagnosticOption;

  /// Retrieve the category number for this diagnostic.
  int clang_getDiagnosticCategory(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticCategory ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticCategory,
        _dart_clang_getDiagnosticCategory>('clang_getDiagnosticCategory'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticCategory? _clang_getDiagnosticCategory;

  /// Retrieve the name of a particular diagnostic category. This is now
  /// deprecated. Use clang_getDiagnosticCategoryText() instead.
  CXString clang_getDiagnosticCategoryName(
    int Category,
  ) {
    return (_clang_getDiagnosticCategoryName ??= _dylib.lookupFunction<
            _c_clang_getDiagnosticCategoryName,
            _dart_clang_getDiagnosticCategoryName>(
        'clang_getDiagnosticCategoryName'))(
      Category,
    );
  }

  _dart_clang_getDiagnosticCategoryName? _clang_getDiagnosticCategoryName;

  /// Retrieve the diagnostic category text for a given diagnostic.
  CXString clang_getDiagnosticCategoryText(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticCategoryText ??= _dylib.lookupFunction<
            _c_clang_getDiagnosticCategoryText,
            _dart_clang_getDiagnosticCategoryText>(
        'clang_getDiagnosticCategoryText'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticCategoryText? _clang_getDiagnosticCategoryText;

  /// Determine the number of source ranges associated with the given
  /// diagnostic.
  int clang_getDiagnosticNumRanges(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_getDiagnosticNumRanges ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticNumRanges,
        _dart_clang_getDiagnosticNumRanges>('clang_getDiagnosticNumRanges'))(
      arg0,
    );
  }

  _dart_clang_getDiagnosticNumRanges? _clang_getDiagnosticNumRanges;

  /// Retrieve a source range associated with the diagnostic.
  CXSourceRange clang_getDiagnosticRange(
    ffi.Pointer<ffi.Void> Diagnostic,
    int Range,
  ) {
    return (_clang_getDiagnosticRange ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticRange,
        _dart_clang_getDiagnosticRange>('clang_getDiagnosticRange'))(
      Diagnostic,
      Range,
    );
  }

  _dart_clang_getDiagnosticRange? _clang_getDiagnosticRange;

  /// Determine the number of fix-it hints associated with the given diagnostic.
  int clang_getDiagnosticNumFixIts(
    ffi.Pointer<ffi.Void> Diagnostic,
  ) {
    return (_clang_getDiagnosticNumFixIts ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticNumFixIts,
        _dart_clang_getDiagnosticNumFixIts>('clang_getDiagnosticNumFixIts'))(
      Diagnostic,
    );
  }

  _dart_clang_getDiagnosticNumFixIts? _clang_getDiagnosticNumFixIts;

  /// Retrieve the replacement information for a given fix-it.
  CXString clang_getDiagnosticFixIt(
    ffi.Pointer<ffi.Void> Diagnostic,
    int FixIt,
    ffi.Pointer<CXSourceRange> ReplacementRange,
  ) {
    return (_clang_getDiagnosticFixIt ??= _dylib.lookupFunction<
        _c_clang_getDiagnosticFixIt,
        _dart_clang_getDiagnosticFixIt>('clang_getDiagnosticFixIt'))(
      Diagnostic,
      FixIt,
      ReplacementRange,
    );
  }

  _dart_clang_getDiagnosticFixIt? _clang_getDiagnosticFixIt;

  /// Get the original translation unit source file name.
  CXString clang_getTranslationUnitSpelling(
    ffi.Pointer<CXTranslationUnitImpl> CTUnit,
  ) {
    return (_clang_getTranslationUnitSpelling ??= _dylib.lookupFunction<
            _c_clang_getTranslationUnitSpelling,
            _dart_clang_getTranslationUnitSpelling>(
        'clang_getTranslationUnitSpelling'))(
      CTUnit,
    );
  }

  _dart_clang_getTranslationUnitSpelling? _clang_getTranslationUnitSpelling;

  /// Return the CXTranslationUnit for a given source file and the provided
  /// command line arguments one would pass to the compiler.
  ffi.Pointer<CXTranslationUnitImpl> clang_createTranslationUnitFromSourceFile(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> source_filename,
    int num_clang_command_line_args,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> clang_command_line_args,
    int num_unsaved_files,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
  ) {
    return (_clang_createTranslationUnitFromSourceFile ??=
        _dylib.lookupFunction<_c_clang_createTranslationUnitFromSourceFile,
                _dart_clang_createTranslationUnitFromSourceFile>(
            'clang_createTranslationUnitFromSourceFile'))(
      CIdx,
      source_filename,
      num_clang_command_line_args,
      clang_command_line_args,
      num_unsaved_files,
      unsaved_files,
    );
  }

  _dart_clang_createTranslationUnitFromSourceFile?
      _clang_createTranslationUnitFromSourceFile;

  /// Same as clang_createTranslationUnit2, but returns the CXTranslationUnit
  /// instead of an error code. In case of an error this routine returns a NULL
  /// CXTranslationUnit, without further detailed error codes.
  ffi.Pointer<CXTranslationUnitImpl> clang_createTranslationUnit(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> ast_filename,
  ) {
    return (_clang_createTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_createTranslationUnit,
        _dart_clang_createTranslationUnit>('clang_createTranslationUnit'))(
      CIdx,
      ast_filename,
    );
  }

  _dart_clang_createTranslationUnit? _clang_createTranslationUnit;

  /// Create a translation unit from an AST file ( -emit-ast).
  int clang_createTranslationUnit2(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> ast_filename,
    ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  ) {
    return (_clang_createTranslationUnit2 ??= _dylib.lookupFunction<
        _c_clang_createTranslationUnit2,
        _dart_clang_createTranslationUnit2>('clang_createTranslationUnit2'))(
      CIdx,
      ast_filename,
      out_TU,
    );
  }

  _dart_clang_createTranslationUnit2? _clang_createTranslationUnit2;

  /// Returns the set of flags that is suitable for parsing a translation unit
  /// that is being edited.
  int clang_defaultEditingTranslationUnitOptions() {
    return (_clang_defaultEditingTranslationUnitOptions ??=
        _dylib.lookupFunction<_c_clang_defaultEditingTranslationUnitOptions,
                _dart_clang_defaultEditingTranslationUnitOptions>(
            'clang_defaultEditingTranslationUnitOptions'))();
  }

  _dart_clang_defaultEditingTranslationUnitOptions?
      _clang_defaultEditingTranslationUnitOptions;

  /// Same as clang_parseTranslationUnit2, but returns the CXTranslationUnit
  /// instead of an error code. In case of an error this routine returns a NULL
  /// CXTranslationUnit, without further detailed error codes.
  ffi.Pointer<CXTranslationUnitImpl> clang_parseTranslationUnit(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> source_filename,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
    int num_command_line_args,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    int options,
  ) {
    return (_clang_parseTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_parseTranslationUnit,
        _dart_clang_parseTranslationUnit>('clang_parseTranslationUnit'))(
      CIdx,
      source_filename,
      command_line_args,
      num_command_line_args,
      unsaved_files,
      num_unsaved_files,
      options,
    );
  }

  _dart_clang_parseTranslationUnit? _clang_parseTranslationUnit;

  /// Parse the given source file and the translation unit corresponding to that
  /// file.
  int clang_parseTranslationUnit2(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> source_filename,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
    int num_command_line_args,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    int options,
    ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  ) {
    return (_clang_parseTranslationUnit2 ??= _dylib.lookupFunction<
        _c_clang_parseTranslationUnit2,
        _dart_clang_parseTranslationUnit2>('clang_parseTranslationUnit2'))(
      CIdx,
      source_filename,
      command_line_args,
      num_command_line_args,
      unsaved_files,
      num_unsaved_files,
      options,
      out_TU,
    );
  }

  _dart_clang_parseTranslationUnit2? _clang_parseTranslationUnit2;

  /// Same as clang_parseTranslationUnit2 but requires a full command line for
  /// command_line_args including argv[0]. This is useful if the standard
  /// library paths are relative to the binary.
  int clang_parseTranslationUnit2FullArgv(
    ffi.Pointer<ffi.Void> CIdx,
    ffi.Pointer<ffi.Int8> source_filename,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
    int num_command_line_args,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    int options,
    ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  ) {
    return (_clang_parseTranslationUnit2FullArgv ??= _dylib.lookupFunction<
            _c_clang_parseTranslationUnit2FullArgv,
            _dart_clang_parseTranslationUnit2FullArgv>(
        'clang_parseTranslationUnit2FullArgv'))(
      CIdx,
      source_filename,
      command_line_args,
      num_command_line_args,
      unsaved_files,
      num_unsaved_files,
      options,
      out_TU,
    );
  }

  _dart_clang_parseTranslationUnit2FullArgv?
      _clang_parseTranslationUnit2FullArgv;

  /// Returns the set of flags that is suitable for saving a translation unit.
  int clang_defaultSaveOptions(
    ffi.Pointer<CXTranslationUnitImpl> TU,
  ) {
    return (_clang_defaultSaveOptions ??= _dylib.lookupFunction<
        _c_clang_defaultSaveOptions,
        _dart_clang_defaultSaveOptions>('clang_defaultSaveOptions'))(
      TU,
    );
  }

  _dart_clang_defaultSaveOptions? _clang_defaultSaveOptions;

  /// Saves a translation unit into a serialized representation of that
  /// translation unit on disk.
  int clang_saveTranslationUnit(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    ffi.Pointer<ffi.Int8> FileName,
    int options,
  ) {
    return (_clang_saveTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_saveTranslationUnit,
        _dart_clang_saveTranslationUnit>('clang_saveTranslationUnit'))(
      TU,
      FileName,
      options,
    );
  }

  _dart_clang_saveTranslationUnit? _clang_saveTranslationUnit;

  /// Suspend a translation unit in order to free memory associated with it.
  int clang_suspendTranslationUnit(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
  ) {
    return (_clang_suspendTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_suspendTranslationUnit,
        _dart_clang_suspendTranslationUnit>('clang_suspendTranslationUnit'))(
      arg0,
    );
  }

  _dart_clang_suspendTranslationUnit? _clang_suspendTranslationUnit;

  /// Destroy the specified CXTranslationUnit object.
  void clang_disposeTranslationUnit(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
  ) {
    return (_clang_disposeTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_disposeTranslationUnit,
        _dart_clang_disposeTranslationUnit>('clang_disposeTranslationUnit'))(
      arg0,
    );
  }

  _dart_clang_disposeTranslationUnit? _clang_disposeTranslationUnit;

  /// Returns the set of flags that is suitable for reparsing a translation
  /// unit.
  int clang_defaultReparseOptions(
    ffi.Pointer<CXTranslationUnitImpl> TU,
  ) {
    return (_clang_defaultReparseOptions ??= _dylib.lookupFunction<
        _c_clang_defaultReparseOptions,
        _dart_clang_defaultReparseOptions>('clang_defaultReparseOptions'))(
      TU,
    );
  }

  _dart_clang_defaultReparseOptions? _clang_defaultReparseOptions;

  /// Reparse the source files that produced this translation unit.
  int clang_reparseTranslationUnit(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    int num_unsaved_files,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int options,
  ) {
    return (_clang_reparseTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_reparseTranslationUnit,
        _dart_clang_reparseTranslationUnit>('clang_reparseTranslationUnit'))(
      TU,
      num_unsaved_files,
      unsaved_files,
      options,
    );
  }

  _dart_clang_reparseTranslationUnit? _clang_reparseTranslationUnit;

  /// Returns the human-readable null-terminated C string that represents the
  /// name of the memory category. This string should never be freed.
  ffi.Pointer<ffi.Int8> clang_getTUResourceUsageName(
    int kind,
  ) {
    return (_clang_getTUResourceUsageName ??= _dylib.lookupFunction<
        _c_clang_getTUResourceUsageName,
        _dart_clang_getTUResourceUsageName>('clang_getTUResourceUsageName'))(
      kind,
    );
  }

  _dart_clang_getTUResourceUsageName? _clang_getTUResourceUsageName;

  /// Return the memory usage of a translation unit. This object should be
  /// released with clang_disposeCXTUResourceUsage().
  CXTUResourceUsage clang_getCXTUResourceUsage(
    ffi.Pointer<CXTranslationUnitImpl> TU,
  ) {
    return (_clang_getCXTUResourceUsage ??= _dylib.lookupFunction<
        _c_clang_getCXTUResourceUsage,
        _dart_clang_getCXTUResourceUsage>('clang_getCXTUResourceUsage'))(
      TU,
    );
  }

  _dart_clang_getCXTUResourceUsage? _clang_getCXTUResourceUsage;

  void clang_disposeCXTUResourceUsage(
    CXTUResourceUsage usage,
  ) {
    return (_clang_disposeCXTUResourceUsage ??= _dylib.lookupFunction<
            _c_clang_disposeCXTUResourceUsage,
            _dart_clang_disposeCXTUResourceUsage>(
        'clang_disposeCXTUResourceUsage'))(
      usage,
    );
  }

  _dart_clang_disposeCXTUResourceUsage? _clang_disposeCXTUResourceUsage;

  /// Get target information for this translation unit.
  ffi.Pointer<CXTargetInfoImpl> clang_getTranslationUnitTargetInfo(
    ffi.Pointer<CXTranslationUnitImpl> CTUnit,
  ) {
    return (_clang_getTranslationUnitTargetInfo ??= _dylib.lookupFunction<
            _c_clang_getTranslationUnitTargetInfo,
            _dart_clang_getTranslationUnitTargetInfo>(
        'clang_getTranslationUnitTargetInfo'))(
      CTUnit,
    );
  }

  _dart_clang_getTranslationUnitTargetInfo? _clang_getTranslationUnitTargetInfo;

  /// Destroy the CXTargetInfo object.
  void clang_TargetInfo_dispose(
    ffi.Pointer<CXTargetInfoImpl> Info,
  ) {
    return (_clang_TargetInfo_dispose ??= _dylib.lookupFunction<
        _c_clang_TargetInfo_dispose,
        _dart_clang_TargetInfo_dispose>('clang_TargetInfo_dispose'))(
      Info,
    );
  }

  _dart_clang_TargetInfo_dispose? _clang_TargetInfo_dispose;

  /// Get the normalized target triple as a string.
  CXString clang_TargetInfo_getTriple(
    ffi.Pointer<CXTargetInfoImpl> Info,
  ) {
    return (_clang_TargetInfo_getTriple ??= _dylib.lookupFunction<
        _c_clang_TargetInfo_getTriple,
        _dart_clang_TargetInfo_getTriple>('clang_TargetInfo_getTriple'))(
      Info,
    );
  }

  _dart_clang_TargetInfo_getTriple? _clang_TargetInfo_getTriple;

  /// Get the pointer width of the target in bits.
  int clang_TargetInfo_getPointerWidth(
    ffi.Pointer<CXTargetInfoImpl> Info,
  ) {
    return (_clang_TargetInfo_getPointerWidth ??= _dylib.lookupFunction<
            _c_clang_TargetInfo_getPointerWidth,
            _dart_clang_TargetInfo_getPointerWidth>(
        'clang_TargetInfo_getPointerWidth'))(
      Info,
    );
  }

  _dart_clang_TargetInfo_getPointerWidth? _clang_TargetInfo_getPointerWidth;

  /// Retrieve the NULL cursor, which represents no entity.
  CXCursor clang_getNullCursor() {
    return (_clang_getNullCursor ??= _dylib.lookupFunction<
        _c_clang_getNullCursor,
        _dart_clang_getNullCursor>('clang_getNullCursor'))();
  }

  _dart_clang_getNullCursor? _clang_getNullCursor;

  /// Retrieve the cursor that represents the given translation unit.
  CXCursor clang_getTranslationUnitCursor(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
  ) {
    return (_clang_getTranslationUnitCursor ??= _dylib.lookupFunction<
            _c_clang_getTranslationUnitCursor,
            _dart_clang_getTranslationUnitCursor>(
        'clang_getTranslationUnitCursor'))(
      arg0,
    );
  }

  _dart_clang_getTranslationUnitCursor? _clang_getTranslationUnitCursor;

  /// Determine whether two cursors are equivalent.
  int clang_equalCursors(
    CXCursor arg0,
    CXCursor arg1,
  ) {
    return (_clang_equalCursors ??=
        _dylib.lookupFunction<_c_clang_equalCursors, _dart_clang_equalCursors>(
            'clang_equalCursors'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_equalCursors? _clang_equalCursors;

  /// Returns non-zero if cursor is null.
  int clang_Cursor_isNull(
    CXCursor cursor,
  ) {
    return (_clang_Cursor_isNull ??= _dylib.lookupFunction<
        _c_clang_Cursor_isNull,
        _dart_clang_Cursor_isNull>('clang_Cursor_isNull'))(
      cursor,
    );
  }

  _dart_clang_Cursor_isNull? _clang_Cursor_isNull;

  /// Compute a hash value for the given cursor.
  int clang_hashCursor(
    CXCursor arg0,
  ) {
    return (_clang_hashCursor ??=
        _dylib.lookupFunction<_c_clang_hashCursor, _dart_clang_hashCursor>(
            'clang_hashCursor'))(
      arg0,
    );
  }

  _dart_clang_hashCursor? _clang_hashCursor;

  /// Retrieve the kind of the given cursor.
  int clang_getCursorKind(
    CXCursor arg0,
  ) {
    return (_clang_getCursorKind ??= _dylib.lookupFunction<
        _c_clang_getCursorKind,
        _dart_clang_getCursorKind>('clang_getCursorKind'))(
      arg0,
    );
  }

  _dart_clang_getCursorKind? _clang_getCursorKind;

  /// Determine whether the given cursor kind represents a declaration.
  int clang_isDeclaration(
    int arg0,
  ) {
    return (_clang_isDeclaration ??= _dylib.lookupFunction<
        _c_clang_isDeclaration,
        _dart_clang_isDeclaration>('clang_isDeclaration'))(
      arg0,
    );
  }

  _dart_clang_isDeclaration? _clang_isDeclaration;

  /// Determine whether the given declaration is invalid.
  int clang_isInvalidDeclaration(
    CXCursor arg0,
  ) {
    return (_clang_isInvalidDeclaration ??= _dylib.lookupFunction<
        _c_clang_isInvalidDeclaration,
        _dart_clang_isInvalidDeclaration>('clang_isInvalidDeclaration'))(
      arg0,
    );
  }

  _dart_clang_isInvalidDeclaration? _clang_isInvalidDeclaration;

  /// Determine whether the given cursor kind represents a simple reference.
  int clang_isReference(
    int arg0,
  ) {
    return (_clang_isReference ??=
        _dylib.lookupFunction<_c_clang_isReference, _dart_clang_isReference>(
            'clang_isReference'))(
      arg0,
    );
  }

  _dart_clang_isReference? _clang_isReference;

  /// Determine whether the given cursor kind represents an expression.
  int clang_isExpression(
    int arg0,
  ) {
    return (_clang_isExpression ??=
        _dylib.lookupFunction<_c_clang_isExpression, _dart_clang_isExpression>(
            'clang_isExpression'))(
      arg0,
    );
  }

  _dart_clang_isExpression? _clang_isExpression;

  /// Determine whether the given cursor kind represents a statement.
  int clang_isStatement(
    int arg0,
  ) {
    return (_clang_isStatement ??=
        _dylib.lookupFunction<_c_clang_isStatement, _dart_clang_isStatement>(
            'clang_isStatement'))(
      arg0,
    );
  }

  _dart_clang_isStatement? _clang_isStatement;

  /// Determine whether the given cursor kind represents an attribute.
  int clang_isAttribute(
    int arg0,
  ) {
    return (_clang_isAttribute ??=
        _dylib.lookupFunction<_c_clang_isAttribute, _dart_clang_isAttribute>(
            'clang_isAttribute'))(
      arg0,
    );
  }

  _dart_clang_isAttribute? _clang_isAttribute;

  /// Determine whether the given cursor has any attributes.
  int clang_Cursor_hasAttrs(
    CXCursor C,
  ) {
    return (_clang_Cursor_hasAttrs ??= _dylib.lookupFunction<
        _c_clang_Cursor_hasAttrs,
        _dart_clang_Cursor_hasAttrs>('clang_Cursor_hasAttrs'))(
      C,
    );
  }

  _dart_clang_Cursor_hasAttrs? _clang_Cursor_hasAttrs;

  /// Determine whether the given cursor kind represents an invalid cursor.
  int clang_isInvalid(
    int arg0,
  ) {
    return (_clang_isInvalid ??=
        _dylib.lookupFunction<_c_clang_isInvalid, _dart_clang_isInvalid>(
            'clang_isInvalid'))(
      arg0,
    );
  }

  _dart_clang_isInvalid? _clang_isInvalid;

  /// Determine whether the given cursor kind represents a translation unit.
  int clang_isTranslationUnit(
    int arg0,
  ) {
    return (_clang_isTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_isTranslationUnit,
        _dart_clang_isTranslationUnit>('clang_isTranslationUnit'))(
      arg0,
    );
  }

  _dart_clang_isTranslationUnit? _clang_isTranslationUnit;

  /// * Determine whether the given cursor represents a preprocessing element,
  /// such as a preprocessor directive or macro instantiation.
  int clang_isPreprocessing(
    int arg0,
  ) {
    return (_clang_isPreprocessing ??= _dylib.lookupFunction<
        _c_clang_isPreprocessing,
        _dart_clang_isPreprocessing>('clang_isPreprocessing'))(
      arg0,
    );
  }

  _dart_clang_isPreprocessing? _clang_isPreprocessing;

  /// * Determine whether the given cursor represents a currently unexposed
  /// piece of the AST (e.g., CXCursor_UnexposedStmt).
  int clang_isUnexposed(
    int arg0,
  ) {
    return (_clang_isUnexposed ??=
        _dylib.lookupFunction<_c_clang_isUnexposed, _dart_clang_isUnexposed>(
            'clang_isUnexposed'))(
      arg0,
    );
  }

  _dart_clang_isUnexposed? _clang_isUnexposed;

  /// Determine the linkage of the entity referred to by a given cursor.
  int clang_getCursorLinkage(
    CXCursor cursor,
  ) {
    return (_clang_getCursorLinkage ??= _dylib.lookupFunction<
        _c_clang_getCursorLinkage,
        _dart_clang_getCursorLinkage>('clang_getCursorLinkage'))(
      cursor,
    );
  }

  _dart_clang_getCursorLinkage? _clang_getCursorLinkage;

  /// Describe the visibility of the entity referred to by a cursor.
  int clang_getCursorVisibility(
    CXCursor cursor,
  ) {
    return (_clang_getCursorVisibility ??= _dylib.lookupFunction<
        _c_clang_getCursorVisibility,
        _dart_clang_getCursorVisibility>('clang_getCursorVisibility'))(
      cursor,
    );
  }

  _dart_clang_getCursorVisibility? _clang_getCursorVisibility;

  /// Determine the availability of the entity that this cursor refers to,
  /// taking the current target platform into account.
  int clang_getCursorAvailability(
    CXCursor cursor,
  ) {
    return (_clang_getCursorAvailability ??= _dylib.lookupFunction<
        _c_clang_getCursorAvailability,
        _dart_clang_getCursorAvailability>('clang_getCursorAvailability'))(
      cursor,
    );
  }

  _dart_clang_getCursorAvailability? _clang_getCursorAvailability;

  /// Determine the availability of the entity that this cursor refers to on any
  /// platforms for which availability information is known.
  int clang_getCursorPlatformAvailability(
    CXCursor cursor,
    ffi.Pointer<ffi.Int32> always_deprecated,
    ffi.Pointer<CXString> deprecated_message,
    ffi.Pointer<ffi.Int32> always_unavailable,
    ffi.Pointer<CXString> unavailable_message,
    ffi.Pointer<CXPlatformAvailability> availability,
    int availability_size,
  ) {
    return (_clang_getCursorPlatformAvailability ??= _dylib.lookupFunction<
            _c_clang_getCursorPlatformAvailability,
            _dart_clang_getCursorPlatformAvailability>(
        'clang_getCursorPlatformAvailability'))(
      cursor,
      always_deprecated,
      deprecated_message,
      always_unavailable,
      unavailable_message,
      availability,
      availability_size,
    );
  }

  _dart_clang_getCursorPlatformAvailability?
      _clang_getCursorPlatformAvailability;

  /// Free the memory associated with a CXPlatformAvailability structure.
  void clang_disposeCXPlatformAvailability(
    ffi.Pointer<CXPlatformAvailability> availability,
  ) {
    return (_clang_disposeCXPlatformAvailability ??= _dylib.lookupFunction<
            _c_clang_disposeCXPlatformAvailability,
            _dart_clang_disposeCXPlatformAvailability>(
        'clang_disposeCXPlatformAvailability'))(
      availability,
    );
  }

  _dart_clang_disposeCXPlatformAvailability?
      _clang_disposeCXPlatformAvailability;

  /// Determine the "language" of the entity referred to by a given cursor.
  int clang_getCursorLanguage(
    CXCursor cursor,
  ) {
    return (_clang_getCursorLanguage ??= _dylib.lookupFunction<
        _c_clang_getCursorLanguage,
        _dart_clang_getCursorLanguage>('clang_getCursorLanguage'))(
      cursor,
    );
  }

  _dart_clang_getCursorLanguage? _clang_getCursorLanguage;

  /// Determine the "thread-local storage (TLS) kind" of the declaration
  /// referred to by a cursor.
  int clang_getCursorTLSKind(
    CXCursor cursor,
  ) {
    return (_clang_getCursorTLSKind ??= _dylib.lookupFunction<
        _c_clang_getCursorTLSKind,
        _dart_clang_getCursorTLSKind>('clang_getCursorTLSKind'))(
      cursor,
    );
  }

  _dart_clang_getCursorTLSKind? _clang_getCursorTLSKind;

  /// Returns the translation unit that a cursor originated from.
  ffi.Pointer<CXTranslationUnitImpl> clang_Cursor_getTranslationUnit(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getTranslationUnit ??= _dylib.lookupFunction<
            _c_clang_Cursor_getTranslationUnit,
            _dart_clang_Cursor_getTranslationUnit>(
        'clang_Cursor_getTranslationUnit'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getTranslationUnit? _clang_Cursor_getTranslationUnit;

  /// Creates an empty CXCursorSet.
  ffi.Pointer<CXCursorSetImpl> clang_createCXCursorSet() {
    return (_clang_createCXCursorSet ??= _dylib.lookupFunction<
        _c_clang_createCXCursorSet,
        _dart_clang_createCXCursorSet>('clang_createCXCursorSet'))();
  }

  _dart_clang_createCXCursorSet? _clang_createCXCursorSet;

  /// Disposes a CXCursorSet and releases its associated memory.
  void clang_disposeCXCursorSet(
    ffi.Pointer<CXCursorSetImpl> cset,
  ) {
    return (_clang_disposeCXCursorSet ??= _dylib.lookupFunction<
        _c_clang_disposeCXCursorSet,
        _dart_clang_disposeCXCursorSet>('clang_disposeCXCursorSet'))(
      cset,
    );
  }

  _dart_clang_disposeCXCursorSet? _clang_disposeCXCursorSet;

  /// Queries a CXCursorSet to see if it contains a specific CXCursor.
  int clang_CXCursorSet_contains(
    ffi.Pointer<CXCursorSetImpl> cset,
    CXCursor cursor,
  ) {
    return (_clang_CXCursorSet_contains ??= _dylib.lookupFunction<
        _c_clang_CXCursorSet_contains,
        _dart_clang_CXCursorSet_contains>('clang_CXCursorSet_contains'))(
      cset,
      cursor,
    );
  }

  _dart_clang_CXCursorSet_contains? _clang_CXCursorSet_contains;

  /// Inserts a CXCursor into a CXCursorSet.
  int clang_CXCursorSet_insert(
    ffi.Pointer<CXCursorSetImpl> cset,
    CXCursor cursor,
  ) {
    return (_clang_CXCursorSet_insert ??= _dylib.lookupFunction<
        _c_clang_CXCursorSet_insert,
        _dart_clang_CXCursorSet_insert>('clang_CXCursorSet_insert'))(
      cset,
      cursor,
    );
  }

  _dart_clang_CXCursorSet_insert? _clang_CXCursorSet_insert;

  /// Determine the semantic parent of the given cursor.
  CXCursor clang_getCursorSemanticParent(
    CXCursor cursor,
  ) {
    return (_clang_getCursorSemanticParent ??= _dylib.lookupFunction<
        _c_clang_getCursorSemanticParent,
        _dart_clang_getCursorSemanticParent>('clang_getCursorSemanticParent'))(
      cursor,
    );
  }

  _dart_clang_getCursorSemanticParent? _clang_getCursorSemanticParent;

  /// Determine the lexical parent of the given cursor.
  CXCursor clang_getCursorLexicalParent(
    CXCursor cursor,
  ) {
    return (_clang_getCursorLexicalParent ??= _dylib.lookupFunction<
        _c_clang_getCursorLexicalParent,
        _dart_clang_getCursorLexicalParent>('clang_getCursorLexicalParent'))(
      cursor,
    );
  }

  _dart_clang_getCursorLexicalParent? _clang_getCursorLexicalParent;

  /// Determine the set of methods that are overridden by the given method.
  void clang_getOverriddenCursors(
    CXCursor cursor,
    ffi.Pointer<ffi.Pointer<CXCursor>> overridden,
    ffi.Pointer<ffi.Uint32> num_overridden,
  ) {
    return (_clang_getOverriddenCursors ??= _dylib.lookupFunction<
        _c_clang_getOverriddenCursors,
        _dart_clang_getOverriddenCursors>('clang_getOverriddenCursors'))(
      cursor,
      overridden,
      num_overridden,
    );
  }

  _dart_clang_getOverriddenCursors? _clang_getOverriddenCursors;

  /// Free the set of overridden cursors returned by
  /// clang_getOverriddenCursors().
  void clang_disposeOverriddenCursors(
    ffi.Pointer<CXCursor> overridden,
  ) {
    return (_clang_disposeOverriddenCursors ??= _dylib.lookupFunction<
            _c_clang_disposeOverriddenCursors,
            _dart_clang_disposeOverriddenCursors>(
        'clang_disposeOverriddenCursors'))(
      overridden,
    );
  }

  _dart_clang_disposeOverriddenCursors? _clang_disposeOverriddenCursors;

  /// Retrieve the file that is included by the given inclusion directive
  /// cursor.
  ffi.Pointer<ffi.Void> clang_getIncludedFile(
    CXCursor cursor,
  ) {
    return (_clang_getIncludedFile ??= _dylib.lookupFunction<
        _c_clang_getIncludedFile,
        _dart_clang_getIncludedFile>('clang_getIncludedFile'))(
      cursor,
    );
  }

  _dart_clang_getIncludedFile? _clang_getIncludedFile;

  /// Map a source location to the cursor that describes the entity at that
  /// location in the source code.
  CXCursor clang_getCursor(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    CXSourceLocation arg1,
  ) {
    return (_clang_getCursor ??=
        _dylib.lookupFunction<_c_clang_getCursor, _dart_clang_getCursor>(
            'clang_getCursor'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_getCursor? _clang_getCursor;

  /// Retrieve the physical location of the source constructor referenced by the
  /// given cursor.
  CXSourceLocation clang_getCursorLocation(
    CXCursor arg0,
  ) {
    return (_clang_getCursorLocation ??= _dylib.lookupFunction<
        _c_clang_getCursorLocation,
        _dart_clang_getCursorLocation>('clang_getCursorLocation'))(
      arg0,
    );
  }

  _dart_clang_getCursorLocation? _clang_getCursorLocation;

  /// Retrieve the physical extent of the source construct referenced by the
  /// given cursor.
  CXSourceRange clang_getCursorExtent(
    CXCursor arg0,
  ) {
    return (_clang_getCursorExtent ??= _dylib.lookupFunction<
        _c_clang_getCursorExtent,
        _dart_clang_getCursorExtent>('clang_getCursorExtent'))(
      arg0,
    );
  }

  _dart_clang_getCursorExtent? _clang_getCursorExtent;

  /// Retrieve the type of a CXCursor (if any).
  CXType clang_getCursorType(
    CXCursor C,
  ) {
    return (_clang_getCursorType ??= _dylib.lookupFunction<
        _c_clang_getCursorType,
        _dart_clang_getCursorType>('clang_getCursorType'))(
      C,
    );
  }

  _dart_clang_getCursorType? _clang_getCursorType;

  /// Pretty-print the underlying type using the rules of the language of the
  /// translation unit from which it came.
  CXString clang_getTypeSpelling(
    CXType CT,
  ) {
    return (_clang_getTypeSpelling ??= _dylib.lookupFunction<
        _c_clang_getTypeSpelling,
        _dart_clang_getTypeSpelling>('clang_getTypeSpelling'))(
      CT,
    );
  }

  _dart_clang_getTypeSpelling? _clang_getTypeSpelling;

  /// Retrieve the underlying type of a typedef declaration.
  CXType clang_getTypedefDeclUnderlyingType(
    CXCursor C,
  ) {
    return (_clang_getTypedefDeclUnderlyingType ??= _dylib.lookupFunction<
            _c_clang_getTypedefDeclUnderlyingType,
            _dart_clang_getTypedefDeclUnderlyingType>(
        'clang_getTypedefDeclUnderlyingType'))(
      C,
    );
  }

  _dart_clang_getTypedefDeclUnderlyingType? _clang_getTypedefDeclUnderlyingType;

  /// Retrieve the integer type of an enum declaration.
  CXType clang_getEnumDeclIntegerType(
    CXCursor C,
  ) {
    return (_clang_getEnumDeclIntegerType ??= _dylib.lookupFunction<
        _c_clang_getEnumDeclIntegerType,
        _dart_clang_getEnumDeclIntegerType>('clang_getEnumDeclIntegerType'))(
      C,
    );
  }

  _dart_clang_getEnumDeclIntegerType? _clang_getEnumDeclIntegerType;

  /// Retrieve the integer value of an enum constant declaration as a signed
  /// long long.
  int clang_getEnumConstantDeclValue(
    CXCursor C,
  ) {
    return (_clang_getEnumConstantDeclValue ??= _dylib.lookupFunction<
            _c_clang_getEnumConstantDeclValue,
            _dart_clang_getEnumConstantDeclValue>(
        'clang_getEnumConstantDeclValue'))(
      C,
    );
  }

  _dart_clang_getEnumConstantDeclValue? _clang_getEnumConstantDeclValue;

  /// Retrieve the integer value of an enum constant declaration as an unsigned
  /// long long.
  int clang_getEnumConstantDeclUnsignedValue(
    CXCursor C,
  ) {
    return (_clang_getEnumConstantDeclUnsignedValue ??= _dylib.lookupFunction<
            _c_clang_getEnumConstantDeclUnsignedValue,
            _dart_clang_getEnumConstantDeclUnsignedValue>(
        'clang_getEnumConstantDeclUnsignedValue'))(
      C,
    );
  }

  _dart_clang_getEnumConstantDeclUnsignedValue?
      _clang_getEnumConstantDeclUnsignedValue;

  /// Retrieve the bit width of a bit field declaration as an integer.
  int clang_getFieldDeclBitWidth(
    CXCursor C,
  ) {
    return (_clang_getFieldDeclBitWidth ??= _dylib.lookupFunction<
        _c_clang_getFieldDeclBitWidth,
        _dart_clang_getFieldDeclBitWidth>('clang_getFieldDeclBitWidth'))(
      C,
    );
  }

  _dart_clang_getFieldDeclBitWidth? _clang_getFieldDeclBitWidth;

  /// Retrieve the number of non-variadic arguments associated with a given
  /// cursor.
  int clang_Cursor_getNumArguments(
    CXCursor C,
  ) {
    return (_clang_Cursor_getNumArguments ??= _dylib.lookupFunction<
        _c_clang_Cursor_getNumArguments,
        _dart_clang_Cursor_getNumArguments>('clang_Cursor_getNumArguments'))(
      C,
    );
  }

  _dart_clang_Cursor_getNumArguments? _clang_Cursor_getNumArguments;

  /// Retrieve the argument cursor of a function or method.
  CXCursor clang_Cursor_getArgument(
    CXCursor C,
    int i,
  ) {
    return (_clang_Cursor_getArgument ??= _dylib.lookupFunction<
        _c_clang_Cursor_getArgument,
        _dart_clang_Cursor_getArgument>('clang_Cursor_getArgument'))(
      C,
      i,
    );
  }

  _dart_clang_Cursor_getArgument? _clang_Cursor_getArgument;

  /// Returns the number of template args of a function decl representing a
  /// template specialization.
  int clang_Cursor_getNumTemplateArguments(
    CXCursor C,
  ) {
    return (_clang_Cursor_getNumTemplateArguments ??= _dylib.lookupFunction<
            _c_clang_Cursor_getNumTemplateArguments,
            _dart_clang_Cursor_getNumTemplateArguments>(
        'clang_Cursor_getNumTemplateArguments'))(
      C,
    );
  }

  _dart_clang_Cursor_getNumTemplateArguments?
      _clang_Cursor_getNumTemplateArguments;

  /// Retrieve the kind of the I'th template argument of the CXCursor C.
  int clang_Cursor_getTemplateArgumentKind(
    CXCursor C,
    int I,
  ) {
    return (_clang_Cursor_getTemplateArgumentKind ??= _dylib.lookupFunction<
            _c_clang_Cursor_getTemplateArgumentKind,
            _dart_clang_Cursor_getTemplateArgumentKind>(
        'clang_Cursor_getTemplateArgumentKind'))(
      C,
      I,
    );
  }

  _dart_clang_Cursor_getTemplateArgumentKind?
      _clang_Cursor_getTemplateArgumentKind;

  /// Retrieve a CXType representing the type of a TemplateArgument of a
  /// function decl representing a template specialization.
  CXType clang_Cursor_getTemplateArgumentType(
    CXCursor C,
    int I,
  ) {
    return (_clang_Cursor_getTemplateArgumentType ??= _dylib.lookupFunction<
            _c_clang_Cursor_getTemplateArgumentType,
            _dart_clang_Cursor_getTemplateArgumentType>(
        'clang_Cursor_getTemplateArgumentType'))(
      C,
      I,
    );
  }

  _dart_clang_Cursor_getTemplateArgumentType?
      _clang_Cursor_getTemplateArgumentType;

  /// Retrieve the value of an Integral TemplateArgument (of a function decl
  /// representing a template specialization) as a signed long long.
  int clang_Cursor_getTemplateArgumentValue(
    CXCursor C,
    int I,
  ) {
    return (_clang_Cursor_getTemplateArgumentValue ??= _dylib.lookupFunction<
            _c_clang_Cursor_getTemplateArgumentValue,
            _dart_clang_Cursor_getTemplateArgumentValue>(
        'clang_Cursor_getTemplateArgumentValue'))(
      C,
      I,
    );
  }

  _dart_clang_Cursor_getTemplateArgumentValue?
      _clang_Cursor_getTemplateArgumentValue;

  /// Retrieve the value of an Integral TemplateArgument (of a function decl
  /// representing a template specialization) as an unsigned long long.
  int clang_Cursor_getTemplateArgumentUnsignedValue(
    CXCursor C,
    int I,
  ) {
    return (_clang_Cursor_getTemplateArgumentUnsignedValue ??=
        _dylib.lookupFunction<_c_clang_Cursor_getTemplateArgumentUnsignedValue,
                _dart_clang_Cursor_getTemplateArgumentUnsignedValue>(
            'clang_Cursor_getTemplateArgumentUnsignedValue'))(
      C,
      I,
    );
  }

  _dart_clang_Cursor_getTemplateArgumentUnsignedValue?
      _clang_Cursor_getTemplateArgumentUnsignedValue;

  /// Determine whether two CXTypes represent the same type.
  int clang_equalTypes(
    CXType A,
    CXType B,
  ) {
    return (_clang_equalTypes ??=
        _dylib.lookupFunction<_c_clang_equalTypes, _dart_clang_equalTypes>(
            'clang_equalTypes'))(
      A,
      B,
    );
  }

  _dart_clang_equalTypes? _clang_equalTypes;

  /// Return the canonical type for a CXType.
  CXType clang_getCanonicalType(
    CXType T,
  ) {
    return (_clang_getCanonicalType ??= _dylib.lookupFunction<
        _c_clang_getCanonicalType,
        _dart_clang_getCanonicalType>('clang_getCanonicalType'))(
      T,
    );
  }

  _dart_clang_getCanonicalType? _clang_getCanonicalType;

  /// Determine whether a CXType has the "const" qualifier set, without looking
  /// through typedefs that may have added "const" at a different level.
  int clang_isConstQualifiedType(
    CXType T,
  ) {
    return (_clang_isConstQualifiedType ??= _dylib.lookupFunction<
        _c_clang_isConstQualifiedType,
        _dart_clang_isConstQualifiedType>('clang_isConstQualifiedType'))(
      T,
    );
  }

  _dart_clang_isConstQualifiedType? _clang_isConstQualifiedType;

  /// Determine whether a CXCursor that is a macro, is function like.
  int clang_Cursor_isMacroFunctionLike(
    CXCursor C,
  ) {
    return (_clang_Cursor_isMacroFunctionLike ??= _dylib.lookupFunction<
            _c_clang_Cursor_isMacroFunctionLike,
            _dart_clang_Cursor_isMacroFunctionLike>(
        'clang_Cursor_isMacroFunctionLike'))(
      C,
    );
  }

  _dart_clang_Cursor_isMacroFunctionLike? _clang_Cursor_isMacroFunctionLike;

  /// Determine whether a CXCursor that is a macro, is a builtin one.
  int clang_Cursor_isMacroBuiltin(
    CXCursor C,
  ) {
    return (_clang_Cursor_isMacroBuiltin ??= _dylib.lookupFunction<
        _c_clang_Cursor_isMacroBuiltin,
        _dart_clang_Cursor_isMacroBuiltin>('clang_Cursor_isMacroBuiltin'))(
      C,
    );
  }

  _dart_clang_Cursor_isMacroBuiltin? _clang_Cursor_isMacroBuiltin;

  /// Determine whether a CXCursor that is a function declaration, is an inline
  /// declaration.
  int clang_Cursor_isFunctionInlined(
    CXCursor C,
  ) {
    return (_clang_Cursor_isFunctionInlined ??= _dylib.lookupFunction<
            _c_clang_Cursor_isFunctionInlined,
            _dart_clang_Cursor_isFunctionInlined>(
        'clang_Cursor_isFunctionInlined'))(
      C,
    );
  }

  _dart_clang_Cursor_isFunctionInlined? _clang_Cursor_isFunctionInlined;

  /// Determine whether a CXType has the "volatile" qualifier set, without
  /// looking through typedefs that may have added "volatile" at a different
  /// level.
  int clang_isVolatileQualifiedType(
    CXType T,
  ) {
    return (_clang_isVolatileQualifiedType ??= _dylib.lookupFunction<
        _c_clang_isVolatileQualifiedType,
        _dart_clang_isVolatileQualifiedType>('clang_isVolatileQualifiedType'))(
      T,
    );
  }

  _dart_clang_isVolatileQualifiedType? _clang_isVolatileQualifiedType;

  /// Determine whether a CXType has the "restrict" qualifier set, without
  /// looking through typedefs that may have added "restrict" at a different
  /// level.
  int clang_isRestrictQualifiedType(
    CXType T,
  ) {
    return (_clang_isRestrictQualifiedType ??= _dylib.lookupFunction<
        _c_clang_isRestrictQualifiedType,
        _dart_clang_isRestrictQualifiedType>('clang_isRestrictQualifiedType'))(
      T,
    );
  }

  _dart_clang_isRestrictQualifiedType? _clang_isRestrictQualifiedType;

  /// Returns the address space of the given type.
  int clang_getAddressSpace(
    CXType T,
  ) {
    return (_clang_getAddressSpace ??= _dylib.lookupFunction<
        _c_clang_getAddressSpace,
        _dart_clang_getAddressSpace>('clang_getAddressSpace'))(
      T,
    );
  }

  _dart_clang_getAddressSpace? _clang_getAddressSpace;

  /// Returns the typedef name of the given type.
  CXString clang_getTypedefName(
    CXType CT,
  ) {
    return (_clang_getTypedefName ??= _dylib.lookupFunction<
        _c_clang_getTypedefName,
        _dart_clang_getTypedefName>('clang_getTypedefName'))(
      CT,
    );
  }

  _dart_clang_getTypedefName? _clang_getTypedefName;

  /// For pointer types, returns the type of the pointee.
  CXType clang_getPointeeType(
    CXType T,
  ) {
    return (_clang_getPointeeType ??= _dylib.lookupFunction<
        _c_clang_getPointeeType,
        _dart_clang_getPointeeType>('clang_getPointeeType'))(
      T,
    );
  }

  _dart_clang_getPointeeType? _clang_getPointeeType;

  /// Return the cursor for the declaration of the given type.
  CXCursor clang_getTypeDeclaration(
    CXType T,
  ) {
    return (_clang_getTypeDeclaration ??= _dylib.lookupFunction<
        _c_clang_getTypeDeclaration,
        _dart_clang_getTypeDeclaration>('clang_getTypeDeclaration'))(
      T,
    );
  }

  _dart_clang_getTypeDeclaration? _clang_getTypeDeclaration;

  /// Returns the Objective-C type encoding for the specified declaration.
  CXString clang_getDeclObjCTypeEncoding(
    CXCursor C,
  ) {
    return (_clang_getDeclObjCTypeEncoding ??= _dylib.lookupFunction<
        _c_clang_getDeclObjCTypeEncoding,
        _dart_clang_getDeclObjCTypeEncoding>('clang_getDeclObjCTypeEncoding'))(
      C,
    );
  }

  _dart_clang_getDeclObjCTypeEncoding? _clang_getDeclObjCTypeEncoding;

  /// Returns the Objective-C type encoding for the specified CXType.
  CXString clang_Type_getObjCEncoding(
    CXType type,
  ) {
    return (_clang_Type_getObjCEncoding ??= _dylib.lookupFunction<
        _c_clang_Type_getObjCEncoding,
        _dart_clang_Type_getObjCEncoding>('clang_Type_getObjCEncoding'))(
      type,
    );
  }

  _dart_clang_Type_getObjCEncoding? _clang_Type_getObjCEncoding;

  /// Retrieve the spelling of a given CXTypeKind.
  CXString clang_getTypeKindSpelling(
    int K,
  ) {
    return (_clang_getTypeKindSpelling ??= _dylib.lookupFunction<
        _c_clang_getTypeKindSpelling,
        _dart_clang_getTypeKindSpelling>('clang_getTypeKindSpelling'))(
      K,
    );
  }

  _dart_clang_getTypeKindSpelling? _clang_getTypeKindSpelling;

  /// Retrieve the calling convention associated with a function type.
  int clang_getFunctionTypeCallingConv(
    CXType T,
  ) {
    return (_clang_getFunctionTypeCallingConv ??= _dylib.lookupFunction<
            _c_clang_getFunctionTypeCallingConv,
            _dart_clang_getFunctionTypeCallingConv>(
        'clang_getFunctionTypeCallingConv'))(
      T,
    );
  }

  _dart_clang_getFunctionTypeCallingConv? _clang_getFunctionTypeCallingConv;

  /// Retrieve the return type associated with a function type.
  CXType clang_getResultType(
    CXType T,
  ) {
    return (_clang_getResultType ??= _dylib.lookupFunction<
        _c_clang_getResultType,
        _dart_clang_getResultType>('clang_getResultType'))(
      T,
    );
  }

  _dart_clang_getResultType? _clang_getResultType;

  /// Retrieve the exception specification type associated with a function type.
  /// This is a value of type CXCursor_ExceptionSpecificationKind.
  int clang_getExceptionSpecificationType(
    CXType T,
  ) {
    return (_clang_getExceptionSpecificationType ??= _dylib.lookupFunction<
            _c_clang_getExceptionSpecificationType,
            _dart_clang_getExceptionSpecificationType>(
        'clang_getExceptionSpecificationType'))(
      T,
    );
  }

  _dart_clang_getExceptionSpecificationType?
      _clang_getExceptionSpecificationType;

  /// Retrieve the number of non-variadic parameters associated with a function
  /// type.
  int clang_getNumArgTypes(
    CXType T,
  ) {
    return (_clang_getNumArgTypes ??= _dylib.lookupFunction<
        _c_clang_getNumArgTypes,
        _dart_clang_getNumArgTypes>('clang_getNumArgTypes'))(
      T,
    );
  }

  _dart_clang_getNumArgTypes? _clang_getNumArgTypes;

  /// Retrieve the type of a parameter of a function type.
  CXType clang_getArgType(
    CXType T,
    int i,
  ) {
    return (_clang_getArgType ??=
        _dylib.lookupFunction<_c_clang_getArgType, _dart_clang_getArgType>(
            'clang_getArgType'))(
      T,
      i,
    );
  }

  _dart_clang_getArgType? _clang_getArgType;

  /// Retrieves the base type of the ObjCObjectType.
  CXType clang_Type_getObjCObjectBaseType(
    CXType T,
  ) {
    return (_clang_Type_getObjCObjectBaseType ??= _dylib.lookupFunction<
            _c_clang_Type_getObjCObjectBaseType,
            _dart_clang_Type_getObjCObjectBaseType>(
        'clang_Type_getObjCObjectBaseType'))(
      T,
    );
  }

  _dart_clang_Type_getObjCObjectBaseType? _clang_Type_getObjCObjectBaseType;

  /// Retrieve the number of protocol references associated with an ObjC
  /// object/id.
  int clang_Type_getNumObjCProtocolRefs(
    CXType T,
  ) {
    return (_clang_Type_getNumObjCProtocolRefs ??= _dylib.lookupFunction<
            _c_clang_Type_getNumObjCProtocolRefs,
            _dart_clang_Type_getNumObjCProtocolRefs>(
        'clang_Type_getNumObjCProtocolRefs'))(
      T,
    );
  }

  _dart_clang_Type_getNumObjCProtocolRefs? _clang_Type_getNumObjCProtocolRefs;

  /// Retrieve the decl for a protocol reference for an ObjC object/id.
  CXCursor clang_Type_getObjCProtocolDecl(
    CXType T,
    int i,
  ) {
    return (_clang_Type_getObjCProtocolDecl ??= _dylib.lookupFunction<
            _c_clang_Type_getObjCProtocolDecl,
            _dart_clang_Type_getObjCProtocolDecl>(
        'clang_Type_getObjCProtocolDecl'))(
      T,
      i,
    );
  }

  _dart_clang_Type_getObjCProtocolDecl? _clang_Type_getObjCProtocolDecl;

  /// Retreive the number of type arguments associated with an ObjC object.
  int clang_Type_getNumObjCTypeArgs(
    CXType T,
  ) {
    return (_clang_Type_getNumObjCTypeArgs ??= _dylib.lookupFunction<
        _c_clang_Type_getNumObjCTypeArgs,
        _dart_clang_Type_getNumObjCTypeArgs>('clang_Type_getNumObjCTypeArgs'))(
      T,
    );
  }

  _dart_clang_Type_getNumObjCTypeArgs? _clang_Type_getNumObjCTypeArgs;

  /// Retrieve a type argument associated with an ObjC object.
  CXType clang_Type_getObjCTypeArg(
    CXType T,
    int i,
  ) {
    return (_clang_Type_getObjCTypeArg ??= _dylib.lookupFunction<
        _c_clang_Type_getObjCTypeArg,
        _dart_clang_Type_getObjCTypeArg>('clang_Type_getObjCTypeArg'))(
      T,
      i,
    );
  }

  _dart_clang_Type_getObjCTypeArg? _clang_Type_getObjCTypeArg;

  /// Return 1 if the CXType is a variadic function type, and 0 otherwise.
  int clang_isFunctionTypeVariadic(
    CXType T,
  ) {
    return (_clang_isFunctionTypeVariadic ??= _dylib.lookupFunction<
        _c_clang_isFunctionTypeVariadic,
        _dart_clang_isFunctionTypeVariadic>('clang_isFunctionTypeVariadic'))(
      T,
    );
  }

  _dart_clang_isFunctionTypeVariadic? _clang_isFunctionTypeVariadic;

  /// Retrieve the return type associated with a given cursor.
  CXType clang_getCursorResultType(
    CXCursor C,
  ) {
    return (_clang_getCursorResultType ??= _dylib.lookupFunction<
        _c_clang_getCursorResultType,
        _dart_clang_getCursorResultType>('clang_getCursorResultType'))(
      C,
    );
  }

  _dart_clang_getCursorResultType? _clang_getCursorResultType;

  /// Retrieve the exception specification type associated with a given cursor.
  /// This is a value of type CXCursor_ExceptionSpecificationKind.
  int clang_getCursorExceptionSpecificationType(
    CXCursor C,
  ) {
    return (_clang_getCursorExceptionSpecificationType ??=
        _dylib.lookupFunction<_c_clang_getCursorExceptionSpecificationType,
                _dart_clang_getCursorExceptionSpecificationType>(
            'clang_getCursorExceptionSpecificationType'))(
      C,
    );
  }

  _dart_clang_getCursorExceptionSpecificationType?
      _clang_getCursorExceptionSpecificationType;

  /// Return 1 if the CXType is a POD (plain old data) type, and 0 otherwise.
  int clang_isPODType(
    CXType T,
  ) {
    return (_clang_isPODType ??=
        _dylib.lookupFunction<_c_clang_isPODType, _dart_clang_isPODType>(
            'clang_isPODType'))(
      T,
    );
  }

  _dart_clang_isPODType? _clang_isPODType;

  /// Return the element type of an array, complex, or vector type.
  CXType clang_getElementType(
    CXType T,
  ) {
    return (_clang_getElementType ??= _dylib.lookupFunction<
        _c_clang_getElementType,
        _dart_clang_getElementType>('clang_getElementType'))(
      T,
    );
  }

  _dart_clang_getElementType? _clang_getElementType;

  /// Return the number of elements of an array or vector type.
  int clang_getNumElements(
    CXType T,
  ) {
    return (_clang_getNumElements ??= _dylib.lookupFunction<
        _c_clang_getNumElements,
        _dart_clang_getNumElements>('clang_getNumElements'))(
      T,
    );
  }

  _dart_clang_getNumElements? _clang_getNumElements;

  /// Return the element type of an array type.
  CXType clang_getArrayElementType(
    CXType T,
  ) {
    return (_clang_getArrayElementType ??= _dylib.lookupFunction<
        _c_clang_getArrayElementType,
        _dart_clang_getArrayElementType>('clang_getArrayElementType'))(
      T,
    );
  }

  _dart_clang_getArrayElementType? _clang_getArrayElementType;

  /// Return the array size of a constant array.
  int clang_getArraySize(
    CXType T,
  ) {
    return (_clang_getArraySize ??=
        _dylib.lookupFunction<_c_clang_getArraySize, _dart_clang_getArraySize>(
            'clang_getArraySize'))(
      T,
    );
  }

  _dart_clang_getArraySize? _clang_getArraySize;

  /// Retrieve the type named by the qualified-id.
  CXType clang_Type_getNamedType(
    CXType T,
  ) {
    return (_clang_Type_getNamedType ??= _dylib.lookupFunction<
        _c_clang_Type_getNamedType,
        _dart_clang_Type_getNamedType>('clang_Type_getNamedType'))(
      T,
    );
  }

  _dart_clang_Type_getNamedType? _clang_Type_getNamedType;

  /// Determine if a typedef is 'transparent' tag.
  int clang_Type_isTransparentTagTypedef(
    CXType T,
  ) {
    return (_clang_Type_isTransparentTagTypedef ??= _dylib.lookupFunction<
            _c_clang_Type_isTransparentTagTypedef,
            _dart_clang_Type_isTransparentTagTypedef>(
        'clang_Type_isTransparentTagTypedef'))(
      T,
    );
  }

  _dart_clang_Type_isTransparentTagTypedef? _clang_Type_isTransparentTagTypedef;

  /// Retrieve the nullability kind of a pointer type.
  int clang_Type_getNullability(
    CXType T,
  ) {
    return (_clang_Type_getNullability ??= _dylib.lookupFunction<
        _c_clang_Type_getNullability,
        _dart_clang_Type_getNullability>('clang_Type_getNullability'))(
      T,
    );
  }

  _dart_clang_Type_getNullability? _clang_Type_getNullability;

  /// Return the alignment of a type in bytes as per C++[expr.alignof] standard.
  int clang_Type_getAlignOf(
    CXType T,
  ) {
    return (_clang_Type_getAlignOf ??= _dylib.lookupFunction<
        _c_clang_Type_getAlignOf,
        _dart_clang_Type_getAlignOf>('clang_Type_getAlignOf'))(
      T,
    );
  }

  _dart_clang_Type_getAlignOf? _clang_Type_getAlignOf;

  /// Return the class type of an member pointer type.
  CXType clang_Type_getClassType(
    CXType T,
  ) {
    return (_clang_Type_getClassType ??= _dylib.lookupFunction<
        _c_clang_Type_getClassType,
        _dart_clang_Type_getClassType>('clang_Type_getClassType'))(
      T,
    );
  }

  _dart_clang_Type_getClassType? _clang_Type_getClassType;

  /// Return the size of a type in bytes as per C++[expr.sizeof] standard.
  int clang_Type_getSizeOf(
    CXType T,
  ) {
    return (_clang_Type_getSizeOf ??= _dylib.lookupFunction<
        _c_clang_Type_getSizeOf,
        _dart_clang_Type_getSizeOf>('clang_Type_getSizeOf'))(
      T,
    );
  }

  _dart_clang_Type_getSizeOf? _clang_Type_getSizeOf;

  /// Return the offset of a field named S in a record of type T in bits as it
  /// would be returned by __offsetof__ as per C++11[18.2p4]
  int clang_Type_getOffsetOf(
    CXType T,
    ffi.Pointer<ffi.Int8> S,
  ) {
    return (_clang_Type_getOffsetOf ??= _dylib.lookupFunction<
        _c_clang_Type_getOffsetOf,
        _dart_clang_Type_getOffsetOf>('clang_Type_getOffsetOf'))(
      T,
      S,
    );
  }

  _dart_clang_Type_getOffsetOf? _clang_Type_getOffsetOf;

  /// Return the type that was modified by this attributed type.
  CXType clang_Type_getModifiedType(
    CXType T,
  ) {
    return (_clang_Type_getModifiedType ??= _dylib.lookupFunction<
        _c_clang_Type_getModifiedType,
        _dart_clang_Type_getModifiedType>('clang_Type_getModifiedType'))(
      T,
    );
  }

  _dart_clang_Type_getModifiedType? _clang_Type_getModifiedType;

  /// Return the offset of the field represented by the Cursor.
  int clang_Cursor_getOffsetOfField(
    CXCursor C,
  ) {
    return (_clang_Cursor_getOffsetOfField ??= _dylib.lookupFunction<
        _c_clang_Cursor_getOffsetOfField,
        _dart_clang_Cursor_getOffsetOfField>('clang_Cursor_getOffsetOfField'))(
      C,
    );
  }

  _dart_clang_Cursor_getOffsetOfField? _clang_Cursor_getOffsetOfField;

  /// Determine whether the given cursor represents an anonymous tag or
  /// namespace
  int clang_Cursor_isAnonymous(
    CXCursor C,
  ) {
    return (_clang_Cursor_isAnonymous ??= _dylib.lookupFunction<
        _c_clang_Cursor_isAnonymous,
        _dart_clang_Cursor_isAnonymous>('clang_Cursor_isAnonymous'))(
      C,
    );
  }

  _dart_clang_Cursor_isAnonymous? _clang_Cursor_isAnonymous;

  /// Determine whether the given cursor represents an anonymous record
  /// declaration.
  int clang_Cursor_isAnonymousRecordDecl(
    CXCursor C,
  ) {
    return (_clang_Cursor_isAnonymousRecordDecl ??= _dylib.lookupFunction<
            _c_clang_Cursor_isAnonymousRecordDecl,
            _dart_clang_Cursor_isAnonymousRecordDecl>(
        'clang_Cursor_isAnonymousRecordDecl'))(
      C,
    );
  }

  _dart_clang_Cursor_isAnonymousRecordDecl? _clang_Cursor_isAnonymousRecordDecl;

  /// Determine whether the given cursor represents an inline namespace
  /// declaration.
  int clang_Cursor_isInlineNamespace(
    CXCursor C,
  ) {
    return (_clang_Cursor_isInlineNamespace ??= _dylib.lookupFunction<
            _c_clang_Cursor_isInlineNamespace,
            _dart_clang_Cursor_isInlineNamespace>(
        'clang_Cursor_isInlineNamespace'))(
      C,
    );
  }

  _dart_clang_Cursor_isInlineNamespace? _clang_Cursor_isInlineNamespace;

  /// Returns the number of template arguments for given template
  /// specialization, or -1 if type T is not a template specialization.
  int clang_Type_getNumTemplateArguments(
    CXType T,
  ) {
    return (_clang_Type_getNumTemplateArguments ??= _dylib.lookupFunction<
            _c_clang_Type_getNumTemplateArguments,
            _dart_clang_Type_getNumTemplateArguments>(
        'clang_Type_getNumTemplateArguments'))(
      T,
    );
  }

  _dart_clang_Type_getNumTemplateArguments? _clang_Type_getNumTemplateArguments;

  /// Returns the type template argument of a template class specialization at
  /// given index.
  CXType clang_Type_getTemplateArgumentAsType(
    CXType T,
    int i,
  ) {
    return (_clang_Type_getTemplateArgumentAsType ??= _dylib.lookupFunction<
            _c_clang_Type_getTemplateArgumentAsType,
            _dart_clang_Type_getTemplateArgumentAsType>(
        'clang_Type_getTemplateArgumentAsType'))(
      T,
      i,
    );
  }

  _dart_clang_Type_getTemplateArgumentAsType?
      _clang_Type_getTemplateArgumentAsType;

  /// Retrieve the ref-qualifier kind of a function or method.
  int clang_Type_getCXXRefQualifier(
    CXType T,
  ) {
    return (_clang_Type_getCXXRefQualifier ??= _dylib.lookupFunction<
        _c_clang_Type_getCXXRefQualifier,
        _dart_clang_Type_getCXXRefQualifier>('clang_Type_getCXXRefQualifier'))(
      T,
    );
  }

  _dart_clang_Type_getCXXRefQualifier? _clang_Type_getCXXRefQualifier;

  /// Returns non-zero if the cursor specifies a Record member that is a
  /// bitfield.
  int clang_Cursor_isBitField(
    CXCursor C,
  ) {
    return (_clang_Cursor_isBitField ??= _dylib.lookupFunction<
        _c_clang_Cursor_isBitField,
        _dart_clang_Cursor_isBitField>('clang_Cursor_isBitField'))(
      C,
    );
  }

  _dart_clang_Cursor_isBitField? _clang_Cursor_isBitField;

  /// Returns 1 if the base class specified by the cursor with kind
  /// CX_CXXBaseSpecifier is virtual.
  int clang_isVirtualBase(
    CXCursor arg0,
  ) {
    return (_clang_isVirtualBase ??= _dylib.lookupFunction<
        _c_clang_isVirtualBase,
        _dart_clang_isVirtualBase>('clang_isVirtualBase'))(
      arg0,
    );
  }

  _dart_clang_isVirtualBase? _clang_isVirtualBase;

  /// Returns the access control level for the referenced object.
  int clang_getCXXAccessSpecifier(
    CXCursor arg0,
  ) {
    return (_clang_getCXXAccessSpecifier ??= _dylib.lookupFunction<
        _c_clang_getCXXAccessSpecifier,
        _dart_clang_getCXXAccessSpecifier>('clang_getCXXAccessSpecifier'))(
      arg0,
    );
  }

  _dart_clang_getCXXAccessSpecifier? _clang_getCXXAccessSpecifier;

  /// Returns the storage class for a function or variable declaration.
  int clang_Cursor_getStorageClass(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getStorageClass ??= _dylib.lookupFunction<
        _c_clang_Cursor_getStorageClass,
        _dart_clang_Cursor_getStorageClass>('clang_Cursor_getStorageClass'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getStorageClass? _clang_Cursor_getStorageClass;

  /// Determine the number of overloaded declarations referenced by a
  /// CXCursor_OverloadedDeclRef cursor.
  int clang_getNumOverloadedDecls(
    CXCursor cursor,
  ) {
    return (_clang_getNumOverloadedDecls ??= _dylib.lookupFunction<
        _c_clang_getNumOverloadedDecls,
        _dart_clang_getNumOverloadedDecls>('clang_getNumOverloadedDecls'))(
      cursor,
    );
  }

  _dart_clang_getNumOverloadedDecls? _clang_getNumOverloadedDecls;

  /// Retrieve a cursor for one of the overloaded declarations referenced by a
  /// CXCursor_OverloadedDeclRef cursor.
  CXCursor clang_getOverloadedDecl(
    CXCursor cursor,
    int index,
  ) {
    return (_clang_getOverloadedDecl ??= _dylib.lookupFunction<
        _c_clang_getOverloadedDecl,
        _dart_clang_getOverloadedDecl>('clang_getOverloadedDecl'))(
      cursor,
      index,
    );
  }

  _dart_clang_getOverloadedDecl? _clang_getOverloadedDecl;

  /// For cursors representing an iboutletcollection attribute, this function
  /// returns the collection element type.
  CXType clang_getIBOutletCollectionType(
    CXCursor arg0,
  ) {
    return (_clang_getIBOutletCollectionType ??= _dylib.lookupFunction<
            _c_clang_getIBOutletCollectionType,
            _dart_clang_getIBOutletCollectionType>(
        'clang_getIBOutletCollectionType'))(
      arg0,
    );
  }

  _dart_clang_getIBOutletCollectionType? _clang_getIBOutletCollectionType;

  /// Visit the children of a particular cursor.
  int clang_visitChildren(
    CXCursor parent,
    ffi.Pointer<ffi.NativeFunction<CXCursorVisitor>> visitor,
    ffi.Pointer<ffi.Void> client_data,
  ) {
    return (_clang_visitChildren ??= _dylib.lookupFunction<
        _c_clang_visitChildren,
        _dart_clang_visitChildren>('clang_visitChildren'))(
      parent,
      visitor,
      client_data,
    );
  }

  _dart_clang_visitChildren? _clang_visitChildren;

  /// Retrieve a Unified Symbol Resolution (USR) for the entity referenced by
  /// the given cursor.
  CXString clang_getCursorUSR(
    CXCursor arg0,
  ) {
    return (_clang_getCursorUSR ??=
        _dylib.lookupFunction<_c_clang_getCursorUSR, _dart_clang_getCursorUSR>(
            'clang_getCursorUSR'))(
      arg0,
    );
  }

  _dart_clang_getCursorUSR? _clang_getCursorUSR;

  /// Construct a USR for a specified Objective-C class.
  CXString clang_constructUSR_ObjCClass(
    ffi.Pointer<ffi.Int8> class_name,
  ) {
    return (_clang_constructUSR_ObjCClass ??= _dylib.lookupFunction<
        _c_clang_constructUSR_ObjCClass,
        _dart_clang_constructUSR_ObjCClass>('clang_constructUSR_ObjCClass'))(
      class_name,
    );
  }

  _dart_clang_constructUSR_ObjCClass? _clang_constructUSR_ObjCClass;

  /// Construct a USR for a specified Objective-C category.
  CXString clang_constructUSR_ObjCCategory(
    ffi.Pointer<ffi.Int8> class_name,
    ffi.Pointer<ffi.Int8> category_name,
  ) {
    return (_clang_constructUSR_ObjCCategory ??= _dylib.lookupFunction<
            _c_clang_constructUSR_ObjCCategory,
            _dart_clang_constructUSR_ObjCCategory>(
        'clang_constructUSR_ObjCCategory'))(
      class_name,
      category_name,
    );
  }

  _dart_clang_constructUSR_ObjCCategory? _clang_constructUSR_ObjCCategory;

  /// Construct a USR for a specified Objective-C protocol.
  CXString clang_constructUSR_ObjCProtocol(
    ffi.Pointer<ffi.Int8> protocol_name,
  ) {
    return (_clang_constructUSR_ObjCProtocol ??= _dylib.lookupFunction<
            _c_clang_constructUSR_ObjCProtocol,
            _dart_clang_constructUSR_ObjCProtocol>(
        'clang_constructUSR_ObjCProtocol'))(
      protocol_name,
    );
  }

  _dart_clang_constructUSR_ObjCProtocol? _clang_constructUSR_ObjCProtocol;

  /// Construct a USR for a specified Objective-C instance variable and the USR
  /// for its containing class.
  CXString clang_constructUSR_ObjCIvar(
    ffi.Pointer<ffi.Int8> name,
    CXString classUSR,
  ) {
    return (_clang_constructUSR_ObjCIvar ??= _dylib.lookupFunction<
        _c_clang_constructUSR_ObjCIvar,
        _dart_clang_constructUSR_ObjCIvar>('clang_constructUSR_ObjCIvar'))(
      name,
      classUSR,
    );
  }

  _dart_clang_constructUSR_ObjCIvar? _clang_constructUSR_ObjCIvar;

  /// Construct a USR for a specified Objective-C method and the USR for its
  /// containing class.
  CXString clang_constructUSR_ObjCMethod(
    ffi.Pointer<ffi.Int8> name,
    int isInstanceMethod,
    CXString classUSR,
  ) {
    return (_clang_constructUSR_ObjCMethod ??= _dylib.lookupFunction<
        _c_clang_constructUSR_ObjCMethod,
        _dart_clang_constructUSR_ObjCMethod>('clang_constructUSR_ObjCMethod'))(
      name,
      isInstanceMethod,
      classUSR,
    );
  }

  _dart_clang_constructUSR_ObjCMethod? _clang_constructUSR_ObjCMethod;

  /// Construct a USR for a specified Objective-C property and the USR for its
  /// containing class.
  CXString clang_constructUSR_ObjCProperty(
    ffi.Pointer<ffi.Int8> property,
    CXString classUSR,
  ) {
    return (_clang_constructUSR_ObjCProperty ??= _dylib.lookupFunction<
            _c_clang_constructUSR_ObjCProperty,
            _dart_clang_constructUSR_ObjCProperty>(
        'clang_constructUSR_ObjCProperty'))(
      property,
      classUSR,
    );
  }

  _dart_clang_constructUSR_ObjCProperty? _clang_constructUSR_ObjCProperty;

  /// Retrieve a name for the entity referenced by this cursor.
  CXString clang_getCursorSpelling(
    CXCursor arg0,
  ) {
    return (_clang_getCursorSpelling ??= _dylib.lookupFunction<
        _c_clang_getCursorSpelling,
        _dart_clang_getCursorSpelling>('clang_getCursorSpelling'))(
      arg0,
    );
  }

  _dart_clang_getCursorSpelling? _clang_getCursorSpelling;

  /// Retrieve a range for a piece that forms the cursors spelling name. Most of
  /// the times there is only one range for the complete spelling but for
  /// Objective-C methods and Objective-C message expressions, there are
  /// multiple pieces for each selector identifier.
  CXSourceRange clang_Cursor_getSpellingNameRange(
    CXCursor arg0,
    int pieceIndex,
    int options,
  ) {
    return (_clang_Cursor_getSpellingNameRange ??= _dylib.lookupFunction<
            _c_clang_Cursor_getSpellingNameRange,
            _dart_clang_Cursor_getSpellingNameRange>(
        'clang_Cursor_getSpellingNameRange'))(
      arg0,
      pieceIndex,
      options,
    );
  }

  _dart_clang_Cursor_getSpellingNameRange? _clang_Cursor_getSpellingNameRange;

  /// Get a property value for the given printing policy.
  int clang_PrintingPolicy_getProperty(
    ffi.Pointer<ffi.Void> Policy,
    int Property,
  ) {
    return (_clang_PrintingPolicy_getProperty ??= _dylib.lookupFunction<
            _c_clang_PrintingPolicy_getProperty,
            _dart_clang_PrintingPolicy_getProperty>(
        'clang_PrintingPolicy_getProperty'))(
      Policy,
      Property,
    );
  }

  _dart_clang_PrintingPolicy_getProperty? _clang_PrintingPolicy_getProperty;

  /// Set a property value for the given printing policy.
  void clang_PrintingPolicy_setProperty(
    ffi.Pointer<ffi.Void> Policy,
    int Property,
    int Value,
  ) {
    return (_clang_PrintingPolicy_setProperty ??= _dylib.lookupFunction<
            _c_clang_PrintingPolicy_setProperty,
            _dart_clang_PrintingPolicy_setProperty>(
        'clang_PrintingPolicy_setProperty'))(
      Policy,
      Property,
      Value,
    );
  }

  _dart_clang_PrintingPolicy_setProperty? _clang_PrintingPolicy_setProperty;

  /// Retrieve the default policy for the cursor.
  ffi.Pointer<ffi.Void> clang_getCursorPrintingPolicy(
    CXCursor arg0,
  ) {
    return (_clang_getCursorPrintingPolicy ??= _dylib.lookupFunction<
        _c_clang_getCursorPrintingPolicy,
        _dart_clang_getCursorPrintingPolicy>('clang_getCursorPrintingPolicy'))(
      arg0,
    );
  }

  _dart_clang_getCursorPrintingPolicy? _clang_getCursorPrintingPolicy;

  /// Release a printing policy.
  void clang_PrintingPolicy_dispose(
    ffi.Pointer<ffi.Void> Policy,
  ) {
    return (_clang_PrintingPolicy_dispose ??= _dylib.lookupFunction<
        _c_clang_PrintingPolicy_dispose,
        _dart_clang_PrintingPolicy_dispose>('clang_PrintingPolicy_dispose'))(
      Policy,
    );
  }

  _dart_clang_PrintingPolicy_dispose? _clang_PrintingPolicy_dispose;

  /// Pretty print declarations.
  CXString clang_getCursorPrettyPrinted(
    CXCursor Cursor,
    ffi.Pointer<ffi.Void> Policy,
  ) {
    return (_clang_getCursorPrettyPrinted ??= _dylib.lookupFunction<
        _c_clang_getCursorPrettyPrinted,
        _dart_clang_getCursorPrettyPrinted>('clang_getCursorPrettyPrinted'))(
      Cursor,
      Policy,
    );
  }

  _dart_clang_getCursorPrettyPrinted? _clang_getCursorPrettyPrinted;

  /// Retrieve the display name for the entity referenced by this cursor.
  CXString clang_getCursorDisplayName(
    CXCursor arg0,
  ) {
    return (_clang_getCursorDisplayName ??= _dylib.lookupFunction<
        _c_clang_getCursorDisplayName,
        _dart_clang_getCursorDisplayName>('clang_getCursorDisplayName'))(
      arg0,
    );
  }

  _dart_clang_getCursorDisplayName? _clang_getCursorDisplayName;

  /// For a cursor that is a reference, retrieve a cursor representing the
  /// entity that it references.
  CXCursor clang_getCursorReferenced(
    CXCursor arg0,
  ) {
    return (_clang_getCursorReferenced ??= _dylib.lookupFunction<
        _c_clang_getCursorReferenced,
        _dart_clang_getCursorReferenced>('clang_getCursorReferenced'))(
      arg0,
    );
  }

  _dart_clang_getCursorReferenced? _clang_getCursorReferenced;

  /// For a cursor that is either a reference to or a declaration of some
  /// entity, retrieve a cursor that describes the definition of that entity.
  CXCursor clang_getCursorDefinition(
    CXCursor arg0,
  ) {
    return (_clang_getCursorDefinition ??= _dylib.lookupFunction<
        _c_clang_getCursorDefinition,
        _dart_clang_getCursorDefinition>('clang_getCursorDefinition'))(
      arg0,
    );
  }

  _dart_clang_getCursorDefinition? _clang_getCursorDefinition;

  /// Determine whether the declaration pointed to by this cursor is also a
  /// definition of that entity.
  int clang_isCursorDefinition(
    CXCursor arg0,
  ) {
    return (_clang_isCursorDefinition ??= _dylib.lookupFunction<
        _c_clang_isCursorDefinition,
        _dart_clang_isCursorDefinition>('clang_isCursorDefinition'))(
      arg0,
    );
  }

  _dart_clang_isCursorDefinition? _clang_isCursorDefinition;

  /// Retrieve the canonical cursor corresponding to the given cursor.
  CXCursor clang_getCanonicalCursor(
    CXCursor arg0,
  ) {
    return (_clang_getCanonicalCursor ??= _dylib.lookupFunction<
        _c_clang_getCanonicalCursor,
        _dart_clang_getCanonicalCursor>('clang_getCanonicalCursor'))(
      arg0,
    );
  }

  _dart_clang_getCanonicalCursor? _clang_getCanonicalCursor;

  /// If the cursor points to a selector identifier in an Objective-C method or
  /// message expression, this returns the selector index.
  int clang_Cursor_getObjCSelectorIndex(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getObjCSelectorIndex ??= _dylib.lookupFunction<
            _c_clang_Cursor_getObjCSelectorIndex,
            _dart_clang_Cursor_getObjCSelectorIndex>(
        'clang_Cursor_getObjCSelectorIndex'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getObjCSelectorIndex? _clang_Cursor_getObjCSelectorIndex;

  /// Given a cursor pointing to a C++ method call or an Objective-C message,
  /// returns non-zero if the method/message is "dynamic", meaning:
  int clang_Cursor_isDynamicCall(
    CXCursor C,
  ) {
    return (_clang_Cursor_isDynamicCall ??= _dylib.lookupFunction<
        _c_clang_Cursor_isDynamicCall,
        _dart_clang_Cursor_isDynamicCall>('clang_Cursor_isDynamicCall'))(
      C,
    );
  }

  _dart_clang_Cursor_isDynamicCall? _clang_Cursor_isDynamicCall;

  /// Given a cursor pointing to an Objective-C message or property reference,
  /// or C++ method call, returns the CXType of the receiver.
  CXType clang_Cursor_getReceiverType(
    CXCursor C,
  ) {
    return (_clang_Cursor_getReceiverType ??= _dylib.lookupFunction<
        _c_clang_Cursor_getReceiverType,
        _dart_clang_Cursor_getReceiverType>('clang_Cursor_getReceiverType'))(
      C,
    );
  }

  _dart_clang_Cursor_getReceiverType? _clang_Cursor_getReceiverType;

  /// Given a cursor that represents a property declaration, return the
  /// associated property attributes. The bits are formed from
  /// CXObjCPropertyAttrKind.
  int clang_Cursor_getObjCPropertyAttributes(
    CXCursor C,
    int reserved,
  ) {
    return (_clang_Cursor_getObjCPropertyAttributes ??= _dylib.lookupFunction<
            _c_clang_Cursor_getObjCPropertyAttributes,
            _dart_clang_Cursor_getObjCPropertyAttributes>(
        'clang_Cursor_getObjCPropertyAttributes'))(
      C,
      reserved,
    );
  }

  _dart_clang_Cursor_getObjCPropertyAttributes?
      _clang_Cursor_getObjCPropertyAttributes;

  /// Given a cursor that represents a property declaration, return the name of
  /// the method that implements the getter.
  CXString clang_Cursor_getObjCPropertyGetterName(
    CXCursor C,
  ) {
    return (_clang_Cursor_getObjCPropertyGetterName ??= _dylib.lookupFunction<
            _c_clang_Cursor_getObjCPropertyGetterName,
            _dart_clang_Cursor_getObjCPropertyGetterName>(
        'clang_Cursor_getObjCPropertyGetterName'))(
      C,
    );
  }

  _dart_clang_Cursor_getObjCPropertyGetterName?
      _clang_Cursor_getObjCPropertyGetterName;

  /// Given a cursor that represents a property declaration, return the name of
  /// the method that implements the setter, if any.
  CXString clang_Cursor_getObjCPropertySetterName(
    CXCursor C,
  ) {
    return (_clang_Cursor_getObjCPropertySetterName ??= _dylib.lookupFunction<
            _c_clang_Cursor_getObjCPropertySetterName,
            _dart_clang_Cursor_getObjCPropertySetterName>(
        'clang_Cursor_getObjCPropertySetterName'))(
      C,
    );
  }

  _dart_clang_Cursor_getObjCPropertySetterName?
      _clang_Cursor_getObjCPropertySetterName;

  /// Given a cursor that represents an Objective-C method or parameter
  /// declaration, return the associated Objective-C qualifiers for the return
  /// type or the parameter respectively. The bits are formed from
  /// CXObjCDeclQualifierKind.
  int clang_Cursor_getObjCDeclQualifiers(
    CXCursor C,
  ) {
    return (_clang_Cursor_getObjCDeclQualifiers ??= _dylib.lookupFunction<
            _c_clang_Cursor_getObjCDeclQualifiers,
            _dart_clang_Cursor_getObjCDeclQualifiers>(
        'clang_Cursor_getObjCDeclQualifiers'))(
      C,
    );
  }

  _dart_clang_Cursor_getObjCDeclQualifiers? _clang_Cursor_getObjCDeclQualifiers;

  /// Given a cursor that represents an Objective-C method or property
  /// declaration, return non-zero if the declaration was affected by
  /// "@optional". Returns zero if the cursor is not such a declaration or it is
  /// "@required".
  int clang_Cursor_isObjCOptional(
    CXCursor C,
  ) {
    return (_clang_Cursor_isObjCOptional ??= _dylib.lookupFunction<
        _c_clang_Cursor_isObjCOptional,
        _dart_clang_Cursor_isObjCOptional>('clang_Cursor_isObjCOptional'))(
      C,
    );
  }

  _dart_clang_Cursor_isObjCOptional? _clang_Cursor_isObjCOptional;

  /// Returns non-zero if the given cursor is a variadic function or method.
  int clang_Cursor_isVariadic(
    CXCursor C,
  ) {
    return (_clang_Cursor_isVariadic ??= _dylib.lookupFunction<
        _c_clang_Cursor_isVariadic,
        _dart_clang_Cursor_isVariadic>('clang_Cursor_isVariadic'))(
      C,
    );
  }

  _dart_clang_Cursor_isVariadic? _clang_Cursor_isVariadic;

  /// Returns non-zero if the given cursor points to a symbol marked with
  /// external_source_symbol attribute.
  int clang_Cursor_isExternalSymbol(
    CXCursor C,
    ffi.Pointer<CXString> language,
    ffi.Pointer<CXString> definedIn,
    ffi.Pointer<ffi.Uint32> isGenerated,
  ) {
    return (_clang_Cursor_isExternalSymbol ??= _dylib.lookupFunction<
        _c_clang_Cursor_isExternalSymbol,
        _dart_clang_Cursor_isExternalSymbol>('clang_Cursor_isExternalSymbol'))(
      C,
      language,
      definedIn,
      isGenerated,
    );
  }

  _dart_clang_Cursor_isExternalSymbol? _clang_Cursor_isExternalSymbol;

  /// Given a cursor that represents a declaration, return the associated
  /// comment's source range. The range may include multiple consecutive
  /// comments with whitespace in between.
  CXSourceRange clang_Cursor_getCommentRange(
    CXCursor C,
  ) {
    return (_clang_Cursor_getCommentRange ??= _dylib.lookupFunction<
        _c_clang_Cursor_getCommentRange,
        _dart_clang_Cursor_getCommentRange>('clang_Cursor_getCommentRange'))(
      C,
    );
  }

  _dart_clang_Cursor_getCommentRange? _clang_Cursor_getCommentRange;

  /// Given a cursor that represents a declaration, return the associated
  /// comment text, including comment markers.
  CXString clang_Cursor_getRawCommentText(
    CXCursor C,
  ) {
    return (_clang_Cursor_getRawCommentText ??= _dylib.lookupFunction<
            _c_clang_Cursor_getRawCommentText,
            _dart_clang_Cursor_getRawCommentText>(
        'clang_Cursor_getRawCommentText'))(
      C,
    );
  }

  _dart_clang_Cursor_getRawCommentText? _clang_Cursor_getRawCommentText;

  /// Given a cursor that represents a documentable entity (e.g., declaration),
  /// return the associated first paragraph.
  CXString clang_Cursor_getBriefCommentText(
    CXCursor C,
  ) {
    return (_clang_Cursor_getBriefCommentText ??= _dylib.lookupFunction<
            _c_clang_Cursor_getBriefCommentText,
            _dart_clang_Cursor_getBriefCommentText>(
        'clang_Cursor_getBriefCommentText'))(
      C,
    );
  }

  _dart_clang_Cursor_getBriefCommentText? _clang_Cursor_getBriefCommentText;

  /// Retrieve the CXString representing the mangled name of the cursor.
  CXString clang_Cursor_getMangling(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getMangling ??= _dylib.lookupFunction<
        _c_clang_Cursor_getMangling,
        _dart_clang_Cursor_getMangling>('clang_Cursor_getMangling'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getMangling? _clang_Cursor_getMangling;

  /// Retrieve the CXStrings representing the mangled symbols of the C++
  /// constructor or destructor at the cursor.
  ffi.Pointer<CXStringSet> clang_Cursor_getCXXManglings(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getCXXManglings ??= _dylib.lookupFunction<
        _c_clang_Cursor_getCXXManglings,
        _dart_clang_Cursor_getCXXManglings>('clang_Cursor_getCXXManglings'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getCXXManglings? _clang_Cursor_getCXXManglings;

  /// Retrieve the CXStrings representing the mangled symbols of the ObjC class
  /// interface or implementation at the cursor.
  ffi.Pointer<CXStringSet> clang_Cursor_getObjCManglings(
    CXCursor arg0,
  ) {
    return (_clang_Cursor_getObjCManglings ??= _dylib.lookupFunction<
        _c_clang_Cursor_getObjCManglings,
        _dart_clang_Cursor_getObjCManglings>('clang_Cursor_getObjCManglings'))(
      arg0,
    );
  }

  _dart_clang_Cursor_getObjCManglings? _clang_Cursor_getObjCManglings;

  /// Given a CXCursor_ModuleImportDecl cursor, return the associated module.
  ffi.Pointer<ffi.Void> clang_Cursor_getModule(
    CXCursor C,
  ) {
    return (_clang_Cursor_getModule ??= _dylib.lookupFunction<
        _c_clang_Cursor_getModule,
        _dart_clang_Cursor_getModule>('clang_Cursor_getModule'))(
      C,
    );
  }

  _dart_clang_Cursor_getModule? _clang_Cursor_getModule;

  /// Given a CXFile header file, return the module that contains it, if one
  /// exists.
  ffi.Pointer<ffi.Void> clang_getModuleForFile(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return (_clang_getModuleForFile ??= _dylib.lookupFunction<
        _c_clang_getModuleForFile,
        _dart_clang_getModuleForFile>('clang_getModuleForFile'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_getModuleForFile? _clang_getModuleForFile;

  /// Returns the module file where the provided module object came from.
  ffi.Pointer<ffi.Void> clang_Module_getASTFile(
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_getASTFile ??= _dylib.lookupFunction<
        _c_clang_Module_getASTFile,
        _dart_clang_Module_getASTFile>('clang_Module_getASTFile'))(
      Module,
    );
  }

  _dart_clang_Module_getASTFile? _clang_Module_getASTFile;

  /// Returns the parent of a sub-module or NULL if the given module is
  /// top-level, e.g. for 'std.vector' it will return the 'std' module.
  ffi.Pointer<ffi.Void> clang_Module_getParent(
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_getParent ??= _dylib.lookupFunction<
        _c_clang_Module_getParent,
        _dart_clang_Module_getParent>('clang_Module_getParent'))(
      Module,
    );
  }

  _dart_clang_Module_getParent? _clang_Module_getParent;

  /// Returns the name of the module, e.g. for the 'std.vector' sub-module it
  /// will return "vector".
  CXString clang_Module_getName(
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_getName ??= _dylib.lookupFunction<
        _c_clang_Module_getName,
        _dart_clang_Module_getName>('clang_Module_getName'))(
      Module,
    );
  }

  _dart_clang_Module_getName? _clang_Module_getName;

  /// Returns the full name of the module, e.g. "std.vector".
  CXString clang_Module_getFullName(
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_getFullName ??= _dylib.lookupFunction<
        _c_clang_Module_getFullName,
        _dart_clang_Module_getFullName>('clang_Module_getFullName'))(
      Module,
    );
  }

  _dart_clang_Module_getFullName? _clang_Module_getFullName;

  /// Returns non-zero if the module is a system one.
  int clang_Module_isSystem(
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_isSystem ??= _dylib.lookupFunction<
        _c_clang_Module_isSystem,
        _dart_clang_Module_isSystem>('clang_Module_isSystem'))(
      Module,
    );
  }

  _dart_clang_Module_isSystem? _clang_Module_isSystem;

  /// Returns the number of top level headers associated with this module.
  int clang_Module_getNumTopLevelHeaders(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    ffi.Pointer<ffi.Void> Module,
  ) {
    return (_clang_Module_getNumTopLevelHeaders ??= _dylib.lookupFunction<
            _c_clang_Module_getNumTopLevelHeaders,
            _dart_clang_Module_getNumTopLevelHeaders>(
        'clang_Module_getNumTopLevelHeaders'))(
      arg0,
      Module,
    );
  }

  _dart_clang_Module_getNumTopLevelHeaders? _clang_Module_getNumTopLevelHeaders;

  /// Returns the specified top level header associated with the module.
  ffi.Pointer<ffi.Void> clang_Module_getTopLevelHeader(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    ffi.Pointer<ffi.Void> Module,
    int Index,
  ) {
    return (_clang_Module_getTopLevelHeader ??= _dylib.lookupFunction<
            _c_clang_Module_getTopLevelHeader,
            _dart_clang_Module_getTopLevelHeader>(
        'clang_Module_getTopLevelHeader'))(
      arg0,
      Module,
      Index,
    );
  }

  _dart_clang_Module_getTopLevelHeader? _clang_Module_getTopLevelHeader;

  /// Determine if a C++ constructor is a converting constructor.
  int clang_CXXConstructor_isConvertingConstructor(
    CXCursor C,
  ) {
    return (_clang_CXXConstructor_isConvertingConstructor ??=
        _dylib.lookupFunction<_c_clang_CXXConstructor_isConvertingConstructor,
                _dart_clang_CXXConstructor_isConvertingConstructor>(
            'clang_CXXConstructor_isConvertingConstructor'))(
      C,
    );
  }

  _dart_clang_CXXConstructor_isConvertingConstructor?
      _clang_CXXConstructor_isConvertingConstructor;

  /// Determine if a C++ constructor is a copy constructor.
  int clang_CXXConstructor_isCopyConstructor(
    CXCursor C,
  ) {
    return (_clang_CXXConstructor_isCopyConstructor ??= _dylib.lookupFunction<
            _c_clang_CXXConstructor_isCopyConstructor,
            _dart_clang_CXXConstructor_isCopyConstructor>(
        'clang_CXXConstructor_isCopyConstructor'))(
      C,
    );
  }

  _dart_clang_CXXConstructor_isCopyConstructor?
      _clang_CXXConstructor_isCopyConstructor;

  /// Determine if a C++ constructor is the default constructor.
  int clang_CXXConstructor_isDefaultConstructor(
    CXCursor C,
  ) {
    return (_clang_CXXConstructor_isDefaultConstructor ??=
        _dylib.lookupFunction<_c_clang_CXXConstructor_isDefaultConstructor,
                _dart_clang_CXXConstructor_isDefaultConstructor>(
            'clang_CXXConstructor_isDefaultConstructor'))(
      C,
    );
  }

  _dart_clang_CXXConstructor_isDefaultConstructor?
      _clang_CXXConstructor_isDefaultConstructor;

  /// Determine if a C++ constructor is a move constructor.
  int clang_CXXConstructor_isMoveConstructor(
    CXCursor C,
  ) {
    return (_clang_CXXConstructor_isMoveConstructor ??= _dylib.lookupFunction<
            _c_clang_CXXConstructor_isMoveConstructor,
            _dart_clang_CXXConstructor_isMoveConstructor>(
        'clang_CXXConstructor_isMoveConstructor'))(
      C,
    );
  }

  _dart_clang_CXXConstructor_isMoveConstructor?
      _clang_CXXConstructor_isMoveConstructor;

  /// Determine if a C++ field is declared 'mutable'.
  int clang_CXXField_isMutable(
    CXCursor C,
  ) {
    return (_clang_CXXField_isMutable ??= _dylib.lookupFunction<
        _c_clang_CXXField_isMutable,
        _dart_clang_CXXField_isMutable>('clang_CXXField_isMutable'))(
      C,
    );
  }

  _dart_clang_CXXField_isMutable? _clang_CXXField_isMutable;

  /// Determine if a C++ method is declared '= default'.
  int clang_CXXMethod_isDefaulted(
    CXCursor C,
  ) {
    return (_clang_CXXMethod_isDefaulted ??= _dylib.lookupFunction<
        _c_clang_CXXMethod_isDefaulted,
        _dart_clang_CXXMethod_isDefaulted>('clang_CXXMethod_isDefaulted'))(
      C,
    );
  }

  _dart_clang_CXXMethod_isDefaulted? _clang_CXXMethod_isDefaulted;

  /// Determine if a C++ member function or member function template is pure
  /// virtual.
  int clang_CXXMethod_isPureVirtual(
    CXCursor C,
  ) {
    return (_clang_CXXMethod_isPureVirtual ??= _dylib.lookupFunction<
        _c_clang_CXXMethod_isPureVirtual,
        _dart_clang_CXXMethod_isPureVirtual>('clang_CXXMethod_isPureVirtual'))(
      C,
    );
  }

  _dart_clang_CXXMethod_isPureVirtual? _clang_CXXMethod_isPureVirtual;

  /// Determine if a C++ member function or member function template is declared
  /// 'static'.
  int clang_CXXMethod_isStatic(
    CXCursor C,
  ) {
    return (_clang_CXXMethod_isStatic ??= _dylib.lookupFunction<
        _c_clang_CXXMethod_isStatic,
        _dart_clang_CXXMethod_isStatic>('clang_CXXMethod_isStatic'))(
      C,
    );
  }

  _dart_clang_CXXMethod_isStatic? _clang_CXXMethod_isStatic;

  /// Determine if a C++ member function or member function template is
  /// explicitly declared 'virtual' or if it overrides a virtual method from one
  /// of the base classes.
  int clang_CXXMethod_isVirtual(
    CXCursor C,
  ) {
    return (_clang_CXXMethod_isVirtual ??= _dylib.lookupFunction<
        _c_clang_CXXMethod_isVirtual,
        _dart_clang_CXXMethod_isVirtual>('clang_CXXMethod_isVirtual'))(
      C,
    );
  }

  _dart_clang_CXXMethod_isVirtual? _clang_CXXMethod_isVirtual;

  /// Determine if a C++ record is abstract, i.e. whether a class or struct has
  /// a pure virtual member function.
  int clang_CXXRecord_isAbstract(
    CXCursor C,
  ) {
    return (_clang_CXXRecord_isAbstract ??= _dylib.lookupFunction<
        _c_clang_CXXRecord_isAbstract,
        _dart_clang_CXXRecord_isAbstract>('clang_CXXRecord_isAbstract'))(
      C,
    );
  }

  _dart_clang_CXXRecord_isAbstract? _clang_CXXRecord_isAbstract;

  /// Determine if an enum declaration refers to a scoped enum.
  int clang_EnumDecl_isScoped(
    CXCursor C,
  ) {
    return (_clang_EnumDecl_isScoped ??= _dylib.lookupFunction<
        _c_clang_EnumDecl_isScoped,
        _dart_clang_EnumDecl_isScoped>('clang_EnumDecl_isScoped'))(
      C,
    );
  }

  _dart_clang_EnumDecl_isScoped? _clang_EnumDecl_isScoped;

  /// Determine if a C++ member function or member function template is declared
  /// 'const'.
  int clang_CXXMethod_isConst(
    CXCursor C,
  ) {
    return (_clang_CXXMethod_isConst ??= _dylib.lookupFunction<
        _c_clang_CXXMethod_isConst,
        _dart_clang_CXXMethod_isConst>('clang_CXXMethod_isConst'))(
      C,
    );
  }

  _dart_clang_CXXMethod_isConst? _clang_CXXMethod_isConst;

  /// Given a cursor that represents a template, determine the cursor kind of
  /// the specializations would be generated by instantiating the template.
  int clang_getTemplateCursorKind(
    CXCursor C,
  ) {
    return (_clang_getTemplateCursorKind ??= _dylib.lookupFunction<
        _c_clang_getTemplateCursorKind,
        _dart_clang_getTemplateCursorKind>('clang_getTemplateCursorKind'))(
      C,
    );
  }

  _dart_clang_getTemplateCursorKind? _clang_getTemplateCursorKind;

  /// Given a cursor that may represent a specialization or instantiation of a
  /// template, retrieve the cursor that represents the template that it
  /// specializes or from which it was instantiated.
  CXCursor clang_getSpecializedCursorTemplate(
    CXCursor C,
  ) {
    return (_clang_getSpecializedCursorTemplate ??= _dylib.lookupFunction<
            _c_clang_getSpecializedCursorTemplate,
            _dart_clang_getSpecializedCursorTemplate>(
        'clang_getSpecializedCursorTemplate'))(
      C,
    );
  }

  _dart_clang_getSpecializedCursorTemplate? _clang_getSpecializedCursorTemplate;

  /// Given a cursor that references something else, return the source range
  /// covering that reference.
  CXSourceRange clang_getCursorReferenceNameRange(
    CXCursor C,
    int NameFlags,
    int PieceIndex,
  ) {
    return (_clang_getCursorReferenceNameRange ??= _dylib.lookupFunction<
            _c_clang_getCursorReferenceNameRange,
            _dart_clang_getCursorReferenceNameRange>(
        'clang_getCursorReferenceNameRange'))(
      C,
      NameFlags,
      PieceIndex,
    );
  }

  _dart_clang_getCursorReferenceNameRange? _clang_getCursorReferenceNameRange;

  /// Get the raw lexical token starting with the given location.
  ffi.Pointer<CXToken> clang_getToken(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    CXSourceLocation Location,
  ) {
    return (_clang_getToken ??=
        _dylib.lookupFunction<_c_clang_getToken, _dart_clang_getToken>(
            'clang_getToken'))(
      TU,
      Location,
    );
  }

  _dart_clang_getToken? _clang_getToken;

  /// Determine the kind of the given token.
  int clang_getTokenKind(
    CXToken arg0,
  ) {
    return (_clang_getTokenKind ??=
        _dylib.lookupFunction<_c_clang_getTokenKind, _dart_clang_getTokenKind>(
            'clang_getTokenKind'))(
      arg0,
    );
  }

  _dart_clang_getTokenKind? _clang_getTokenKind;

  /// Determine the spelling of the given token.
  CXString clang_getTokenSpelling(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    CXToken arg1,
  ) {
    return (_clang_getTokenSpelling ??= _dylib.lookupFunction<
        _c_clang_getTokenSpelling,
        _dart_clang_getTokenSpelling>('clang_getTokenSpelling'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_getTokenSpelling? _clang_getTokenSpelling;

  /// Retrieve the source location of the given token.
  CXSourceLocation clang_getTokenLocation(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    CXToken arg1,
  ) {
    return (_clang_getTokenLocation ??= _dylib.lookupFunction<
        _c_clang_getTokenLocation,
        _dart_clang_getTokenLocation>('clang_getTokenLocation'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_getTokenLocation? _clang_getTokenLocation;

  /// Retrieve a source range that covers the given token.
  CXSourceRange clang_getTokenExtent(
    ffi.Pointer<CXTranslationUnitImpl> arg0,
    CXToken arg1,
  ) {
    return (_clang_getTokenExtent ??= _dylib.lookupFunction<
        _c_clang_getTokenExtent,
        _dart_clang_getTokenExtent>('clang_getTokenExtent'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_getTokenExtent? _clang_getTokenExtent;

  /// Tokenize the source code described by the given range into raw lexical
  /// tokens.
  void clang_tokenize(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    CXSourceRange Range,
    ffi.Pointer<ffi.Pointer<CXToken>> Tokens,
    ffi.Pointer<ffi.Uint32> NumTokens,
  ) {
    return (_clang_tokenize ??=
        _dylib.lookupFunction<_c_clang_tokenize, _dart_clang_tokenize>(
            'clang_tokenize'))(
      TU,
      Range,
      Tokens,
      NumTokens,
    );
  }

  _dart_clang_tokenize? _clang_tokenize;

  /// Annotate the given set of tokens by providing cursors for each token that
  /// can be mapped to a specific entity within the abstract syntax tree.
  void clang_annotateTokens(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    ffi.Pointer<CXToken> Tokens,
    int NumTokens,
    ffi.Pointer<CXCursor> Cursors,
  ) {
    return (_clang_annotateTokens ??= _dylib.lookupFunction<
        _c_clang_annotateTokens,
        _dart_clang_annotateTokens>('clang_annotateTokens'))(
      TU,
      Tokens,
      NumTokens,
      Cursors,
    );
  }

  _dart_clang_annotateTokens? _clang_annotateTokens;

  /// Free the given set of tokens.
  void clang_disposeTokens(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    ffi.Pointer<CXToken> Tokens,
    int NumTokens,
  ) {
    return (_clang_disposeTokens ??= _dylib.lookupFunction<
        _c_clang_disposeTokens,
        _dart_clang_disposeTokens>('clang_disposeTokens'))(
      TU,
      Tokens,
      NumTokens,
    );
  }

  _dart_clang_disposeTokens? _clang_disposeTokens;

  /// These routines are used for testing and debugging, only, and should not be
  /// relied upon.
  CXString clang_getCursorKindSpelling(
    int Kind,
  ) {
    return (_clang_getCursorKindSpelling ??= _dylib.lookupFunction<
        _c_clang_getCursorKindSpelling,
        _dart_clang_getCursorKindSpelling>('clang_getCursorKindSpelling'))(
      Kind,
    );
  }

  _dart_clang_getCursorKindSpelling? _clang_getCursorKindSpelling;

  void clang_getDefinitionSpellingAndExtent(
    CXCursor arg0,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> startBuf,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> endBuf,
    ffi.Pointer<ffi.Uint32> startLine,
    ffi.Pointer<ffi.Uint32> startColumn,
    ffi.Pointer<ffi.Uint32> endLine,
    ffi.Pointer<ffi.Uint32> endColumn,
  ) {
    return (_clang_getDefinitionSpellingAndExtent ??= _dylib.lookupFunction<
            _c_clang_getDefinitionSpellingAndExtent,
            _dart_clang_getDefinitionSpellingAndExtent>(
        'clang_getDefinitionSpellingAndExtent'))(
      arg0,
      startBuf,
      endBuf,
      startLine,
      startColumn,
      endLine,
      endColumn,
    );
  }

  _dart_clang_getDefinitionSpellingAndExtent?
      _clang_getDefinitionSpellingAndExtent;

  void clang_enableStackTraces() {
    return (_clang_enableStackTraces ??= _dylib.lookupFunction<
        _c_clang_enableStackTraces,
        _dart_clang_enableStackTraces>('clang_enableStackTraces'))();
  }

  _dart_clang_enableStackTraces? _clang_enableStackTraces;

  void clang_executeOnThread(
    ffi.Pointer<ffi.NativeFunction<_typedefC_1>> fn,
    ffi.Pointer<ffi.Void> user_data,
    int stack_size,
  ) {
    return (_clang_executeOnThread ??= _dylib.lookupFunction<
        _c_clang_executeOnThread,
        _dart_clang_executeOnThread>('clang_executeOnThread'))(
      fn,
      user_data,
      stack_size,
    );
  }

  _dart_clang_executeOnThread? _clang_executeOnThread;

  /// Determine the kind of a particular chunk within a completion string.
  int clang_getCompletionChunkKind(
    ffi.Pointer<ffi.Void> completion_string,
    int chunk_number,
  ) {
    return (_clang_getCompletionChunkKind ??= _dylib.lookupFunction<
        _c_clang_getCompletionChunkKind,
        _dart_clang_getCompletionChunkKind>('clang_getCompletionChunkKind'))(
      completion_string,
      chunk_number,
    );
  }

  _dart_clang_getCompletionChunkKind? _clang_getCompletionChunkKind;

  /// Retrieve the text associated with a particular chunk within a completion
  /// string.
  CXString clang_getCompletionChunkText(
    ffi.Pointer<ffi.Void> completion_string,
    int chunk_number,
  ) {
    return (_clang_getCompletionChunkText ??= _dylib.lookupFunction<
        _c_clang_getCompletionChunkText,
        _dart_clang_getCompletionChunkText>('clang_getCompletionChunkText'))(
      completion_string,
      chunk_number,
    );
  }

  _dart_clang_getCompletionChunkText? _clang_getCompletionChunkText;

  /// Retrieve the completion string associated with a particular chunk within a
  /// completion string.
  ffi.Pointer<ffi.Void> clang_getCompletionChunkCompletionString(
    ffi.Pointer<ffi.Void> completion_string,
    int chunk_number,
  ) {
    return (_clang_getCompletionChunkCompletionString ??= _dylib.lookupFunction<
            _c_clang_getCompletionChunkCompletionString,
            _dart_clang_getCompletionChunkCompletionString>(
        'clang_getCompletionChunkCompletionString'))(
      completion_string,
      chunk_number,
    );
  }

  _dart_clang_getCompletionChunkCompletionString?
      _clang_getCompletionChunkCompletionString;

  /// Retrieve the number of chunks in the given code-completion string.
  int clang_getNumCompletionChunks(
    ffi.Pointer<ffi.Void> completion_string,
  ) {
    return (_clang_getNumCompletionChunks ??= _dylib.lookupFunction<
        _c_clang_getNumCompletionChunks,
        _dart_clang_getNumCompletionChunks>('clang_getNumCompletionChunks'))(
      completion_string,
    );
  }

  _dart_clang_getNumCompletionChunks? _clang_getNumCompletionChunks;

  /// Determine the priority of this code completion.
  int clang_getCompletionPriority(
    ffi.Pointer<ffi.Void> completion_string,
  ) {
    return (_clang_getCompletionPriority ??= _dylib.lookupFunction<
        _c_clang_getCompletionPriority,
        _dart_clang_getCompletionPriority>('clang_getCompletionPriority'))(
      completion_string,
    );
  }

  _dart_clang_getCompletionPriority? _clang_getCompletionPriority;

  /// Determine the availability of the entity that this code-completion string
  /// refers to.
  int clang_getCompletionAvailability(
    ffi.Pointer<ffi.Void> completion_string,
  ) {
    return (_clang_getCompletionAvailability ??= _dylib.lookupFunction<
            _c_clang_getCompletionAvailability,
            _dart_clang_getCompletionAvailability>(
        'clang_getCompletionAvailability'))(
      completion_string,
    );
  }

  _dart_clang_getCompletionAvailability? _clang_getCompletionAvailability;

  /// Retrieve the number of annotations associated with the given completion
  /// string.
  int clang_getCompletionNumAnnotations(
    ffi.Pointer<ffi.Void> completion_string,
  ) {
    return (_clang_getCompletionNumAnnotations ??= _dylib.lookupFunction<
            _c_clang_getCompletionNumAnnotations,
            _dart_clang_getCompletionNumAnnotations>(
        'clang_getCompletionNumAnnotations'))(
      completion_string,
    );
  }

  _dart_clang_getCompletionNumAnnotations? _clang_getCompletionNumAnnotations;

  /// Retrieve the annotation associated with the given completion string.
  CXString clang_getCompletionAnnotation(
    ffi.Pointer<ffi.Void> completion_string,
    int annotation_number,
  ) {
    return (_clang_getCompletionAnnotation ??= _dylib.lookupFunction<
        _c_clang_getCompletionAnnotation,
        _dart_clang_getCompletionAnnotation>('clang_getCompletionAnnotation'))(
      completion_string,
      annotation_number,
    );
  }

  _dart_clang_getCompletionAnnotation? _clang_getCompletionAnnotation;

  /// Retrieve the parent context of the given completion string.
  CXString clang_getCompletionParent(
    ffi.Pointer<ffi.Void> completion_string,
    ffi.Pointer<ffi.Int32> kind,
  ) {
    return (_clang_getCompletionParent ??= _dylib.lookupFunction<
        _c_clang_getCompletionParent,
        _dart_clang_getCompletionParent>('clang_getCompletionParent'))(
      completion_string,
      kind,
    );
  }

  _dart_clang_getCompletionParent? _clang_getCompletionParent;

  /// Retrieve the brief documentation comment attached to the declaration that
  /// corresponds to the given completion string.
  CXString clang_getCompletionBriefComment(
    ffi.Pointer<ffi.Void> completion_string,
  ) {
    return (_clang_getCompletionBriefComment ??= _dylib.lookupFunction<
            _c_clang_getCompletionBriefComment,
            _dart_clang_getCompletionBriefComment>(
        'clang_getCompletionBriefComment'))(
      completion_string,
    );
  }

  _dart_clang_getCompletionBriefComment? _clang_getCompletionBriefComment;

  /// Retrieve a completion string for an arbitrary declaration or macro
  /// definition cursor.
  ffi.Pointer<ffi.Void> clang_getCursorCompletionString(
    CXCursor cursor,
  ) {
    return (_clang_getCursorCompletionString ??= _dylib.lookupFunction<
            _c_clang_getCursorCompletionString,
            _dart_clang_getCursorCompletionString>(
        'clang_getCursorCompletionString'))(
      cursor,
    );
  }

  _dart_clang_getCursorCompletionString? _clang_getCursorCompletionString;

  /// Retrieve the number of fix-its for the given completion index.
  int clang_getCompletionNumFixIts(
    ffi.Pointer<CXCodeCompleteResults> results,
    int completion_index,
  ) {
    return (_clang_getCompletionNumFixIts ??= _dylib.lookupFunction<
        _c_clang_getCompletionNumFixIts,
        _dart_clang_getCompletionNumFixIts>('clang_getCompletionNumFixIts'))(
      results,
      completion_index,
    );
  }

  _dart_clang_getCompletionNumFixIts? _clang_getCompletionNumFixIts;

  /// Fix-its that *must* be applied before inserting the text for the
  /// corresponding completion.
  CXString clang_getCompletionFixIt(
    ffi.Pointer<CXCodeCompleteResults> results,
    int completion_index,
    int fixit_index,
    ffi.Pointer<CXSourceRange> replacement_range,
  ) {
    return (_clang_getCompletionFixIt ??= _dylib.lookupFunction<
        _c_clang_getCompletionFixIt,
        _dart_clang_getCompletionFixIt>('clang_getCompletionFixIt'))(
      results,
      completion_index,
      fixit_index,
      replacement_range,
    );
  }

  _dart_clang_getCompletionFixIt? _clang_getCompletionFixIt;

  /// Returns a default set of code-completion options that can be passed to
  /// clang_codeCompleteAt().
  int clang_defaultCodeCompleteOptions() {
    return (_clang_defaultCodeCompleteOptions ??= _dylib.lookupFunction<
            _c_clang_defaultCodeCompleteOptions,
            _dart_clang_defaultCodeCompleteOptions>(
        'clang_defaultCodeCompleteOptions'))();
  }

  _dart_clang_defaultCodeCompleteOptions? _clang_defaultCodeCompleteOptions;

  /// Perform code completion at a given location in a translation unit.
  ffi.Pointer<CXCodeCompleteResults> clang_codeCompleteAt(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    ffi.Pointer<ffi.Int8> complete_filename,
    int complete_line,
    int complete_column,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    int options,
  ) {
    return (_clang_codeCompleteAt ??= _dylib.lookupFunction<
        _c_clang_codeCompleteAt,
        _dart_clang_codeCompleteAt>('clang_codeCompleteAt'))(
      TU,
      complete_filename,
      complete_line,
      complete_column,
      unsaved_files,
      num_unsaved_files,
      options,
    );
  }

  _dart_clang_codeCompleteAt? _clang_codeCompleteAt;

  /// Sort the code-completion results in case-insensitive alphabetical order.
  void clang_sortCodeCompletionResults(
    ffi.Pointer<CXCompletionResult> Results,
    int NumResults,
  ) {
    return (_clang_sortCodeCompletionResults ??= _dylib.lookupFunction<
            _c_clang_sortCodeCompletionResults,
            _dart_clang_sortCodeCompletionResults>(
        'clang_sortCodeCompletionResults'))(
      Results,
      NumResults,
    );
  }

  _dart_clang_sortCodeCompletionResults? _clang_sortCodeCompletionResults;

  /// Free the given set of code-completion results.
  void clang_disposeCodeCompleteResults(
    ffi.Pointer<CXCodeCompleteResults> Results,
  ) {
    return (_clang_disposeCodeCompleteResults ??= _dylib.lookupFunction<
            _c_clang_disposeCodeCompleteResults,
            _dart_clang_disposeCodeCompleteResults>(
        'clang_disposeCodeCompleteResults'))(
      Results,
    );
  }

  _dart_clang_disposeCodeCompleteResults? _clang_disposeCodeCompleteResults;

  /// Determine the number of diagnostics produced prior to the location where
  /// code completion was performed.
  int clang_codeCompleteGetNumDiagnostics(
    ffi.Pointer<CXCodeCompleteResults> Results,
  ) {
    return (_clang_codeCompleteGetNumDiagnostics ??= _dylib.lookupFunction<
            _c_clang_codeCompleteGetNumDiagnostics,
            _dart_clang_codeCompleteGetNumDiagnostics>(
        'clang_codeCompleteGetNumDiagnostics'))(
      Results,
    );
  }

  _dart_clang_codeCompleteGetNumDiagnostics?
      _clang_codeCompleteGetNumDiagnostics;

  /// Retrieve a diagnostic associated with the given code completion.
  ffi.Pointer<ffi.Void> clang_codeCompleteGetDiagnostic(
    ffi.Pointer<CXCodeCompleteResults> Results,
    int Index,
  ) {
    return (_clang_codeCompleteGetDiagnostic ??= _dylib.lookupFunction<
            _c_clang_codeCompleteGetDiagnostic,
            _dart_clang_codeCompleteGetDiagnostic>(
        'clang_codeCompleteGetDiagnostic'))(
      Results,
      Index,
    );
  }

  _dart_clang_codeCompleteGetDiagnostic? _clang_codeCompleteGetDiagnostic;

  /// Determines what completions are appropriate for the context the given code
  /// completion.
  int clang_codeCompleteGetContexts(
    ffi.Pointer<CXCodeCompleteResults> Results,
  ) {
    return (_clang_codeCompleteGetContexts ??= _dylib.lookupFunction<
        _c_clang_codeCompleteGetContexts,
        _dart_clang_codeCompleteGetContexts>('clang_codeCompleteGetContexts'))(
      Results,
    );
  }

  _dart_clang_codeCompleteGetContexts? _clang_codeCompleteGetContexts;

  /// Returns the cursor kind for the container for the current code completion
  /// context. The container is only guaranteed to be set for contexts where a
  /// container exists (i.e. member accesses or Objective-C message sends); if
  /// there is not a container, this function will return CXCursor_InvalidCode.
  int clang_codeCompleteGetContainerKind(
    ffi.Pointer<CXCodeCompleteResults> Results,
    ffi.Pointer<ffi.Uint32> IsIncomplete,
  ) {
    return (_clang_codeCompleteGetContainerKind ??= _dylib.lookupFunction<
            _c_clang_codeCompleteGetContainerKind,
            _dart_clang_codeCompleteGetContainerKind>(
        'clang_codeCompleteGetContainerKind'))(
      Results,
      IsIncomplete,
    );
  }

  _dart_clang_codeCompleteGetContainerKind? _clang_codeCompleteGetContainerKind;

  /// Returns the USR for the container for the current code completion context.
  /// If there is not a container for the current context, this function will
  /// return the empty string.
  CXString clang_codeCompleteGetContainerUSR(
    ffi.Pointer<CXCodeCompleteResults> Results,
  ) {
    return (_clang_codeCompleteGetContainerUSR ??= _dylib.lookupFunction<
            _c_clang_codeCompleteGetContainerUSR,
            _dart_clang_codeCompleteGetContainerUSR>(
        'clang_codeCompleteGetContainerUSR'))(
      Results,
    );
  }

  _dart_clang_codeCompleteGetContainerUSR? _clang_codeCompleteGetContainerUSR;

  /// Returns the currently-entered selector for an Objective-C message send,
  /// formatted like "initWithFoo:bar:". Only guaranteed to return a non-empty
  /// string for CXCompletionContext_ObjCInstanceMessage and
  /// CXCompletionContext_ObjCClassMessage.
  CXString clang_codeCompleteGetObjCSelector(
    ffi.Pointer<CXCodeCompleteResults> Results,
  ) {
    return (_clang_codeCompleteGetObjCSelector ??= _dylib.lookupFunction<
            _c_clang_codeCompleteGetObjCSelector,
            _dart_clang_codeCompleteGetObjCSelector>(
        'clang_codeCompleteGetObjCSelector'))(
      Results,
    );
  }

  _dart_clang_codeCompleteGetObjCSelector? _clang_codeCompleteGetObjCSelector;

  /// Return a version string, suitable for showing to a user, but not intended
  /// to be parsed (the format is not guaranteed to be stable).
  CXString clang_getClangVersion() {
    return (_clang_getClangVersion ??= _dylib.lookupFunction<
        _c_clang_getClangVersion,
        _dart_clang_getClangVersion>('clang_getClangVersion'))();
  }

  _dart_clang_getClangVersion? _clang_getClangVersion;

  /// Enable/disable crash recovery.
  void clang_toggleCrashRecovery(
    int isEnabled,
  ) {
    return (_clang_toggleCrashRecovery ??= _dylib.lookupFunction<
        _c_clang_toggleCrashRecovery,
        _dart_clang_toggleCrashRecovery>('clang_toggleCrashRecovery'))(
      isEnabled,
    );
  }

  _dart_clang_toggleCrashRecovery? _clang_toggleCrashRecovery;

  /// Visit the set of preprocessor inclusions in a translation unit. The
  /// visitor function is called with the provided data for every included file.
  /// This does not include headers included by the PCH file (unless one is
  /// inspecting the inclusions in the PCH file itself).
  void clang_getInclusions(
    ffi.Pointer<CXTranslationUnitImpl> tu,
    ffi.Pointer<ffi.NativeFunction<CXInclusionVisitor>> visitor,
    ffi.Pointer<ffi.Void> client_data,
  ) {
    return (_clang_getInclusions ??= _dylib.lookupFunction<
        _c_clang_getInclusions,
        _dart_clang_getInclusions>('clang_getInclusions'))(
      tu,
      visitor,
      client_data,
    );
  }

  _dart_clang_getInclusions? _clang_getInclusions;

  /// If cursor is a statement declaration tries to evaluate the statement and
  /// if its variable, tries to evaluate its initializer, into its corresponding
  /// type.
  ffi.Pointer<ffi.Void> clang_Cursor_Evaluate(
    CXCursor C,
  ) {
    return (_clang_Cursor_Evaluate ??= _dylib.lookupFunction<
        _c_clang_Cursor_Evaluate,
        _dart_clang_Cursor_Evaluate>('clang_Cursor_Evaluate'))(
      C,
    );
  }

  _dart_clang_Cursor_Evaluate? _clang_Cursor_Evaluate;

  /// Returns the kind of the evaluated result.
  int clang_EvalResult_getKind(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getKind ??= _dylib.lookupFunction<
        _c_clang_EvalResult_getKind,
        _dart_clang_EvalResult_getKind>('clang_EvalResult_getKind'))(
      E,
    );
  }

  _dart_clang_EvalResult_getKind? _clang_EvalResult_getKind;

  /// Returns the evaluation result as integer if the kind is Int.
  int clang_EvalResult_getAsInt(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getAsInt ??= _dylib.lookupFunction<
        _c_clang_EvalResult_getAsInt,
        _dart_clang_EvalResult_getAsInt>('clang_EvalResult_getAsInt'))(
      E,
    );
  }

  _dart_clang_EvalResult_getAsInt? _clang_EvalResult_getAsInt;

  /// Returns the evaluation result as a long long integer if the kind is Int.
  /// This prevents overflows that may happen if the result is returned with
  /// clang_EvalResult_getAsInt.
  int clang_EvalResult_getAsLongLong(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getAsLongLong ??= _dylib.lookupFunction<
            _c_clang_EvalResult_getAsLongLong,
            _dart_clang_EvalResult_getAsLongLong>(
        'clang_EvalResult_getAsLongLong'))(
      E,
    );
  }

  _dart_clang_EvalResult_getAsLongLong? _clang_EvalResult_getAsLongLong;

  /// Returns a non-zero value if the kind is Int and the evaluation result
  /// resulted in an unsigned integer.
  int clang_EvalResult_isUnsignedInt(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_isUnsignedInt ??= _dylib.lookupFunction<
            _c_clang_EvalResult_isUnsignedInt,
            _dart_clang_EvalResult_isUnsignedInt>(
        'clang_EvalResult_isUnsignedInt'))(
      E,
    );
  }

  _dart_clang_EvalResult_isUnsignedInt? _clang_EvalResult_isUnsignedInt;

  /// Returns the evaluation result as an unsigned integer if the kind is Int
  /// and clang_EvalResult_isUnsignedInt is non-zero.
  int clang_EvalResult_getAsUnsigned(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getAsUnsigned ??= _dylib.lookupFunction<
            _c_clang_EvalResult_getAsUnsigned,
            _dart_clang_EvalResult_getAsUnsigned>(
        'clang_EvalResult_getAsUnsigned'))(
      E,
    );
  }

  _dart_clang_EvalResult_getAsUnsigned? _clang_EvalResult_getAsUnsigned;

  /// Returns the evaluation result as double if the kind is double.
  double clang_EvalResult_getAsDouble(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getAsDouble ??= _dylib.lookupFunction<
        _c_clang_EvalResult_getAsDouble,
        _dart_clang_EvalResult_getAsDouble>('clang_EvalResult_getAsDouble'))(
      E,
    );
  }

  _dart_clang_EvalResult_getAsDouble? _clang_EvalResult_getAsDouble;

  /// Returns the evaluation result as a constant string if the kind is other
  /// than Int or float. User must not free this pointer, instead call
  /// clang_EvalResult_dispose on the CXEvalResult returned by
  /// clang_Cursor_Evaluate.
  ffi.Pointer<ffi.Int8> clang_EvalResult_getAsStr(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_getAsStr ??= _dylib.lookupFunction<
        _c_clang_EvalResult_getAsStr,
        _dart_clang_EvalResult_getAsStr>('clang_EvalResult_getAsStr'))(
      E,
    );
  }

  _dart_clang_EvalResult_getAsStr? _clang_EvalResult_getAsStr;

  /// Disposes the created Eval memory.
  void clang_EvalResult_dispose(
    ffi.Pointer<ffi.Void> E,
  ) {
    return (_clang_EvalResult_dispose ??= _dylib.lookupFunction<
        _c_clang_EvalResult_dispose,
        _dart_clang_EvalResult_dispose>('clang_EvalResult_dispose'))(
      E,
    );
  }

  _dart_clang_EvalResult_dispose? _clang_EvalResult_dispose;

  /// Retrieve a remapping.
  ffi.Pointer<ffi.Void> clang_getRemappings(
    ffi.Pointer<ffi.Int8> path,
  ) {
    return (_clang_getRemappings ??= _dylib.lookupFunction<
        _c_clang_getRemappings,
        _dart_clang_getRemappings>('clang_getRemappings'))(
      path,
    );
  }

  _dart_clang_getRemappings? _clang_getRemappings;

  /// Retrieve a remapping.
  ffi.Pointer<ffi.Void> clang_getRemappingsFromFileList(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> filePaths,
    int numFiles,
  ) {
    return (_clang_getRemappingsFromFileList ??= _dylib.lookupFunction<
            _c_clang_getRemappingsFromFileList,
            _dart_clang_getRemappingsFromFileList>(
        'clang_getRemappingsFromFileList'))(
      filePaths,
      numFiles,
    );
  }

  _dart_clang_getRemappingsFromFileList? _clang_getRemappingsFromFileList;

  /// Determine the number of remappings.
  int clang_remap_getNumFiles(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_remap_getNumFiles ??= _dylib.lookupFunction<
        _c_clang_remap_getNumFiles,
        _dart_clang_remap_getNumFiles>('clang_remap_getNumFiles'))(
      arg0,
    );
  }

  _dart_clang_remap_getNumFiles? _clang_remap_getNumFiles;

  /// Get the original and the associated filename from the remapping.
  void clang_remap_getFilenames(
    ffi.Pointer<ffi.Void> arg0,
    int index,
    ffi.Pointer<CXString> original,
    ffi.Pointer<CXString> transformed,
  ) {
    return (_clang_remap_getFilenames ??= _dylib.lookupFunction<
        _c_clang_remap_getFilenames,
        _dart_clang_remap_getFilenames>('clang_remap_getFilenames'))(
      arg0,
      index,
      original,
      transformed,
    );
  }

  _dart_clang_remap_getFilenames? _clang_remap_getFilenames;

  /// Dispose the remapping.
  void clang_remap_dispose(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_remap_dispose ??= _dylib.lookupFunction<
        _c_clang_remap_dispose,
        _dart_clang_remap_dispose>('clang_remap_dispose'))(
      arg0,
    );
  }

  _dart_clang_remap_dispose? _clang_remap_dispose;

  /// Find references of a declaration in a specific file.
  int clang_findReferencesInFile(
    CXCursor cursor,
    ffi.Pointer<ffi.Void> file,
    CXCursorAndRangeVisitor visitor,
  ) {
    return (_clang_findReferencesInFile ??= _dylib.lookupFunction<
        _c_clang_findReferencesInFile,
        _dart_clang_findReferencesInFile>('clang_findReferencesInFile'))(
      cursor,
      file,
      visitor,
    );
  }

  _dart_clang_findReferencesInFile? _clang_findReferencesInFile;

  /// Find #import/#include directives in a specific file.
  int clang_findIncludesInFile(
    ffi.Pointer<CXTranslationUnitImpl> TU,
    ffi.Pointer<ffi.Void> file,
    CXCursorAndRangeVisitor visitor,
  ) {
    return (_clang_findIncludesInFile ??= _dylib.lookupFunction<
        _c_clang_findIncludesInFile,
        _dart_clang_findIncludesInFile>('clang_findIncludesInFile'))(
      TU,
      file,
      visitor,
    );
  }

  _dart_clang_findIncludesInFile? _clang_findIncludesInFile;

  int clang_index_isEntityObjCContainerKind(
    int arg0,
  ) {
    return (_clang_index_isEntityObjCContainerKind ??= _dylib.lookupFunction<
            _c_clang_index_isEntityObjCContainerKind,
            _dart_clang_index_isEntityObjCContainerKind>(
        'clang_index_isEntityObjCContainerKind'))(
      arg0,
    );
  }

  _dart_clang_index_isEntityObjCContainerKind?
      _clang_index_isEntityObjCContainerKind;

  ffi.Pointer<CXIdxObjCContainerDeclInfo> clang_index_getObjCContainerDeclInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getObjCContainerDeclInfo ??= _dylib.lookupFunction<
            _c_clang_index_getObjCContainerDeclInfo,
            _dart_clang_index_getObjCContainerDeclInfo>(
        'clang_index_getObjCContainerDeclInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getObjCContainerDeclInfo?
      _clang_index_getObjCContainerDeclInfo;

  ffi.Pointer<CXIdxObjCInterfaceDeclInfo> clang_index_getObjCInterfaceDeclInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getObjCInterfaceDeclInfo ??= _dylib.lookupFunction<
            _c_clang_index_getObjCInterfaceDeclInfo,
            _dart_clang_index_getObjCInterfaceDeclInfo>(
        'clang_index_getObjCInterfaceDeclInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getObjCInterfaceDeclInfo?
      _clang_index_getObjCInterfaceDeclInfo;

  ffi.Pointer<CXIdxObjCCategoryDeclInfo> clang_index_getObjCCategoryDeclInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getObjCCategoryDeclInfo ??= _dylib.lookupFunction<
            _c_clang_index_getObjCCategoryDeclInfo,
            _dart_clang_index_getObjCCategoryDeclInfo>(
        'clang_index_getObjCCategoryDeclInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getObjCCategoryDeclInfo?
      _clang_index_getObjCCategoryDeclInfo;

  ffi.Pointer<CXIdxObjCProtocolRefListInfo>
      clang_index_getObjCProtocolRefListInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getObjCProtocolRefListInfo ??= _dylib.lookupFunction<
            _c_clang_index_getObjCProtocolRefListInfo,
            _dart_clang_index_getObjCProtocolRefListInfo>(
        'clang_index_getObjCProtocolRefListInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getObjCProtocolRefListInfo?
      _clang_index_getObjCProtocolRefListInfo;

  ffi.Pointer<CXIdxObjCPropertyDeclInfo> clang_index_getObjCPropertyDeclInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getObjCPropertyDeclInfo ??= _dylib.lookupFunction<
            _c_clang_index_getObjCPropertyDeclInfo,
            _dart_clang_index_getObjCPropertyDeclInfo>(
        'clang_index_getObjCPropertyDeclInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getObjCPropertyDeclInfo?
      _clang_index_getObjCPropertyDeclInfo;

  ffi.Pointer<CXIdxIBOutletCollectionAttrInfo>
      clang_index_getIBOutletCollectionAttrInfo(
    ffi.Pointer<CXIdxAttrInfo> arg0,
  ) {
    return (_clang_index_getIBOutletCollectionAttrInfo ??=
        _dylib.lookupFunction<_c_clang_index_getIBOutletCollectionAttrInfo,
                _dart_clang_index_getIBOutletCollectionAttrInfo>(
            'clang_index_getIBOutletCollectionAttrInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getIBOutletCollectionAttrInfo?
      _clang_index_getIBOutletCollectionAttrInfo;

  ffi.Pointer<CXIdxCXXClassDeclInfo> clang_index_getCXXClassDeclInfo(
    ffi.Pointer<CXIdxDeclInfo> arg0,
  ) {
    return (_clang_index_getCXXClassDeclInfo ??= _dylib.lookupFunction<
            _c_clang_index_getCXXClassDeclInfo,
            _dart_clang_index_getCXXClassDeclInfo>(
        'clang_index_getCXXClassDeclInfo'))(
      arg0,
    );
  }

  _dart_clang_index_getCXXClassDeclInfo? _clang_index_getCXXClassDeclInfo;

  /// For retrieving a custom CXIdxClientContainer attached to a container.
  ffi.Pointer<ffi.Void> clang_index_getClientContainer(
    ffi.Pointer<CXIdxContainerInfo> arg0,
  ) {
    return (_clang_index_getClientContainer ??= _dylib.lookupFunction<
            _c_clang_index_getClientContainer,
            _dart_clang_index_getClientContainer>(
        'clang_index_getClientContainer'))(
      arg0,
    );
  }

  _dart_clang_index_getClientContainer? _clang_index_getClientContainer;

  /// For setting a custom CXIdxClientContainer attached to a container.
  void clang_index_setClientContainer(
    ffi.Pointer<CXIdxContainerInfo> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return (_clang_index_setClientContainer ??= _dylib.lookupFunction<
            _c_clang_index_setClientContainer,
            _dart_clang_index_setClientContainer>(
        'clang_index_setClientContainer'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_index_setClientContainer? _clang_index_setClientContainer;

  /// For retrieving a custom CXIdxClientEntity attached to an entity.
  ffi.Pointer<ffi.Void> clang_index_getClientEntity(
    ffi.Pointer<CXIdxEntityInfo> arg0,
  ) {
    return (_clang_index_getClientEntity ??= _dylib.lookupFunction<
        _c_clang_index_getClientEntity,
        _dart_clang_index_getClientEntity>('clang_index_getClientEntity'))(
      arg0,
    );
  }

  _dart_clang_index_getClientEntity? _clang_index_getClientEntity;

  /// For setting a custom CXIdxClientEntity attached to an entity.
  void clang_index_setClientEntity(
    ffi.Pointer<CXIdxEntityInfo> arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return (_clang_index_setClientEntity ??= _dylib.lookupFunction<
        _c_clang_index_setClientEntity,
        _dart_clang_index_setClientEntity>('clang_index_setClientEntity'))(
      arg0,
      arg1,
    );
  }

  _dart_clang_index_setClientEntity? _clang_index_setClientEntity;

  /// An indexing action/session, to be applied to one or multiple translation
  /// units.
  ffi.Pointer<ffi.Void> clang_IndexAction_create(
    ffi.Pointer<ffi.Void> CIdx,
  ) {
    return (_clang_IndexAction_create ??= _dylib.lookupFunction<
        _c_clang_IndexAction_create,
        _dart_clang_IndexAction_create>('clang_IndexAction_create'))(
      CIdx,
    );
  }

  _dart_clang_IndexAction_create? _clang_IndexAction_create;

  /// Destroy the given index action.
  void clang_IndexAction_dispose(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return (_clang_IndexAction_dispose ??= _dylib.lookupFunction<
        _c_clang_IndexAction_dispose,
        _dart_clang_IndexAction_dispose>('clang_IndexAction_dispose'))(
      arg0,
    );
  }

  _dart_clang_IndexAction_dispose? _clang_IndexAction_dispose;

  /// Index the given source file and the translation unit corresponding to that
  /// file via callbacks implemented through #IndexerCallbacks.
  int clang_indexSourceFile(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> client_data,
    ffi.Pointer<IndexerCallbacks> index_callbacks,
    int index_callbacks_size,
    int index_options,
    ffi.Pointer<ffi.Int8> source_filename,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
    int num_command_line_args,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
    int TU_options,
  ) {
    return (_clang_indexSourceFile ??= _dylib.lookupFunction<
        _c_clang_indexSourceFile,
        _dart_clang_indexSourceFile>('clang_indexSourceFile'))(
      arg0,
      client_data,
      index_callbacks,
      index_callbacks_size,
      index_options,
      source_filename,
      command_line_args,
      num_command_line_args,
      unsaved_files,
      num_unsaved_files,
      out_TU,
      TU_options,
    );
  }

  _dart_clang_indexSourceFile? _clang_indexSourceFile;

  /// Same as clang_indexSourceFile but requires a full command line for
  /// command_line_args including argv[0]. This is useful if the standard
  /// library paths are relative to the binary.
  int clang_indexSourceFileFullArgv(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> client_data,
    ffi.Pointer<IndexerCallbacks> index_callbacks,
    int index_callbacks_size,
    int index_options,
    ffi.Pointer<ffi.Int8> source_filename,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
    int num_command_line_args,
    ffi.Pointer<CXUnsavedFile> unsaved_files,
    int num_unsaved_files,
    ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
    int TU_options,
  ) {
    return (_clang_indexSourceFileFullArgv ??= _dylib.lookupFunction<
        _c_clang_indexSourceFileFullArgv,
        _dart_clang_indexSourceFileFullArgv>('clang_indexSourceFileFullArgv'))(
      arg0,
      client_data,
      index_callbacks,
      index_callbacks_size,
      index_options,
      source_filename,
      command_line_args,
      num_command_line_args,
      unsaved_files,
      num_unsaved_files,
      out_TU,
      TU_options,
    );
  }

  _dart_clang_indexSourceFileFullArgv? _clang_indexSourceFileFullArgv;

  /// Index the given translation unit via callbacks implemented through
  /// #IndexerCallbacks.
  int clang_indexTranslationUnit(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> client_data,
    ffi.Pointer<IndexerCallbacks> index_callbacks,
    int index_callbacks_size,
    int index_options,
    ffi.Pointer<CXTranslationUnitImpl> arg5,
  ) {
    return (_clang_indexTranslationUnit ??= _dylib.lookupFunction<
        _c_clang_indexTranslationUnit,
        _dart_clang_indexTranslationUnit>('clang_indexTranslationUnit'))(
      arg0,
      client_data,
      index_callbacks,
      index_callbacks_size,
      index_options,
      arg5,
    );
  }

  _dart_clang_indexTranslationUnit? _clang_indexTranslationUnit;

  /// Retrieve the CXIdxFile, file, line, column, and offset represented by the
  /// given CXIdxLoc.
  void clang_indexLoc_getFileLocation(
    CXIdxLoc loc,
    ffi.Pointer<ffi.Pointer<ffi.Void>> indexFile,
    ffi.Pointer<ffi.Pointer<ffi.Void>> file,
    ffi.Pointer<ffi.Uint32> line,
    ffi.Pointer<ffi.Uint32> column,
    ffi.Pointer<ffi.Uint32> offset,
  ) {
    return (_clang_indexLoc_getFileLocation ??= _dylib.lookupFunction<
            _c_clang_indexLoc_getFileLocation,
            _dart_clang_indexLoc_getFileLocation>(
        'clang_indexLoc_getFileLocation'))(
      loc,
      indexFile,
      file,
      line,
      column,
      offset,
    );
  }

  _dart_clang_indexLoc_getFileLocation? _clang_indexLoc_getFileLocation;

  /// Retrieve the CXSourceLocation represented by the given CXIdxLoc.
  CXSourceLocation clang_indexLoc_getCXSourceLocation(
    CXIdxLoc loc,
  ) {
    return (_clang_indexLoc_getCXSourceLocation ??= _dylib.lookupFunction<
            _c_clang_indexLoc_getCXSourceLocation,
            _dart_clang_indexLoc_getCXSourceLocation>(
        'clang_indexLoc_getCXSourceLocation'))(
      loc,
    );
  }

  _dart_clang_indexLoc_getCXSourceLocation? _clang_indexLoc_getCXSourceLocation;

  /// Visit the fields of a particular type.
  int clang_Type_visitFields(
    CXType T,
    ffi.Pointer<ffi.NativeFunction<CXFieldVisitor>> visitor,
    ffi.Pointer<ffi.Void> client_data,
  ) {
    return (_clang_Type_visitFields ??= _dylib.lookupFunction<
        _c_clang_Type_visitFields,
        _dart_clang_Type_visitFields>('clang_Type_visitFields'))(
      T,
      visitor,
      client_data,
    );
  }

  _dart_clang_Type_visitFields? _clang_Type_visitFields;
}

/// Error codes returned by libclang routines.
abstract class CXErrorCode {
  /// No error.
  static const int CXError_Success = 0;

  /// A generic error code, no further details are available.
  static const int CXError_Failure = 1;

  /// libclang crashed while performing the requested operation.
  static const int CXError_Crashed = 2;

  /// The function detected that the arguments violate the function contract.
  static const int CXError_InvalidArguments = 3;

  /// An AST deserialization error has occurred.
  static const int CXError_ASTReadError = 4;
}

/// A character string.
class CXString extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Uint32()
  external int private_flags;
}

class CXStringSet extends ffi.Struct {
  external ffi.Pointer<CXString> Strings;

  @ffi.Uint32()
  external int Count;
}

class CXVirtualFileOverlayImpl extends ffi.Struct {}

class CXModuleMapDescriptorImpl extends ffi.Struct {}

class CXTargetInfoImpl extends ffi.Struct {}

class CXTranslationUnitImpl extends ffi.Struct {}

/// Provides the contents of a file that has not yet been saved to disk.
class CXUnsavedFile extends ffi.Struct {
  /// The file whose contents have not yet been saved.
  external ffi.Pointer<ffi.Int8> Filename;

  /// A buffer containing the unsaved contents of this file.
  external ffi.Pointer<ffi.Int8> Contents;

  /// The length of the unsaved contents of this buffer.
  @ffi.Uint64()
  external int Length;
}

/// Describes the availability of a particular entity, which indicates whether
/// the use of this entity will result in a warning or error due to it being
/// deprecated or unavailable.
abstract class CXAvailabilityKind {
  /// The entity is available.
  static const int CXAvailability_Available = 0;

  /// The entity is available, but has been deprecated (and its use is not
  /// recommended).
  static const int CXAvailability_Deprecated = 1;

  /// The entity is not available; any use of it will be an error.
  static const int CXAvailability_NotAvailable = 2;

  /// The entity is available, but not accessible; any use of it will be an
  /// error.
  static const int CXAvailability_NotAccessible = 3;
}

/// Describes a version number of the form major.minor.subminor.
class CXVersion extends ffi.Struct {
  /// The major version number, e.g., the '10' in '10.7.3'. A negative value
  /// indicates that there is no version number at all.
  @ffi.Int32()
  external int Major;

  /// The minor version number, e.g., the '7' in '10.7.3'. This value will be
  /// negative if no minor version number was provided, e.g., for version '10'.
  @ffi.Int32()
  external int Minor;

  /// The subminor version number, e.g., the '3' in '10.7.3'. This value will be
  /// negative if no minor or subminor version number was provided, e.g., in
  /// version '10' or '10.7'.
  @ffi.Int32()
  external int Subminor;
}

/// Describes the exception specification of a cursor.
abstract class CXCursor_ExceptionSpecificationKind {
  /// The cursor has no exception specification.
  static const int CXCursor_ExceptionSpecificationKind_None = 0;

  /// The cursor has exception specification throw()
  static const int CXCursor_ExceptionSpecificationKind_DynamicNone = 1;

  /// The cursor has exception specification throw(T1, T2)
  static const int CXCursor_ExceptionSpecificationKind_Dynamic = 2;

  /// The cursor has exception specification throw(...).
  static const int CXCursor_ExceptionSpecificationKind_MSAny = 3;

  /// The cursor has exception specification basic noexcept.
  static const int CXCursor_ExceptionSpecificationKind_BasicNoexcept = 4;

  /// The cursor has exception specification computed noexcept.
  static const int CXCursor_ExceptionSpecificationKind_ComputedNoexcept = 5;

  /// The exception specification has not yet been evaluated.
  static const int CXCursor_ExceptionSpecificationKind_Unevaluated = 6;

  /// The exception specification has not yet been instantiated.
  static const int CXCursor_ExceptionSpecificationKind_Uninstantiated = 7;

  /// The exception specification has not been parsed yet.
  static const int CXCursor_ExceptionSpecificationKind_Unparsed = 8;

  /// The cursor has a __declspec(nothrow) exception specification.
  static const int CXCursor_ExceptionSpecificationKind_NoThrow = 9;
}

abstract class CXGlobalOptFlags {
  /// Used to indicate that no special CXIndex options are needed.
  static const int CXGlobalOpt_None = 0;

  /// Used to indicate that threads that libclang creates for indexing purposes
  /// should use background priority.
  static const int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 1;

  /// Used to indicate that threads that libclang creates for editing purposes
  /// should use background priority.
  static const int CXGlobalOpt_ThreadBackgroundPriorityForEditing = 2;

  /// Used to indicate that all threads that libclang creates should use
  /// background priority.
  static const int CXGlobalOpt_ThreadBackgroundPriorityForAll = 3;
}

/// Uniquely identifies a CXFile, that refers to the same underlying file,
/// across an indexing session.
class CXFileUniqueID extends ffi.Struct {
  @ffi.Uint64()
  external int _unique_data_item_0;
  @ffi.Uint64()
  external int _unique_data_item_1;
  @ffi.Uint64()
  external int _unique_data_item_2;

  /// Helper for array `data`.
  ArrayHelper_CXFileUniqueID_data_level0 get data =>
      ArrayHelper_CXFileUniqueID_data_level0(this, [3], 0, 0);
}

/// Helper for array `data` in struct `CXFileUniqueID`.
class ArrayHelper_CXFileUniqueID_data_level0 {
  final CXFileUniqueID _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXFileUniqueID_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Identifies a specific source location within a translation unit.
class CXSourceLocation extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_0;
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_1;

  /// Helper for array `ptr_data`.
  ArrayHelper_CXSourceLocation_ptr_data_level0 get ptr_data =>
      ArrayHelper_CXSourceLocation_ptr_data_level0(this, [2], 0, 0);
  @ffi.Uint32()
  external int int_data;
}

/// Helper for array `ptr_data` in struct `CXSourceLocation`.
class ArrayHelper_CXSourceLocation_ptr_data_level0 {
  final CXSourceLocation _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXSourceLocation_ptr_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_ptr_data_item_0;
      case 1:
        return _struct._unique_ptr_data_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_ptr_data_item_0 = value;
        break;
      case 1:
        _struct._unique_ptr_data_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Identifies a half-open character range in the source code.
class CXSourceRange extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_0;
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_1;

  /// Helper for array `ptr_data`.
  ArrayHelper_CXSourceRange_ptr_data_level0 get ptr_data =>
      ArrayHelper_CXSourceRange_ptr_data_level0(this, [2], 0, 0);
  @ffi.Uint32()
  external int begin_int_data;

  @ffi.Uint32()
  external int end_int_data;
}

/// Helper for array `ptr_data` in struct `CXSourceRange`.
class ArrayHelper_CXSourceRange_ptr_data_level0 {
  final CXSourceRange _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXSourceRange_ptr_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_ptr_data_item_0;
      case 1:
        return _struct._unique_ptr_data_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_ptr_data_item_0 = value;
        break;
      case 1:
        _struct._unique_ptr_data_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Identifies an array of ranges.
class CXSourceRangeList extends ffi.Struct {
  /// The number of ranges in the ranges array.
  @ffi.Uint32()
  external int count;

  /// An array of CXSourceRanges.
  external ffi.Pointer<CXSourceRange> ranges;
}

/// Describes the severity of a particular diagnostic.
abstract class CXDiagnosticSeverity {
  /// A diagnostic that has been suppressed, e.g., by a command-line option.
  static const int CXDiagnostic_Ignored = 0;

  /// This diagnostic is a note that should be attached to the previous
  /// (non-note) diagnostic.
  static const int CXDiagnostic_Note = 1;

  /// This diagnostic indicates suspicious code that may not be wrong.
  static const int CXDiagnostic_Warning = 2;

  /// This diagnostic indicates that the code is ill-formed.
  static const int CXDiagnostic_Error = 3;

  /// This diagnostic indicates that the code is ill-formed such that future
  /// parser recovery is unlikely to produce useful results.
  static const int CXDiagnostic_Fatal = 4;
}

/// Describes the kind of error that occurred (if any) in a call to
/// clang_loadDiagnostics.
abstract class CXLoadDiag_Error {
  /// Indicates that no error occurred.
  static const int CXLoadDiag_None = 0;

  /// Indicates that an unknown error occurred while attempting to deserialize
  /// diagnostics.
  static const int CXLoadDiag_Unknown = 1;

  /// Indicates that the file containing the serialized diagnostics could not be
  /// opened.
  static const int CXLoadDiag_CannotLoad = 2;

  /// Indicates that the serialized diagnostics file is invalid or corrupt.
  static const int CXLoadDiag_InvalidFile = 3;
}

/// Options to control the display of diagnostics.
abstract class CXDiagnosticDisplayOptions {
  /// Display the source-location information where the diagnostic was located.
  static const int CXDiagnostic_DisplaySourceLocation = 1;

  /// If displaying the source-location information of the diagnostic, also
  /// include the column number.
  static const int CXDiagnostic_DisplayColumn = 2;

  /// If displaying the source-location information of the diagnostic, also
  /// include information about source ranges in a machine-parsable format.
  static const int CXDiagnostic_DisplaySourceRanges = 4;

  /// Display the option name associated with this diagnostic, if any.
  static const int CXDiagnostic_DisplayOption = 8;

  /// Display the category number associated with this diagnostic, if any.
  static const int CXDiagnostic_DisplayCategoryId = 16;

  /// Display the category name associated with this diagnostic, if any.
  static const int CXDiagnostic_DisplayCategoryName = 32;
}

/// Flags that control the creation of translation units.
abstract class CXTranslationUnit_Flags {
  /// Used to indicate that no special translation-unit options are needed.
  static const int CXTranslationUnit_None = 0;

  /// Used to indicate that the parser should construct a "detailed"
  /// preprocessing record, including all macro definitions and instantiations.
  static const int CXTranslationUnit_DetailedPreprocessingRecord = 1;

  /// Used to indicate that the translation unit is incomplete.
  static const int CXTranslationUnit_Incomplete = 2;

  /// Used to indicate that the translation unit should be built with an
  /// implicit precompiled header for the preamble.
  static const int CXTranslationUnit_PrecompiledPreamble = 4;

  /// Used to indicate that the translation unit should cache some
  /// code-completion results with each reparse of the source file.
  static const int CXTranslationUnit_CacheCompletionResults = 8;

  /// Used to indicate that the translation unit will be serialized with
  /// clang_saveTranslationUnit.
  static const int CXTranslationUnit_ForSerialization = 16;

  /// DEPRECATED: Enabled chained precompiled preambles in C++.
  static const int CXTranslationUnit_CXXChainedPCH = 32;

  /// Used to indicate that function/method bodies should be skipped while
  /// parsing.
  static const int CXTranslationUnit_SkipFunctionBodies = 64;

  /// Used to indicate that brief documentation comments should be included into
  /// the set of code completions returned from this translation unit.
  static const int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 128;

  /// Used to indicate that the precompiled preamble should be created on the
  /// first parse. Otherwise it will be created on the first reparse. This
  /// trades runtime on the first parse (serializing the preamble takes time)
  /// for reduced runtime on the second parse (can now reuse the preamble).
  static const int CXTranslationUnit_CreatePreambleOnFirstParse = 256;

  /// Do not stop processing when fatal errors are encountered.
  static const int CXTranslationUnit_KeepGoing = 512;

  /// Sets the preprocessor in a mode for parsing a single file only.
  static const int CXTranslationUnit_SingleFileParse = 1024;

  /// Used in combination with CXTranslationUnit_SkipFunctionBodies to constrain
  /// the skipping of function bodies to the preamble.
  static const int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 2048;

  /// Used to indicate that attributed types should be included in CXType.
  static const int CXTranslationUnit_IncludeAttributedTypes = 4096;

  /// Used to indicate that implicit attributes should be visited.
  static const int CXTranslationUnit_VisitImplicitAttributes = 8192;

  /// Used to indicate that non-errors from included files should be ignored.
  static const int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 16384;

  /// Tells the preprocessor not to skip excluded conditional blocks.
  static const int CXTranslationUnit_RetainExcludedConditionalBlocks = 32768;
}

/// Flags that control how translation units are saved.
abstract class CXSaveTranslationUnit_Flags {
  /// Used to indicate that no special saving options are needed.
  static const int CXSaveTranslationUnit_None = 0;
}

/// Describes the kind of error that occurred (if any) in a call to
/// clang_saveTranslationUnit().
abstract class CXSaveError {
  /// Indicates that no error occurred while saving a translation unit.
  static const int CXSaveError_None = 0;

  /// Indicates that an unknown error occurred while attempting to save the
  /// file.
  static const int CXSaveError_Unknown = 1;

  /// Indicates that errors during translation prevented this attempt to save
  /// the translation unit.
  static const int CXSaveError_TranslationErrors = 2;

  /// Indicates that the translation unit to be saved was somehow invalid (e.g.,
  /// NULL).
  static const int CXSaveError_InvalidTU = 3;
}

/// Flags that control the reparsing of translation units.
abstract class CXReparse_Flags {
  /// Used to indicate that no special reparsing options are needed.
  static const int CXReparse_None = 0;
}

/// Categorizes how memory is being used by a translation unit.
abstract class CXTUResourceUsageKind {
  static const int CXTUResourceUsage_AST = 1;
  static const int CXTUResourceUsage_Identifiers = 2;
  static const int CXTUResourceUsage_Selectors = 3;
  static const int CXTUResourceUsage_GlobalCompletionResults = 4;
  static const int CXTUResourceUsage_SourceManagerContentCache = 5;
  static const int CXTUResourceUsage_AST_SideTables = 6;
  static const int CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7;
  static const int CXTUResourceUsage_SourceManager_Membuffer_MMap = 8;
  static const int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9;
  static const int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10;
  static const int CXTUResourceUsage_Preprocessor = 11;
  static const int CXTUResourceUsage_PreprocessingRecord = 12;
  static const int CXTUResourceUsage_SourceManager_DataStructures = 13;
  static const int CXTUResourceUsage_Preprocessor_HeaderSearch = 14;
  static const int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = 1;
  static const int CXTUResourceUsage_MEMORY_IN_BYTES_END = 14;
  static const int CXTUResourceUsage_First = 1;
  static const int CXTUResourceUsage_Last = 14;
}

class CXTUResourceUsageEntry extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  @ffi.Uint64()
  external int amount;
}

/// The memory usage of a CXTranslationUnit, broken into categories.
class CXTUResourceUsage extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  @ffi.Uint32()
  external int numEntries;

  external ffi.Pointer<CXTUResourceUsageEntry> entries;
}

/// Describes the kind of entity that a cursor refers to.
abstract class CXCursorKind {
  /// A declaration whose specific kind is not exposed via this interface.
  static const int CXCursor_UnexposedDecl = 1;

  /// A C or C++ struct.
  static const int CXCursor_StructDecl = 2;

  /// A C or C++ union.
  static const int CXCursor_UnionDecl = 3;

  /// A C++ class.
  static const int CXCursor_ClassDecl = 4;

  /// An enumeration.
  static const int CXCursor_EnumDecl = 5;

  /// A field (in C) or non-static data member (in C++) in a struct, union, or
  /// C++ class.
  static const int CXCursor_FieldDecl = 6;

  /// An enumerator constant.
  static const int CXCursor_EnumConstantDecl = 7;

  /// A function.
  static const int CXCursor_FunctionDecl = 8;

  /// A variable.
  static const int CXCursor_VarDecl = 9;

  /// A function or method parameter.
  static const int CXCursor_ParmDecl = 10;

  /// An Objective-C @interface.
  static const int CXCursor_ObjCInterfaceDecl = 11;

  /// An Objective-C @interface for a category.
  static const int CXCursor_ObjCCategoryDecl = 12;

  /// An Objective-C @protocol declaration.
  static const int CXCursor_ObjCProtocolDecl = 13;

  /// An Objective-C @property declaration.
  static const int CXCursor_ObjCPropertyDecl = 14;

  /// An Objective-C instance variable.
  static const int CXCursor_ObjCIvarDecl = 15;

  /// An Objective-C instance method.
  static const int CXCursor_ObjCInstanceMethodDecl = 16;

  /// An Objective-C class method.
  static const int CXCursor_ObjCClassMethodDecl = 17;

  /// An Objective-C @implementation.
  static const int CXCursor_ObjCImplementationDecl = 18;

  /// An Objective-C @implementation for a category.
  static const int CXCursor_ObjCCategoryImplDecl = 19;

  /// A typedef.
  static const int CXCursor_TypedefDecl = 20;

  /// A C++ class method.
  static const int CXCursor_CXXMethod = 21;

  /// A C++ namespace.
  static const int CXCursor_Namespace = 22;

  /// A linkage specification, e.g. 'extern "C"'.
  static const int CXCursor_LinkageSpec = 23;

  /// A C++ constructor.
  static const int CXCursor_Constructor = 24;

  /// A C++ destructor.
  static const int CXCursor_Destructor = 25;

  /// A C++ conversion function.
  static const int CXCursor_ConversionFunction = 26;

  /// A C++ template type parameter.
  static const int CXCursor_TemplateTypeParameter = 27;

  /// A C++ non-type template parameter.
  static const int CXCursor_NonTypeTemplateParameter = 28;

  /// A C++ template template parameter.
  static const int CXCursor_TemplateTemplateParameter = 29;

  /// A C++ function template.
  static const int CXCursor_FunctionTemplate = 30;

  /// A C++ class template.
  static const int CXCursor_ClassTemplate = 31;

  /// A C++ class template partial specialization.
  static const int CXCursor_ClassTemplatePartialSpecialization = 32;

  /// A C++ namespace alias declaration.
  static const int CXCursor_NamespaceAlias = 33;

  /// A C++ using directive.
  static const int CXCursor_UsingDirective = 34;

  /// A C++ using declaration.
  static const int CXCursor_UsingDeclaration = 35;

  /// A C++ alias declaration
  static const int CXCursor_TypeAliasDecl = 36;

  /// An Objective-C @synthesize definition.
  static const int CXCursor_ObjCSynthesizeDecl = 37;

  /// An Objective-C @dynamic definition.
  static const int CXCursor_ObjCDynamicDecl = 38;

  /// An access specifier.
  static const int CXCursor_CXXAccessSpecifier = 39;
  static const int CXCursor_FirstDecl = 1;
  static const int CXCursor_LastDecl = 39;
  static const int CXCursor_FirstRef = 40;
  static const int CXCursor_ObjCSuperClassRef = 40;
  static const int CXCursor_ObjCProtocolRef = 41;
  static const int CXCursor_ObjCClassRef = 42;

  /// A reference to a type declaration.
  static const int CXCursor_TypeRef = 43;
  static const int CXCursor_CXXBaseSpecifier = 44;

  /// A reference to a class template, function template, template template
  /// parameter, or class template partial specialization.
  static const int CXCursor_TemplateRef = 45;

  /// A reference to a namespace or namespace alias.
  static const int CXCursor_NamespaceRef = 46;

  /// A reference to a member of a struct, union, or class that occurs in some
  /// non-expression context, e.g., a designated initializer.
  static const int CXCursor_MemberRef = 47;

  /// A reference to a labeled statement.
  static const int CXCursor_LabelRef = 48;

  /// A reference to a set of overloaded functions or function templates that
  /// has not yet been resolved to a specific function or function template.
  static const int CXCursor_OverloadedDeclRef = 49;

  /// A reference to a variable that occurs in some non-expression context,
  /// e.g., a C++ lambda capture list.
  static const int CXCursor_VariableRef = 50;
  static const int CXCursor_LastRef = 50;
  static const int CXCursor_FirstInvalid = 70;
  static const int CXCursor_InvalidFile = 70;
  static const int CXCursor_NoDeclFound = 71;
  static const int CXCursor_NotImplemented = 72;
  static const int CXCursor_InvalidCode = 73;
  static const int CXCursor_LastInvalid = 73;
  static const int CXCursor_FirstExpr = 100;

  /// An expression whose specific kind is not exposed via this interface.
  static const int CXCursor_UnexposedExpr = 100;

  /// An expression that refers to some value declaration, such as a function,
  /// variable, or enumerator.
  static const int CXCursor_DeclRefExpr = 101;

  /// An expression that refers to a member of a struct, union, class,
  /// Objective-C class, etc.
  static const int CXCursor_MemberRefExpr = 102;

  /// An expression that calls a function.
  static const int CXCursor_CallExpr = 103;

  /// An expression that sends a message to an Objective-C object or class.
  static const int CXCursor_ObjCMessageExpr = 104;

  /// An expression that represents a block literal.
  static const int CXCursor_BlockExpr = 105;

  /// An integer literal.
  static const int CXCursor_IntegerLiteral = 106;

  /// A floating point number literal.
  static const int CXCursor_FloatingLiteral = 107;

  /// An imaginary number literal.
  static const int CXCursor_ImaginaryLiteral = 108;

  /// A string literal.
  static const int CXCursor_StringLiteral = 109;

  /// A character literal.
  static const int CXCursor_CharacterLiteral = 110;

  /// A parenthesized expression, e.g. "(1)".
  static const int CXCursor_ParenExpr = 111;

  /// This represents the unary-expression's (except sizeof and alignof).
  static const int CXCursor_UnaryOperator = 112;

  /// [C99 6.5.2.1] Array Subscripting.
  static const int CXCursor_ArraySubscriptExpr = 113;

  /// A builtin binary operation expression such as "x + y" or "x <= y".
  static const int CXCursor_BinaryOperator = 114;

  /// Compound assignment such as "+=".
  static const int CXCursor_CompoundAssignOperator = 115;

  /// The ?: ternary operator.
  static const int CXCursor_ConditionalOperator = 116;

  /// An explicit cast in C (C99 6.5.4) or a C-style cast in C++ (C++
  /// [expr.cast]), which uses the syntax (Type)expr.
  static const int CXCursor_CStyleCastExpr = 117;

  /// [C99 6.5.2.5]
  static const int CXCursor_CompoundLiteralExpr = 118;

  /// Describes an C or C++ initializer list.
  static const int CXCursor_InitListExpr = 119;

  /// The GNU address of label extension, representing &&label.
  static const int CXCursor_AddrLabelExpr = 120;

  /// This is the GNU Statement Expression extension: ({int X=4; X;})
  static const int CXCursor_StmtExpr = 121;

  /// Represents a C11 generic selection.
  static const int CXCursor_GenericSelectionExpr = 122;

  /// Implements the GNU __null extension, which is a name for a null pointer
  /// constant that has integral type (e.g., int or long) and is the same size
  /// and alignment as a pointer.
  static const int CXCursor_GNUNullExpr = 123;

  /// C++'s static_cast<> expression.
  static const int CXCursor_CXXStaticCastExpr = 124;

  /// C++'s dynamic_cast<> expression.
  static const int CXCursor_CXXDynamicCastExpr = 125;

  /// C++'s reinterpret_cast<> expression.
  static const int CXCursor_CXXReinterpretCastExpr = 126;

  /// C++'s const_cast<> expression.
  static const int CXCursor_CXXConstCastExpr = 127;

  /// Represents an explicit C++ type conversion that uses "functional" notion
  /// (C++ [expr.type.conv]).
  static const int CXCursor_CXXFunctionalCastExpr = 128;

  /// A C++ typeid expression (C++ [expr.typeid]).
  static const int CXCursor_CXXTypeidExpr = 129;

  /// [C++ 2.13.5] C++ Boolean Literal.
  static const int CXCursor_CXXBoolLiteralExpr = 130;

  /// [C++0x 2.14.7] C++ Pointer Literal.
  static const int CXCursor_CXXNullPtrLiteralExpr = 131;

  /// Represents the "this" expression in C++
  static const int CXCursor_CXXThisExpr = 132;

  /// [C++ 15] C++ Throw Expression.
  static const int CXCursor_CXXThrowExpr = 133;

  /// A new expression for memory allocation and constructor calls, e.g: "new
  /// CXXNewExpr(foo)".
  static const int CXCursor_CXXNewExpr = 134;

  /// A delete expression for memory deallocation and destructor calls, e.g.
  /// "delete[] pArray".
  static const int CXCursor_CXXDeleteExpr = 135;

  /// A unary expression. (noexcept, sizeof, or other traits)
  static const int CXCursor_UnaryExpr = 136;

  /// An Objective-C string literal i.e. "foo".
  static const int CXCursor_ObjCStringLiteral = 137;

  /// An Objective-C @encode expression.
  static const int CXCursor_ObjCEncodeExpr = 138;

  /// An Objective-C @selector expression.
  static const int CXCursor_ObjCSelectorExpr = 139;

  /// An Objective-C @protocol expression.
  static const int CXCursor_ObjCProtocolExpr = 140;

  /// An Objective-C "bridged" cast expression, which casts between Objective-C
  /// pointers and C pointers, transferring ownership in the process.
  static const int CXCursor_ObjCBridgedCastExpr = 141;

  /// Represents a C++0x pack expansion that produces a sequence of expressions.
  static const int CXCursor_PackExpansionExpr = 142;

  /// Represents an expression that computes the length of a parameter pack.
  static const int CXCursor_SizeOfPackExpr = 143;
  static const int CXCursor_LambdaExpr = 144;

  /// Objective-c Boolean Literal.
  static const int CXCursor_ObjCBoolLiteralExpr = 145;

  /// Represents the "self" expression in an Objective-C method.
  static const int CXCursor_ObjCSelfExpr = 146;

  /// OpenMP 4.0 [2.4, Array Section].
  static const int CXCursor_OMPArraySectionExpr = 147;

  /// Represents an (...) check.
  static const int CXCursor_ObjCAvailabilityCheckExpr = 148;

  /// Fixed point literal
  static const int CXCursor_FixedPointLiteral = 149;
  static const int CXCursor_LastExpr = 149;
  static const int CXCursor_FirstStmt = 200;

  /// A statement whose specific kind is not exposed via this interface.
  static const int CXCursor_UnexposedStmt = 200;

  /// A labelled statement in a function.
  static const int CXCursor_LabelStmt = 201;

  /// A group of statements like { stmt stmt }.
  static const int CXCursor_CompoundStmt = 202;

  /// A case statement.
  static const int CXCursor_CaseStmt = 203;

  /// A default statement.
  static const int CXCursor_DefaultStmt = 204;

  /// An if statement
  static const int CXCursor_IfStmt = 205;

  /// A switch statement.
  static const int CXCursor_SwitchStmt = 206;

  /// A while statement.
  static const int CXCursor_WhileStmt = 207;

  /// A do statement.
  static const int CXCursor_DoStmt = 208;

  /// A for statement.
  static const int CXCursor_ForStmt = 209;

  /// A goto statement.
  static const int CXCursor_GotoStmt = 210;

  /// An indirect goto statement.
  static const int CXCursor_IndirectGotoStmt = 211;

  /// A continue statement.
  static const int CXCursor_ContinueStmt = 212;

  /// A break statement.
  static const int CXCursor_BreakStmt = 213;

  /// A return statement.
  static const int CXCursor_ReturnStmt = 214;

  /// A GCC inline assembly statement extension.
  static const int CXCursor_GCCAsmStmt = 215;
  static const int CXCursor_AsmStmt = 215;

  /// Objective-C's overall @try-@catch-@finally statement.
  static const int CXCursor_ObjCAtTryStmt = 216;

  /// Objective-C's @catch statement.
  static const int CXCursor_ObjCAtCatchStmt = 217;

  /// Objective-C's @finally statement.
  static const int CXCursor_ObjCAtFinallyStmt = 218;

  /// Objective-C's @throw statement.
  static const int CXCursor_ObjCAtThrowStmt = 219;

  /// Objective-C's @synchronized statement.
  static const int CXCursor_ObjCAtSynchronizedStmt = 220;

  /// Objective-C's autorelease pool statement.
  static const int CXCursor_ObjCAutoreleasePoolStmt = 221;

  /// Objective-C's collection statement.
  static const int CXCursor_ObjCForCollectionStmt = 222;

  /// C++'s catch statement.
  static const int CXCursor_CXXCatchStmt = 223;

  /// C++'s try statement.
  static const int CXCursor_CXXTryStmt = 224;

  /// C++'s for (* : *) statement.
  static const int CXCursor_CXXForRangeStmt = 225;

  /// Windows Structured Exception Handling's try statement.
  static const int CXCursor_SEHTryStmt = 226;

  /// Windows Structured Exception Handling's except statement.
  static const int CXCursor_SEHExceptStmt = 227;

  /// Windows Structured Exception Handling's finally statement.
  static const int CXCursor_SEHFinallyStmt = 228;

  /// A MS inline assembly statement extension.
  static const int CXCursor_MSAsmStmt = 229;

  /// The null statement ";": C99 6.8.3p3.
  static const int CXCursor_NullStmt = 230;

  /// Adaptor class for mixing declarations with statements and expressions.
  static const int CXCursor_DeclStmt = 231;

  /// OpenMP parallel directive.
  static const int CXCursor_OMPParallelDirective = 232;

  /// OpenMP SIMD directive.
  static const int CXCursor_OMPSimdDirective = 233;

  /// OpenMP for directive.
  static const int CXCursor_OMPForDirective = 234;

  /// OpenMP sections directive.
  static const int CXCursor_OMPSectionsDirective = 235;

  /// OpenMP section directive.
  static const int CXCursor_OMPSectionDirective = 236;

  /// OpenMP single directive.
  static const int CXCursor_OMPSingleDirective = 237;

  /// OpenMP parallel for directive.
  static const int CXCursor_OMPParallelForDirective = 238;

  /// OpenMP parallel sections directive.
  static const int CXCursor_OMPParallelSectionsDirective = 239;

  /// OpenMP task directive.
  static const int CXCursor_OMPTaskDirective = 240;

  /// OpenMP master directive.
  static const int CXCursor_OMPMasterDirective = 241;

  /// OpenMP critical directive.
  static const int CXCursor_OMPCriticalDirective = 242;

  /// OpenMP taskyield directive.
  static const int CXCursor_OMPTaskyieldDirective = 243;

  /// OpenMP barrier directive.
  static const int CXCursor_OMPBarrierDirective = 244;

  /// OpenMP taskwait directive.
  static const int CXCursor_OMPTaskwaitDirective = 245;

  /// OpenMP flush directive.
  static const int CXCursor_OMPFlushDirective = 246;

  /// Windows Structured Exception Handling's leave statement.
  static const int CXCursor_SEHLeaveStmt = 247;

  /// OpenMP ordered directive.
  static const int CXCursor_OMPOrderedDirective = 248;

  /// OpenMP atomic directive.
  static const int CXCursor_OMPAtomicDirective = 249;

  /// OpenMP for SIMD directive.
  static const int CXCursor_OMPForSimdDirective = 250;

  /// OpenMP parallel for SIMD directive.
  static const int CXCursor_OMPParallelForSimdDirective = 251;

  /// OpenMP target directive.
  static const int CXCursor_OMPTargetDirective = 252;

  /// OpenMP teams directive.
  static const int CXCursor_OMPTeamsDirective = 253;

  /// OpenMP taskgroup directive.
  static const int CXCursor_OMPTaskgroupDirective = 254;

  /// OpenMP cancellation point directive.
  static const int CXCursor_OMPCancellationPointDirective = 255;

  /// OpenMP cancel directive.
  static const int CXCursor_OMPCancelDirective = 256;

  /// OpenMP target data directive.
  static const int CXCursor_OMPTargetDataDirective = 257;

  /// OpenMP taskloop directive.
  static const int CXCursor_OMPTaskLoopDirective = 258;

  /// OpenMP taskloop simd directive.
  static const int CXCursor_OMPTaskLoopSimdDirective = 259;

  /// OpenMP distribute directive.
  static const int CXCursor_OMPDistributeDirective = 260;

  /// OpenMP target enter data directive.
  static const int CXCursor_OMPTargetEnterDataDirective = 261;

  /// OpenMP target exit data directive.
  static const int CXCursor_OMPTargetExitDataDirective = 262;

  /// OpenMP target parallel directive.
  static const int CXCursor_OMPTargetParallelDirective = 263;

  /// OpenMP target parallel for directive.
  static const int CXCursor_OMPTargetParallelForDirective = 264;

  /// OpenMP target update directive.
  static const int CXCursor_OMPTargetUpdateDirective = 265;

  /// OpenMP distribute parallel for directive.
  static const int CXCursor_OMPDistributeParallelForDirective = 266;

  /// OpenMP distribute parallel for simd directive.
  static const int CXCursor_OMPDistributeParallelForSimdDirective = 267;

  /// OpenMP distribute simd directive.
  static const int CXCursor_OMPDistributeSimdDirective = 268;

  /// OpenMP target parallel for simd directive.
  static const int CXCursor_OMPTargetParallelForSimdDirective = 269;

  /// OpenMP target simd directive.
  static const int CXCursor_OMPTargetSimdDirective = 270;

  /// OpenMP teams distribute directive.
  static const int CXCursor_OMPTeamsDistributeDirective = 271;

  /// OpenMP teams distribute simd directive.
  static const int CXCursor_OMPTeamsDistributeSimdDirective = 272;

  /// OpenMP teams distribute parallel for simd directive.
  static const int CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273;

  /// OpenMP teams distribute parallel for directive.
  static const int CXCursor_OMPTeamsDistributeParallelForDirective = 274;

  /// OpenMP target teams directive.
  static const int CXCursor_OMPTargetTeamsDirective = 275;

  /// OpenMP target teams distribute directive.
  static const int CXCursor_OMPTargetTeamsDistributeDirective = 276;

  /// OpenMP target teams distribute parallel for directive.
  static const int CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277;

  /// OpenMP target teams distribute parallel for simd directive.
  static const int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective =
      278;

  /// OpenMP target teams distribute simd directive.
  static const int CXCursor_OMPTargetTeamsDistributeSimdDirective = 279;

  /// C++2a std::bit_cast expression.
  static const int CXCursor_BuiltinBitCastExpr = 280;

  /// OpenMP master taskloop directive.
  static const int CXCursor_OMPMasterTaskLoopDirective = 281;

  /// OpenMP parallel master taskloop directive.
  static const int CXCursor_OMPParallelMasterTaskLoopDirective = 282;

  /// OpenMP master taskloop simd directive.
  static const int CXCursor_OMPMasterTaskLoopSimdDirective = 283;

  /// OpenMP parallel master taskloop simd directive.
  static const int CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284;

  /// OpenMP parallel master directive.
  static const int CXCursor_OMPParallelMasterDirective = 285;
  static const int CXCursor_LastStmt = 285;

  /// Cursor that represents the translation unit itself.
  static const int CXCursor_TranslationUnit = 300;
  static const int CXCursor_FirstAttr = 400;

  /// An attribute whose specific kind is not exposed via this interface.
  static const int CXCursor_UnexposedAttr = 400;
  static const int CXCursor_IBActionAttr = 401;
  static const int CXCursor_IBOutletAttr = 402;
  static const int CXCursor_IBOutletCollectionAttr = 403;
  static const int CXCursor_CXXFinalAttr = 404;
  static const int CXCursor_CXXOverrideAttr = 405;
  static const int CXCursor_AnnotateAttr = 406;
  static const int CXCursor_AsmLabelAttr = 407;
  static const int CXCursor_PackedAttr = 408;
  static const int CXCursor_PureAttr = 409;
  static const int CXCursor_ConstAttr = 410;
  static const int CXCursor_NoDuplicateAttr = 411;
  static const int CXCursor_CUDAConstantAttr = 412;
  static const int CXCursor_CUDADeviceAttr = 413;
  static const int CXCursor_CUDAGlobalAttr = 414;
  static const int CXCursor_CUDAHostAttr = 415;
  static const int CXCursor_CUDASharedAttr = 416;
  static const int CXCursor_VisibilityAttr = 417;
  static const int CXCursor_DLLExport = 418;
  static const int CXCursor_DLLImport = 419;
  static const int CXCursor_NSReturnsRetained = 420;
  static const int CXCursor_NSReturnsNotRetained = 421;
  static const int CXCursor_NSReturnsAutoreleased = 422;
  static const int CXCursor_NSConsumesSelf = 423;
  static const int CXCursor_NSConsumed = 424;
  static const int CXCursor_ObjCException = 425;
  static const int CXCursor_ObjCNSObject = 426;
  static const int CXCursor_ObjCIndependentClass = 427;
  static const int CXCursor_ObjCPreciseLifetime = 428;
  static const int CXCursor_ObjCReturnsInnerPointer = 429;
  static const int CXCursor_ObjCRequiresSuper = 430;
  static const int CXCursor_ObjCRootClass = 431;
  static const int CXCursor_ObjCSubclassingRestricted = 432;
  static const int CXCursor_ObjCExplicitProtocolImpl = 433;
  static const int CXCursor_ObjCDesignatedInitializer = 434;
  static const int CXCursor_ObjCRuntimeVisible = 435;
  static const int CXCursor_ObjCBoxable = 436;
  static const int CXCursor_FlagEnum = 437;
  static const int CXCursor_ConvergentAttr = 438;
  static const int CXCursor_WarnUnusedAttr = 439;
  static const int CXCursor_WarnUnusedResultAttr = 440;
  static const int CXCursor_AlignedAttr = 441;
  static const int CXCursor_LastAttr = 441;
  static const int CXCursor_PreprocessingDirective = 500;
  static const int CXCursor_MacroDefinition = 501;
  static const int CXCursor_MacroExpansion = 502;
  static const int CXCursor_MacroInstantiation = 502;
  static const int CXCursor_InclusionDirective = 503;
  static const int CXCursor_FirstPreprocessing = 500;
  static const int CXCursor_LastPreprocessing = 503;

  /// A module import declaration.
  static const int CXCursor_ModuleImportDecl = 600;
  static const int CXCursor_TypeAliasTemplateDecl = 601;

  /// A static_assert or _Static_assert node
  static const int CXCursor_StaticAssert = 602;

  /// a friend declaration.
  static const int CXCursor_FriendDecl = 603;
  static const int CXCursor_FirstExtraDecl = 600;
  static const int CXCursor_LastExtraDecl = 603;

  /// A code completion overload candidate.
  static const int CXCursor_OverloadCandidate = 700;
}

/// A cursor representing some element in the abstract syntax tree for a
/// translation unit.
class CXCursor extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  @ffi.Int32()
  external int xdata;

  external ffi.Pointer<ffi.Void> _unique_data_item_0;
  external ffi.Pointer<ffi.Void> _unique_data_item_1;
  external ffi.Pointer<ffi.Void> _unique_data_item_2;

  /// Helper for array `data`.
  ArrayHelper_CXCursor_data_level0 get data =>
      ArrayHelper_CXCursor_data_level0(this, [3], 0, 0);
}

/// Helper for array `data` in struct `CXCursor`.
class ArrayHelper_CXCursor_data_level0 {
  final CXCursor _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXCursor_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Describe the linkage of the entity referred to by a cursor.
abstract class CXLinkageKind {
  /// This value indicates that no linkage information is available for a
  /// provided CXCursor.
  static const int CXLinkage_Invalid = 0;

  /// This is the linkage for variables, parameters, and so on that have
  /// automatic storage. This covers normal (non-extern) local variables.
  static const int CXLinkage_NoLinkage = 1;

  /// This is the linkage for static variables and static functions.
  static const int CXLinkage_Internal = 2;

  /// This is the linkage for entities with external linkage that live in C++
  /// anonymous namespaces.
  static const int CXLinkage_UniqueExternal = 3;

  /// This is the linkage for entities with true, external linkage.
  static const int CXLinkage_External = 4;
}

abstract class CXVisibilityKind {
  /// This value indicates that no visibility information is available for a
  /// provided CXCursor.
  static const int CXVisibility_Invalid = 0;

  /// Symbol not seen by the linker.
  static const int CXVisibility_Hidden = 1;

  /// Symbol seen by the linker but resolves to a symbol inside this object.
  static const int CXVisibility_Protected = 2;

  /// Symbol seen by the linker and acts like a normal symbol.
  static const int CXVisibility_Default = 3;
}

/// Describes the availability of a given entity on a particular platform, e.g.,
/// a particular class might only be available on Mac OS 10.7 or newer.
class CXPlatformAvailability extends ffi.Struct {
  /// A string that describes the platform for which this structure provides
  /// availability information.
  external CXString Platform;

  /// The version number in which this entity was introduced.
  external CXVersion Introduced;

  /// The version number in which this entity was deprecated (but is still
  /// available).
  external CXVersion Deprecated;

  /// The version number in which this entity was obsoleted, and therefore is no
  /// longer available.
  external CXVersion Obsoleted;

  /// Whether the entity is unconditionally unavailable on this platform.
  @ffi.Int32()
  external int Unavailable;

  /// An optional message to provide to a user of this API, e.g., to suggest
  /// replacement APIs.
  external CXString Message;
}

/// Describe the "language" of the entity referred to by a cursor.
abstract class CXLanguageKind {
  static const int CXLanguage_Invalid = 0;
  static const int CXLanguage_C = 1;
  static const int CXLanguage_ObjC = 2;
  static const int CXLanguage_CPlusPlus = 3;
}

/// Describe the "thread-local storage (TLS) kind" of the declaration referred
/// to by a cursor.
abstract class CXTLSKind {
  static const int CXTLS_None = 0;
  static const int CXTLS_Dynamic = 1;
  static const int CXTLS_Static = 2;
}

class CXCursorSetImpl extends ffi.Struct {}

/// Describes the kind of type
abstract class CXTypeKind {
  /// Represents an invalid type (e.g., where no type is available).
  static const int CXType_Invalid = 0;

  /// A type whose specific kind is not exposed via this interface.
  static const int CXType_Unexposed = 1;
  static const int CXType_Void = 2;
  static const int CXType_Bool = 3;
  static const int CXType_Char_U = 4;
  static const int CXType_UChar = 5;
  static const int CXType_Char16 = 6;
  static const int CXType_Char32 = 7;
  static const int CXType_UShort = 8;
  static const int CXType_UInt = 9;
  static const int CXType_ULong = 10;
  static const int CXType_ULongLong = 11;
  static const int CXType_UInt128 = 12;
  static const int CXType_Char_S = 13;
  static const int CXType_SChar = 14;
  static const int CXType_WChar = 15;
  static const int CXType_Short = 16;
  static const int CXType_Int = 17;
  static const int CXType_Long = 18;
  static const int CXType_LongLong = 19;
  static const int CXType_Int128 = 20;
  static const int CXType_Float = 21;
  static const int CXType_Double = 22;
  static const int CXType_LongDouble = 23;
  static const int CXType_NullPtr = 24;
  static const int CXType_Overload = 25;
  static const int CXType_Dependent = 26;
  static const int CXType_ObjCId = 27;
  static const int CXType_ObjCClass = 28;
  static const int CXType_ObjCSel = 29;
  static const int CXType_Float128 = 30;
  static const int CXType_Half = 31;
  static const int CXType_Float16 = 32;
  static const int CXType_ShortAccum = 33;
  static const int CXType_Accum = 34;
  static const int CXType_LongAccum = 35;
  static const int CXType_UShortAccum = 36;
  static const int CXType_UAccum = 37;
  static const int CXType_ULongAccum = 38;
  static const int CXType_FirstBuiltin = 2;
  static const int CXType_LastBuiltin = 38;
  static const int CXType_Complex = 100;
  static const int CXType_Pointer = 101;
  static const int CXType_BlockPointer = 102;
  static const int CXType_LValueReference = 103;
  static const int CXType_RValueReference = 104;
  static const int CXType_Record = 105;
  static const int CXType_Enum = 106;
  static const int CXType_Typedef = 107;
  static const int CXType_ObjCInterface = 108;
  static const int CXType_ObjCObjectPointer = 109;
  static const int CXType_FunctionNoProto = 110;
  static const int CXType_FunctionProto = 111;
  static const int CXType_ConstantArray = 112;
  static const int CXType_Vector = 113;
  static const int CXType_IncompleteArray = 114;
  static const int CXType_VariableArray = 115;
  static const int CXType_DependentSizedArray = 116;
  static const int CXType_MemberPointer = 117;
  static const int CXType_Auto = 118;

  /// Represents a type that was referred to using an elaborated type keyword.
  static const int CXType_Elaborated = 119;
  static const int CXType_Pipe = 120;
  static const int CXType_OCLImage1dRO = 121;
  static const int CXType_OCLImage1dArrayRO = 122;
  static const int CXType_OCLImage1dBufferRO = 123;
  static const int CXType_OCLImage2dRO = 124;
  static const int CXType_OCLImage2dArrayRO = 125;
  static const int CXType_OCLImage2dDepthRO = 126;
  static const int CXType_OCLImage2dArrayDepthRO = 127;
  static const int CXType_OCLImage2dMSAARO = 128;
  static const int CXType_OCLImage2dArrayMSAARO = 129;
  static const int CXType_OCLImage2dMSAADepthRO = 130;
  static const int CXType_OCLImage2dArrayMSAADepthRO = 131;
  static const int CXType_OCLImage3dRO = 132;
  static const int CXType_OCLImage1dWO = 133;
  static const int CXType_OCLImage1dArrayWO = 134;
  static const int CXType_OCLImage1dBufferWO = 135;
  static const int CXType_OCLImage2dWO = 136;
  static const int CXType_OCLImage2dArrayWO = 137;
  static const int CXType_OCLImage2dDepthWO = 138;
  static const int CXType_OCLImage2dArrayDepthWO = 139;
  static const int CXType_OCLImage2dMSAAWO = 140;
  static const int CXType_OCLImage2dArrayMSAAWO = 141;
  static const int CXType_OCLImage2dMSAADepthWO = 142;
  static const int CXType_OCLImage2dArrayMSAADepthWO = 143;
  static const int CXType_OCLImage3dWO = 144;
  static const int CXType_OCLImage1dRW = 145;
  static const int CXType_OCLImage1dArrayRW = 146;
  static const int CXType_OCLImage1dBufferRW = 147;
  static const int CXType_OCLImage2dRW = 148;
  static const int CXType_OCLImage2dArrayRW = 149;
  static const int CXType_OCLImage2dDepthRW = 150;
  static const int CXType_OCLImage2dArrayDepthRW = 151;
  static const int CXType_OCLImage2dMSAARW = 152;
  static const int CXType_OCLImage2dArrayMSAARW = 153;
  static const int CXType_OCLImage2dMSAADepthRW = 154;
  static const int CXType_OCLImage2dArrayMSAADepthRW = 155;
  static const int CXType_OCLImage3dRW = 156;
  static const int CXType_OCLSampler = 157;
  static const int CXType_OCLEvent = 158;
  static const int CXType_OCLQueue = 159;
  static const int CXType_OCLReserveID = 160;
  static const int CXType_ObjCObject = 161;
  static const int CXType_ObjCTypeParam = 162;
  static const int CXType_Attributed = 163;
  static const int CXType_OCLIntelSubgroupAVCMcePayload = 164;
  static const int CXType_OCLIntelSubgroupAVCImePayload = 165;
  static const int CXType_OCLIntelSubgroupAVCRefPayload = 166;
  static const int CXType_OCLIntelSubgroupAVCSicPayload = 167;
  static const int CXType_OCLIntelSubgroupAVCMceResult = 168;
  static const int CXType_OCLIntelSubgroupAVCImeResult = 169;
  static const int CXType_OCLIntelSubgroupAVCRefResult = 170;
  static const int CXType_OCLIntelSubgroupAVCSicResult = 171;
  static const int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172;
  static const int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173;
  static const int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174;
  static const int CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175;
  static const int CXType_ExtVector = 176;
}

/// Describes the calling convention of a function type
abstract class CXCallingConv {
  static const int CXCallingConv_Default = 0;
  static const int CXCallingConv_C = 1;
  static const int CXCallingConv_X86StdCall = 2;
  static const int CXCallingConv_X86FastCall = 3;
  static const int CXCallingConv_X86ThisCall = 4;
  static const int CXCallingConv_X86Pascal = 5;
  static const int CXCallingConv_AAPCS = 6;
  static const int CXCallingConv_AAPCS_VFP = 7;
  static const int CXCallingConv_X86RegCall = 8;
  static const int CXCallingConv_IntelOclBicc = 9;
  static const int CXCallingConv_Win64 = 10;
  static const int CXCallingConv_X86_64Win64 = 10;
  static const int CXCallingConv_X86_64SysV = 11;
  static const int CXCallingConv_X86VectorCall = 12;
  static const int CXCallingConv_Swift = 13;
  static const int CXCallingConv_PreserveMost = 14;
  static const int CXCallingConv_PreserveAll = 15;
  static const int CXCallingConv_AArch64VectorCall = 16;
  static const int CXCallingConv_Invalid = 100;
  static const int CXCallingConv_Unexposed = 200;
}

/// The type of an element in the abstract syntax tree.
class CXType extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  external ffi.Pointer<ffi.Void> _unique_data_item_0;
  external ffi.Pointer<ffi.Void> _unique_data_item_1;

  /// Helper for array `data`.
  ArrayHelper_CXType_data_level0 get data =>
      ArrayHelper_CXType_data_level0(this, [2], 0, 0);
}

/// Helper for array `data` in struct `CXType`.
class ArrayHelper_CXType_data_level0 {
  final CXType _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXType_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Describes the kind of a template argument.
abstract class CXTemplateArgumentKind {
  static const int CXTemplateArgumentKind_Null = 0;
  static const int CXTemplateArgumentKind_Type = 1;
  static const int CXTemplateArgumentKind_Declaration = 2;
  static const int CXTemplateArgumentKind_NullPtr = 3;
  static const int CXTemplateArgumentKind_Integral = 4;
  static const int CXTemplateArgumentKind_Template = 5;
  static const int CXTemplateArgumentKind_TemplateExpansion = 6;
  static const int CXTemplateArgumentKind_Expression = 7;
  static const int CXTemplateArgumentKind_Pack = 8;
  static const int CXTemplateArgumentKind_Invalid = 9;
}

abstract class CXTypeNullabilityKind {
  /// Values of this type can never be null.
  static const int CXTypeNullability_NonNull = 0;

  /// Values of this type can be null.
  static const int CXTypeNullability_Nullable = 1;

  /// Whether values of this type can be null is (explicitly) unspecified. This
  /// captures a (fairly rare) case where we can't conclude anything about the
  /// nullability of the type even though it has been considered.
  static const int CXTypeNullability_Unspecified = 2;

  /// Nullability is not applicable to this type.
  static const int CXTypeNullability_Invalid = 3;
}

/// List the possible error codes for clang_Type_getSizeOf,
/// clang_Type_getAlignOf, clang_Type_getOffsetOf and clang_Cursor_getOffsetOf.
abstract class CXTypeLayoutError {
  /// Type is of kind CXType_Invalid.
  static const int CXTypeLayoutError_Invalid = -1;

  /// The type is an incomplete Type.
  static const int CXTypeLayoutError_Incomplete = -2;

  /// The type is a dependent Type.
  static const int CXTypeLayoutError_Dependent = -3;

  /// The type is not a constant size type.
  static const int CXTypeLayoutError_NotConstantSize = -4;

  /// The Field name is not valid for this record.
  static const int CXTypeLayoutError_InvalidFieldName = -5;

  /// The type is undeduced.
  static const int CXTypeLayoutError_Undeduced = -6;
}

abstract class CXRefQualifierKind {
  /// No ref-qualifier was provided.
  static const int CXRefQualifier_None = 0;

  /// An lvalue ref-qualifier was provided ( &).
  static const int CXRefQualifier_LValue = 1;

  /// An rvalue ref-qualifier was provided ( &&).
  static const int CXRefQualifier_RValue = 2;
}

/// Represents the C++ access control level to a base class for a cursor with
/// kind CX_CXXBaseSpecifier.
abstract class CX_CXXAccessSpecifier {
  static const int CX_CXXInvalidAccessSpecifier = 0;
  static const int CX_CXXPublic = 1;
  static const int CX_CXXProtected = 2;
  static const int CX_CXXPrivate = 3;
}

/// Represents the storage classes as declared in the source. CX_SC_Invalid was
/// added for the case that the passed cursor in not a declaration.
abstract class CX_StorageClass {
  static const int CX_SC_Invalid = 0;
  static const int CX_SC_None = 1;
  static const int CX_SC_Extern = 2;
  static const int CX_SC_Static = 3;
  static const int CX_SC_PrivateExtern = 4;
  static const int CX_SC_OpenCLWorkGroupLocal = 5;
  static const int CX_SC_Auto = 6;
  static const int CX_SC_Register = 7;
}

/// Describes how the traversal of the children of a particular cursor should
/// proceed after visiting a particular child cursor.
abstract class CXChildVisitResult {
  /// Terminates the cursor traversal.
  static const int CXChildVisit_Break = 0;

  /// Continues the cursor traversal with the next sibling of the cursor just
  /// visited, without visiting its children.
  static const int CXChildVisit_Continue = 1;

  /// Recursively traverse the children of this cursor, using the same visitor
  /// and client data.
  static const int CXChildVisit_Recurse = 2;
}

/// Properties for the printing policy.
abstract class CXPrintingPolicyProperty {
  static const int CXPrintingPolicy_Indentation = 0;
  static const int CXPrintingPolicy_SuppressSpecifiers = 1;
  static const int CXPrintingPolicy_SuppressTagKeyword = 2;
  static const int CXPrintingPolicy_IncludeTagDefinition = 3;
  static const int CXPrintingPolicy_SuppressScope = 4;
  static const int CXPrintingPolicy_SuppressUnwrittenScope = 5;
  static const int CXPrintingPolicy_SuppressInitializers = 6;
  static const int CXPrintingPolicy_ConstantArraySizeAsWritten = 7;
  static const int CXPrintingPolicy_AnonymousTagLocations = 8;
  static const int CXPrintingPolicy_SuppressStrongLifetime = 9;
  static const int CXPrintingPolicy_SuppressLifetimeQualifiers = 10;
  static const int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = 11;
  static const int CXPrintingPolicy_Bool = 12;
  static const int CXPrintingPolicy_Restrict = 13;
  static const int CXPrintingPolicy_Alignof = 14;
  static const int CXPrintingPolicy_UnderscoreAlignof = 15;
  static const int CXPrintingPolicy_UseVoidForZeroParams = 16;
  static const int CXPrintingPolicy_TerseOutput = 17;
  static const int CXPrintingPolicy_PolishForDeclaration = 18;
  static const int CXPrintingPolicy_Half = 19;
  static const int CXPrintingPolicy_MSWChar = 20;
  static const int CXPrintingPolicy_IncludeNewlines = 21;
  static const int CXPrintingPolicy_MSVCFormatting = 22;
  static const int CXPrintingPolicy_ConstantsAsWritten = 23;
  static const int CXPrintingPolicy_SuppressImplicitBase = 24;
  static const int CXPrintingPolicy_FullyQualifiedName = 25;
  static const int CXPrintingPolicy_LastProperty = 25;
}

/// Property attributes for a CXCursor_ObjCPropertyDecl.
abstract class CXObjCPropertyAttrKind {
  static const int CXObjCPropertyAttr_noattr = 0;
  static const int CXObjCPropertyAttr_readonly = 1;
  static const int CXObjCPropertyAttr_getter = 2;
  static const int CXObjCPropertyAttr_assign = 4;
  static const int CXObjCPropertyAttr_readwrite = 8;
  static const int CXObjCPropertyAttr_retain = 16;
  static const int CXObjCPropertyAttr_copy = 32;
  static const int CXObjCPropertyAttr_nonatomic = 64;
  static const int CXObjCPropertyAttr_setter = 128;
  static const int CXObjCPropertyAttr_atomic = 256;
  static const int CXObjCPropertyAttr_weak = 512;
  static const int CXObjCPropertyAttr_strong = 1024;
  static const int CXObjCPropertyAttr_unsafe_unretained = 2048;
  static const int CXObjCPropertyAttr_class = 4096;
}

/// 'Qualifiers' written next to the return and parameter types in Objective-C
/// method declarations.
abstract class CXObjCDeclQualifierKind {
  static const int CXObjCDeclQualifier_None = 0;
  static const int CXObjCDeclQualifier_In = 1;
  static const int CXObjCDeclQualifier_Inout = 2;
  static const int CXObjCDeclQualifier_Out = 4;
  static const int CXObjCDeclQualifier_Bycopy = 8;
  static const int CXObjCDeclQualifier_Byref = 16;
  static const int CXObjCDeclQualifier_Oneway = 32;
}

abstract class CXNameRefFlags {
  /// Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the range.
  static const int CXNameRange_WantQualifier = 1;

  /// Include the explicit template arguments, e.g. <int> in x.f<int>, in the
  /// range.
  static const int CXNameRange_WantTemplateArgs = 2;

  /// If the name is non-contiguous, return the full spanning range.
  static const int CXNameRange_WantSinglePiece = 4;
}

/// Describes a kind of token.
abstract class CXTokenKind {
  /// A token that contains some kind of punctuation.
  static const int CXToken_Punctuation = 0;

  /// A language keyword.
  static const int CXToken_Keyword = 1;

  /// An identifier (that is not a keyword).
  static const int CXToken_Identifier = 2;

  /// A numeric, string, or character literal.
  static const int CXToken_Literal = 3;

  /// A comment.
  static const int CXToken_Comment = 4;
}

/// Describes a single preprocessing token.
class CXToken extends ffi.Struct {
  @ffi.Uint32()
  external int _unique_int_data_item_0;
  @ffi.Uint32()
  external int _unique_int_data_item_1;
  @ffi.Uint32()
  external int _unique_int_data_item_2;
  @ffi.Uint32()
  external int _unique_int_data_item_3;

  /// Helper for array `int_data`.
  ArrayHelper_CXToken_int_data_level0 get int_data =>
      ArrayHelper_CXToken_int_data_level0(this, [4], 0, 0);
  external ffi.Pointer<ffi.Void> ptr_data;
}

/// Helper for array `int_data` in struct `CXToken`.
class ArrayHelper_CXToken_int_data_level0 {
  final CXToken _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXToken_int_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_int_data_item_0;
      case 1:
        return _struct._unique_int_data_item_1;
      case 2:
        return _struct._unique_int_data_item_2;
      case 3:
        return _struct._unique_int_data_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_int_data_item_0 = value;
        break;
      case 1:
        _struct._unique_int_data_item_1 = value;
        break;
      case 2:
        _struct._unique_int_data_item_2 = value;
        break;
      case 3:
        _struct._unique_int_data_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// A single result of code completion.
class CXCompletionResult extends ffi.Struct {
  /// The kind of entity that this completion refers to.
  @ffi.Int32()
  external int CursorKind;

  /// The code-completion string that describes how to insert this
  /// code-completion result into the editing buffer.
  external ffi.Pointer<ffi.Void> CompletionString;
}

/// Describes a single piece of text within a code-completion string.
abstract class CXCompletionChunkKind {
  /// A code-completion string that describes "optional" text that could be a
  /// part of the template (but is not required).
  static const int CXCompletionChunk_Optional = 0;

  /// Text that a user would be expected to type to get this code-completion
  /// result.
  static const int CXCompletionChunk_TypedText = 1;

  /// Text that should be inserted as part of a code-completion result.
  static const int CXCompletionChunk_Text = 2;

  /// Placeholder text that should be replaced by the user.
  static const int CXCompletionChunk_Placeholder = 3;

  /// Informative text that should be displayed but never inserted as part of
  /// the template.
  static const int CXCompletionChunk_Informative = 4;

  /// Text that describes the current parameter when code-completion is
  /// referring to function call, message send, or template specialization.
  static const int CXCompletionChunk_CurrentParameter = 5;

  /// A left parenthesis ('('), used to initiate a function call or signal the
  /// beginning of a function parameter list.
  static const int CXCompletionChunk_LeftParen = 6;

  /// A right parenthesis (')'), used to finish a function call or signal the
  /// end of a function parameter list.
  static const int CXCompletionChunk_RightParen = 7;

  /// A left bracket ('[').
  static const int CXCompletionChunk_LeftBracket = 8;

  /// A right bracket (']').
  static const int CXCompletionChunk_RightBracket = 9;

  /// A left brace ('{').
  static const int CXCompletionChunk_LeftBrace = 10;

  /// A right brace ('}').
  static const int CXCompletionChunk_RightBrace = 11;

  /// A left angle bracket ('<').
  static const int CXCompletionChunk_LeftAngle = 12;

  /// A right angle bracket ('>').
  static const int CXCompletionChunk_RightAngle = 13;

  /// A comma separator (',').
  static const int CXCompletionChunk_Comma = 14;

  /// Text that specifies the result type of a given result.
  static const int CXCompletionChunk_ResultType = 15;

  /// A colon (':').
  static const int CXCompletionChunk_Colon = 16;

  /// A semicolon (';').
  static const int CXCompletionChunk_SemiColon = 17;

  /// An '=' sign.
  static const int CXCompletionChunk_Equal = 18;

  /// Horizontal space (' ').
  static const int CXCompletionChunk_HorizontalSpace = 19;

  /// Vertical space ('\n'), after which it is generally a good idea to perform
  /// indentation.
  static const int CXCompletionChunk_VerticalSpace = 20;
}

/// Contains the results of code-completion.
class CXCodeCompleteResults extends ffi.Struct {
  /// The code-completion results.
  external ffi.Pointer<CXCompletionResult> Results;

  /// The number of code-completion results stored in the Results array.
  @ffi.Uint32()
  external int NumResults;
}

/// Flags that can be passed to clang_codeCompleteAt() to modify its behavior.
abstract class CXCodeComplete_Flags {
  /// Whether to include macros within the set of code completions returned.
  static const int CXCodeComplete_IncludeMacros = 1;

  /// Whether to include code patterns for language constructs within the set of
  /// code completions, e.g., for loops.
  static const int CXCodeComplete_IncludeCodePatterns = 2;

  /// Whether to include brief documentation within the set of code completions
  /// returned.
  static const int CXCodeComplete_IncludeBriefComments = 4;

  /// Whether to speed up completion by omitting top- or namespace-level
  /// entities defined in the preamble. There's no guarantee any particular
  /// entity is omitted. This may be useful if the headers are indexed
  /// externally.
  static const int CXCodeComplete_SkipPreamble = 8;

  /// Whether to include completions with small fix-its, e.g. change '.' to '->'
  /// on member access, etc.
  static const int CXCodeComplete_IncludeCompletionsWithFixIts = 16;
}

/// Bits that represent the context under which completion is occurring.
abstract class CXCompletionContext {
  /// The context for completions is unexposed, as only Clang results should be
  /// included. (This is equivalent to having no context bits set.)
  static const int CXCompletionContext_Unexposed = 0;

  /// Completions for any possible type should be included in the results.
  static const int CXCompletionContext_AnyType = 1;

  /// Completions for any possible value (variables, function calls, etc.)
  /// should be included in the results.
  static const int CXCompletionContext_AnyValue = 2;

  /// Completions for values that resolve to an Objective-C object should be
  /// included in the results.
  static const int CXCompletionContext_ObjCObjectValue = 4;

  /// Completions for values that resolve to an Objective-C selector should be
  /// included in the results.
  static const int CXCompletionContext_ObjCSelectorValue = 8;

  /// Completions for values that resolve to a C++ class type should be included
  /// in the results.
  static const int CXCompletionContext_CXXClassTypeValue = 16;

  /// Completions for fields of the member being accessed using the dot operator
  /// should be included in the results.
  static const int CXCompletionContext_DotMemberAccess = 32;

  /// Completions for fields of the member being accessed using the arrow
  /// operator should be included in the results.
  static const int CXCompletionContext_ArrowMemberAccess = 64;

  /// Completions for properties of the Objective-C object being accessed using
  /// the dot operator should be included in the results.
  static const int CXCompletionContext_ObjCPropertyAccess = 128;

  /// Completions for enum tags should be included in the results.
  static const int CXCompletionContext_EnumTag = 256;

  /// Completions for union tags should be included in the results.
  static const int CXCompletionContext_UnionTag = 512;

  /// Completions for struct tags should be included in the results.
  static const int CXCompletionContext_StructTag = 1024;

  /// Completions for C++ class names should be included in the results.
  static const int CXCompletionContext_ClassTag = 2048;

  /// Completions for C++ namespaces and namespace aliases should be included in
  /// the results.
  static const int CXCompletionContext_Namespace = 4096;

  /// Completions for C++ nested name specifiers should be included in the
  /// results.
  static const int CXCompletionContext_NestedNameSpecifier = 8192;

  /// Completions for Objective-C interfaces (classes) should be included in the
  /// results.
  static const int CXCompletionContext_ObjCInterface = 16384;

  /// Completions for Objective-C protocols should be included in the results.
  static const int CXCompletionContext_ObjCProtocol = 32768;

  /// Completions for Objective-C categories should be included in the results.
  static const int CXCompletionContext_ObjCCategory = 65536;

  /// Completions for Objective-C instance messages should be included in the
  /// results.
  static const int CXCompletionContext_ObjCInstanceMessage = 131072;

  /// Completions for Objective-C class messages should be included in the
  /// results.
  static const int CXCompletionContext_ObjCClassMessage = 262144;

  /// Completions for Objective-C selector names should be included in the
  /// results.
  static const int CXCompletionContext_ObjCSelectorName = 524288;

  /// Completions for preprocessor macro names should be included in the
  /// results.
  static const int CXCompletionContext_MacroName = 1048576;

  /// Natural language completions should be included in the results.
  static const int CXCompletionContext_NaturalLanguage = 2097152;

  /// #include file completions should be included in the results.
  static const int CXCompletionContext_IncludedFile = 4194304;

  /// The current context is unknown, so set all contexts.
  static const int CXCompletionContext_Unknown = 8388607;
}

abstract class CXEvalResultKind {
  static const int CXEval_Int = 1;
  static const int CXEval_Float = 2;
  static const int CXEval_ObjCStrLiteral = 3;
  static const int CXEval_StrLiteral = 4;
  static const int CXEval_CFStr = 5;
  static const int CXEval_Other = 6;
  static const int CXEval_UnExposed = 0;
}

/// @{
abstract class CXVisitorResult {
  static const int CXVisit_Break = 0;
  static const int CXVisit_Continue = 1;
}

class CXCursorAndRangeVisitor extends ffi.Struct {
  external ffi.Pointer<ffi.Void> context;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> visit;
}

abstract class CXResult {
  /// Function returned successfully.
  static const int CXResult_Success = 0;

  /// One of the parameters was invalid for the function.
  static const int CXResult_Invalid = 1;

  /// The function was terminated by a callback (e.g. it returned CXVisit_Break)
  static const int CXResult_VisitBreak = 2;
}

/// Source location passed to index callbacks.
class CXIdxLoc extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_0;
  external ffi.Pointer<ffi.Void> _unique_ptr_data_item_1;

  /// Helper for array `ptr_data`.
  ArrayHelper_CXIdxLoc_ptr_data_level0 get ptr_data =>
      ArrayHelper_CXIdxLoc_ptr_data_level0(this, [2], 0, 0);
  @ffi.Uint32()
  external int int_data;
}

/// Helper for array `ptr_data` in struct `CXIdxLoc`.
class ArrayHelper_CXIdxLoc_ptr_data_level0 {
  final CXIdxLoc _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_CXIdxLoc_ptr_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_ptr_data_item_0;
      case 1:
        return _struct._unique_ptr_data_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_ptr_data_item_0 = value;
        break;
      case 1:
        _struct._unique_ptr_data_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Data for ppIncludedFile callback.
class CXIdxIncludedFileInfo extends ffi.Struct {
  /// Location of '#' in the #include/#import directive.
  external CXIdxLoc hashLoc;

  /// Filename as written in the #include/#import directive.
  external ffi.Pointer<ffi.Int8> filename;

  /// The actual file that the #include/#import directive resolved to.
  external ffi.Pointer<ffi.Void> file;

  @ffi.Int32()
  external int isImport;

  @ffi.Int32()
  external int isAngled;

  /// Non-zero if the directive was automatically turned into a module import.
  @ffi.Int32()
  external int isModuleImport;
}

/// Data for IndexerCallbacks#importedASTFile.
class CXIdxImportedASTFileInfo extends ffi.Struct {
  /// Top level AST file containing the imported PCH, module or submodule.
  external ffi.Pointer<ffi.Void> file;

  /// The imported module or NULL if the AST file is a PCH.
  external ffi.Pointer<ffi.Void> module;

  /// Location where the file is imported. Applicable only for modules.
  external CXIdxLoc loc;

  /// Non-zero if an inclusion directive was automatically turned into a module
  /// import. Applicable only for modules.
  @ffi.Int32()
  external int isImplicit;
}

abstract class CXIdxEntityKind {
  static const int CXIdxEntity_Unexposed = 0;
  static const int CXIdxEntity_Typedef = 1;
  static const int CXIdxEntity_Function = 2;
  static const int CXIdxEntity_Variable = 3;
  static const int CXIdxEntity_Field = 4;
  static const int CXIdxEntity_EnumConstant = 5;
  static const int CXIdxEntity_ObjCClass = 6;
  static const int CXIdxEntity_ObjCProtocol = 7;
  static const int CXIdxEntity_ObjCCategory = 8;
  static const int CXIdxEntity_ObjCInstanceMethod = 9;
  static const int CXIdxEntity_ObjCClassMethod = 10;
  static const int CXIdxEntity_ObjCProperty = 11;
  static const int CXIdxEntity_ObjCIvar = 12;
  static const int CXIdxEntity_Enum = 13;
  static const int CXIdxEntity_Struct = 14;
  static const int CXIdxEntity_Union = 15;
  static const int CXIdxEntity_CXXClass = 16;
  static const int CXIdxEntity_CXXNamespace = 17;
  static const int CXIdxEntity_CXXNamespaceAlias = 18;
  static const int CXIdxEntity_CXXStaticVariable = 19;
  static const int CXIdxEntity_CXXStaticMethod = 20;
  static const int CXIdxEntity_CXXInstanceMethod = 21;
  static const int CXIdxEntity_CXXConstructor = 22;
  static const int CXIdxEntity_CXXDestructor = 23;
  static const int CXIdxEntity_CXXConversionFunction = 24;
  static const int CXIdxEntity_CXXTypeAlias = 25;
  static const int CXIdxEntity_CXXInterface = 26;
}

abstract class CXIdxEntityLanguage {
  static const int CXIdxEntityLang_None = 0;
  static const int CXIdxEntityLang_C = 1;
  static const int CXIdxEntityLang_ObjC = 2;
  static const int CXIdxEntityLang_CXX = 3;
  static const int CXIdxEntityLang_Swift = 4;
}

/// Extra C++ template information for an entity. This can apply to:
/// CXIdxEntity_Function CXIdxEntity_CXXClass CXIdxEntity_CXXStaticMethod
/// CXIdxEntity_CXXInstanceMethod CXIdxEntity_CXXConstructor
/// CXIdxEntity_CXXConversionFunction CXIdxEntity_CXXTypeAlias
abstract class CXIdxEntityCXXTemplateKind {
  static const int CXIdxEntity_NonTemplate = 0;
  static const int CXIdxEntity_Template = 1;
  static const int CXIdxEntity_TemplatePartialSpecialization = 2;
  static const int CXIdxEntity_TemplateSpecialization = 3;
}

abstract class CXIdxAttrKind {
  static const int CXIdxAttr_Unexposed = 0;
  static const int CXIdxAttr_IBAction = 1;
  static const int CXIdxAttr_IBOutlet = 2;
  static const int CXIdxAttr_IBOutletCollection = 3;
}

class CXIdxAttrInfo extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  external CXCursor cursor;

  external CXIdxLoc loc;
}

class CXIdxEntityInfo extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  @ffi.Int32()
  external int templateKind;

  @ffi.Int32()
  external int lang;

  external ffi.Pointer<ffi.Int8> name;

  external ffi.Pointer<ffi.Int8> USR;

  external CXCursor cursor;

  external ffi.Pointer<ffi.Pointer<CXIdxAttrInfo>> attributes;

  @ffi.Uint32()
  external int numAttributes;
}

class CXIdxContainerInfo extends ffi.Struct {
  external CXCursor cursor;
}

class CXIdxIBOutletCollectionAttrInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxAttrInfo> attrInfo;

  external ffi.Pointer<CXIdxEntityInfo> objcClass;

  external CXCursor classCursor;

  external CXIdxLoc classLoc;
}

abstract class CXIdxDeclInfoFlags {
  static const int CXIdxDeclFlag_Skipped = 1;
}

class CXIdxDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxEntityInfo> entityInfo;

  external CXCursor cursor;

  external CXIdxLoc loc;

  external ffi.Pointer<CXIdxContainerInfo> semanticContainer;

  /// Generally same as #semanticContainer but can be different in cases like
  /// out-of-line C++ member functions.
  external ffi.Pointer<CXIdxContainerInfo> lexicalContainer;

  @ffi.Int32()
  external int isRedeclaration;

  @ffi.Int32()
  external int isDefinition;

  @ffi.Int32()
  external int isContainer;

  external ffi.Pointer<CXIdxContainerInfo> declAsContainer;

  /// Whether the declaration exists in code or was created implicitly by the
  /// compiler, e.g. implicit Objective-C methods for properties.
  @ffi.Int32()
  external int isImplicit;

  external ffi.Pointer<ffi.Pointer<CXIdxAttrInfo>> attributes;

  @ffi.Uint32()
  external int numAttributes;

  @ffi.Uint32()
  external int flags;
}

abstract class CXIdxObjCContainerKind {
  static const int CXIdxObjCContainer_ForwardRef = 0;
  static const int CXIdxObjCContainer_Interface = 1;
  static const int CXIdxObjCContainer_Implementation = 2;
}

class CXIdxObjCContainerDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxDeclInfo> declInfo;

  @ffi.Int32()
  external int kind;
}

class CXIdxBaseClassInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxEntityInfo> base;

  external CXCursor cursor;

  external CXIdxLoc loc;
}

class CXIdxObjCProtocolRefInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxEntityInfo> protocol;

  external CXCursor cursor;

  external CXIdxLoc loc;
}

class CXIdxObjCProtocolRefListInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<CXIdxObjCProtocolRefInfo>> protocols;

  @ffi.Uint32()
  external int numProtocols;
}

class CXIdxObjCInterfaceDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxObjCContainerDeclInfo> containerInfo;

  external ffi.Pointer<CXIdxBaseClassInfo> superInfo;

  external ffi.Pointer<CXIdxObjCProtocolRefListInfo> protocols;
}

class CXIdxObjCCategoryDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxObjCContainerDeclInfo> containerInfo;

  external ffi.Pointer<CXIdxEntityInfo> objcClass;

  external CXCursor classCursor;

  external CXIdxLoc classLoc;

  external ffi.Pointer<CXIdxObjCProtocolRefListInfo> protocols;
}

class CXIdxObjCPropertyDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxDeclInfo> declInfo;

  external ffi.Pointer<CXIdxEntityInfo> getter;

  external ffi.Pointer<CXIdxEntityInfo> setter;
}

class CXIdxCXXClassDeclInfo extends ffi.Struct {
  external ffi.Pointer<CXIdxDeclInfo> declInfo;

  external ffi.Pointer<ffi.Pointer<CXIdxBaseClassInfo>> bases;

  @ffi.Uint32()
  external int numBases;
}

/// Data for IndexerCallbacks#indexEntityReference.
abstract class CXIdxEntityRefKind {
  /// The entity is referenced directly in user's code.
  static const int CXIdxEntityRef_Direct = 1;

  /// An implicit reference, e.g. a reference of an Objective-C method via the
  /// dot syntax.
  static const int CXIdxEntityRef_Implicit = 2;
}

/// Roles that are attributed to symbol occurrences.
abstract class CXSymbolRole {
  static const int CXSymbolRole_None = 0;
  static const int CXSymbolRole_Declaration = 1;
  static const int CXSymbolRole_Definition = 2;
  static const int CXSymbolRole_Reference = 4;
  static const int CXSymbolRole_Read = 8;
  static const int CXSymbolRole_Write = 16;
  static const int CXSymbolRole_Call = 32;
  static const int CXSymbolRole_Dynamic = 64;
  static const int CXSymbolRole_AddressOf = 128;
  static const int CXSymbolRole_Implicit = 256;
}

/// Data for IndexerCallbacks#indexEntityReference.
class CXIdxEntityRefInfo extends ffi.Struct {
  @ffi.Int32()
  external int kind;

  /// Reference cursor.
  external CXCursor cursor;

  external CXIdxLoc loc;

  /// The entity that gets referenced.
  external ffi.Pointer<CXIdxEntityInfo> referencedEntity;

  /// Immediate "parent" of the reference. For example:
  external ffi.Pointer<CXIdxEntityInfo> parentEntity;

  /// Lexical container context of the reference.
  external ffi.Pointer<CXIdxContainerInfo> container;

  /// Sets of symbol roles of the reference.
  @ffi.Int32()
  external int role;
}

/// A group of callbacks used by #clang_indexSourceFile and
/// #clang_indexTranslationUnit.
class IndexerCallbacks extends ffi.Struct {
  /// Called periodically to check whether indexing should be aborted. Should
  /// return 0 to continue, and non-zero to abort.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> abortQuery;

  /// Called at the end of indexing; passes the complete diagnostic set.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> diagnostic;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_5>> enteredMainFile;

  /// Called when a file gets #included/#imported.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_6>> ppIncludedFile;

  /// Called when a AST file (PCH or module) gets imported.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_7>> importedASTFile;

  /// Called at the beginning of indexing a translation unit.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_8>> startedTranslationUnit;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_9>> indexDeclaration;

  /// Called to index a reference of an entity.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_10>> indexEntityReference;
}

abstract class CXIndexOptFlags {
  /// Used to indicate that no special indexing options are needed.
  static const int CXIndexOpt_None = 0;

  /// Used to indicate that IndexerCallbacks#indexEntityReference should be
  /// invoked for only one reference of an entity per source file that does not
  /// also include a declaration/definition of the entity.
  static const int CXIndexOpt_SuppressRedundantRefs = 1;

  /// Function-local symbols should be indexed. If this is not set
  /// function-local symbols will be ignored.
  static const int CXIndexOpt_IndexFunctionLocalSymbols = 2;

  /// Implicit function/class template instantiations should be indexed. If this
  /// is not set, implicit instantiations will be ignored.
  static const int CXIndexOpt_IndexImplicitTemplateInstantiations = 4;

  /// Suppress all compiler warnings when parsing for indexing.
  static const int CXIndexOpt_SuppressWarnings = 8;

  /// Skip a function/method body that was already parsed during an indexing
  /// session associated with a CXIndexAction object. Bodies in system headers
  /// are always skipped.
  static const int CXIndexOpt_SkipParsedBodiesInSession = 16;
}

const int CINDEX_VERSION_MAJOR = 0;

const int CINDEX_VERSION_MINOR = 59;

const int CINDEX_VERSION = 59;

const String CINDEX_VERSION_STRING = '0.59';

typedef _c_clang_getCString = ffi.Pointer<ffi.Int8> Function(
  CXString string,
);

typedef _dart_clang_getCString = ffi.Pointer<ffi.Int8> Function(
  CXString string,
);

typedef _c_clang_disposeString = ffi.Void Function(
  CXString string,
);

typedef _dart_clang_disposeString = void Function(
  CXString string,
);

typedef _c_clang_disposeStringSet = ffi.Void Function(
  ffi.Pointer<CXStringSet> set_1,
);

typedef _dart_clang_disposeStringSet = void Function(
  ffi.Pointer<CXStringSet> set_1,
);

typedef _c_clang_getBuildSessionTimestamp = ffi.Uint64 Function();

typedef _dart_clang_getBuildSessionTimestamp = int Function();

typedef _c_clang_VirtualFileOverlay_create
    = ffi.Pointer<CXVirtualFileOverlayImpl> Function(
  ffi.Uint32 options,
);

typedef _dart_clang_VirtualFileOverlay_create
    = ffi.Pointer<CXVirtualFileOverlayImpl> Function(
  int options,
);

typedef _c_clang_VirtualFileOverlay_addFileMapping = ffi.Int32 Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  ffi.Pointer<ffi.Int8> virtualPath,
  ffi.Pointer<ffi.Int8> realPath,
);

typedef _dart_clang_VirtualFileOverlay_addFileMapping = int Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  ffi.Pointer<ffi.Int8> virtualPath,
  ffi.Pointer<ffi.Int8> realPath,
);

typedef _c_clang_VirtualFileOverlay_setCaseSensitivity = ffi.Int32 Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  ffi.Int32 caseSensitive,
);

typedef _dart_clang_VirtualFileOverlay_setCaseSensitivity = int Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  int caseSensitive,
);

typedef _c_clang_VirtualFileOverlay_writeToBuffer = ffi.Int32 Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  ffi.Uint32 options,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
  ffi.Pointer<ffi.Uint32> out_buffer_size,
);

typedef _dart_clang_VirtualFileOverlay_writeToBuffer = int Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
  int options,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
  ffi.Pointer<ffi.Uint32> out_buffer_size,
);

typedef _c_clang_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> buffer,
);

typedef _dart_clang_free = void Function(
  ffi.Pointer<ffi.Void> buffer,
);

typedef _c_clang_VirtualFileOverlay_dispose = ffi.Void Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
);

typedef _dart_clang_VirtualFileOverlay_dispose = void Function(
  ffi.Pointer<CXVirtualFileOverlayImpl> arg0,
);

typedef _c_clang_ModuleMapDescriptor_create
    = ffi.Pointer<CXModuleMapDescriptorImpl> Function(
  ffi.Uint32 options,
);

typedef _dart_clang_ModuleMapDescriptor_create
    = ffi.Pointer<CXModuleMapDescriptorImpl> Function(
  int options,
);

typedef _c_clang_ModuleMapDescriptor_setFrameworkModuleName = ffi.Int32
    Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_clang_ModuleMapDescriptor_setFrameworkModuleName = int Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_clang_ModuleMapDescriptor_setUmbrellaHeader = ffi.Int32 Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_clang_ModuleMapDescriptor_setUmbrellaHeader = int Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_clang_ModuleMapDescriptor_writeToBuffer = ffi.Int32 Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  ffi.Uint32 options,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
  ffi.Pointer<ffi.Uint32> out_buffer_size,
);

typedef _dart_clang_ModuleMapDescriptor_writeToBuffer = int Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
  int options,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out_buffer_ptr,
  ffi.Pointer<ffi.Uint32> out_buffer_size,
);

typedef _c_clang_ModuleMapDescriptor_dispose = ffi.Void Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
);

typedef _dart_clang_ModuleMapDescriptor_dispose = void Function(
  ffi.Pointer<CXModuleMapDescriptorImpl> arg0,
);

typedef _c_clang_createIndex = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 excludeDeclarationsFromPCH,
  ffi.Int32 displayDiagnostics,
);

typedef _dart_clang_createIndex = ffi.Pointer<ffi.Void> Function(
  int excludeDeclarationsFromPCH,
  int displayDiagnostics,
);

typedef _c_clang_disposeIndex = ffi.Void Function(
  ffi.Pointer<ffi.Void> index,
);

typedef _dart_clang_disposeIndex = void Function(
  ffi.Pointer<ffi.Void> index,
);

typedef _c_clang_CXIndex_setGlobalOptions = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Uint32 options,
);

typedef _dart_clang_CXIndex_setGlobalOptions = void Function(
  ffi.Pointer<ffi.Void> arg0,
  int options,
);

typedef _c_clang_CXIndex_getGlobalOptions = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_CXIndex_getGlobalOptions = int Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_CXIndex_setInvocationEmissionPathOption = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Int8> Path,
);

typedef _dart_clang_CXIndex_setInvocationEmissionPathOption = void Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Int8> Path,
);

typedef _c_clang_getFileName = CXString Function(
  ffi.Pointer<ffi.Void> SFile,
);

typedef _dart_clang_getFileName = CXString Function(
  ffi.Pointer<ffi.Void> SFile,
);

typedef _c_clang_getFileTime = ffi.Int64 Function(
  ffi.Pointer<ffi.Void> SFile,
);

typedef _dart_clang_getFileTime = int Function(
  ffi.Pointer<ffi.Void> SFile,
);

typedef _c_clang_getFileUniqueID = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> file,
  ffi.Pointer<CXFileUniqueID> outID,
);

typedef _dart_clang_getFileUniqueID = int Function(
  ffi.Pointer<ffi.Void> file,
  ffi.Pointer<CXFileUniqueID> outID,
);

typedef _c_clang_isFileMultipleIncludeGuarded = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
);

typedef _dart_clang_isFileMultipleIncludeGuarded = int Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
);

typedef _c_clang_getFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Int8> file_name,
);

typedef _dart_clang_getFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Int8> file_name,
);

typedef _c_clang_getFileContents = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_clang_getFileContents = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_clang_File_isEqual = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> file1,
  ffi.Pointer<ffi.Void> file2,
);

typedef _dart_clang_File_isEqual = int Function(
  ffi.Pointer<ffi.Void> file1,
  ffi.Pointer<ffi.Void> file2,
);

typedef _c_clang_File_tryGetRealPathName = CXString Function(
  ffi.Pointer<ffi.Void> file,
);

typedef _dart_clang_File_tryGetRealPathName = CXString Function(
  ffi.Pointer<ffi.Void> file,
);

typedef _c_clang_getNullLocation = CXSourceLocation Function();

typedef _dart_clang_getNullLocation = CXSourceLocation Function();

typedef _c_clang_equalLocations = ffi.Uint32 Function(
  CXSourceLocation loc1,
  CXSourceLocation loc2,
);

typedef _dart_clang_equalLocations = int Function(
  CXSourceLocation loc1,
  CXSourceLocation loc2,
);

typedef _c_clang_getLocation = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  ffi.Uint32 line,
  ffi.Uint32 column,
);

typedef _dart_clang_getLocation = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  int line,
  int column,
);

typedef _c_clang_getLocationForOffset = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  ffi.Uint32 offset,
);

typedef _dart_clang_getLocationForOffset = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
  int offset,
);

typedef _c_clang_Location_isInSystemHeader = ffi.Int32 Function(
  CXSourceLocation location,
);

typedef _dart_clang_Location_isInSystemHeader = int Function(
  CXSourceLocation location,
);

typedef _c_clang_Location_isFromMainFile = ffi.Int32 Function(
  CXSourceLocation location,
);

typedef _dart_clang_Location_isFromMainFile = int Function(
  CXSourceLocation location,
);

typedef _c_clang_getNullRange = CXSourceRange Function();

typedef _dart_clang_getNullRange = CXSourceRange Function();

typedef _c_clang_getRange = CXSourceRange Function(
  CXSourceLocation begin,
  CXSourceLocation end,
);

typedef _dart_clang_getRange = CXSourceRange Function(
  CXSourceLocation begin,
  CXSourceLocation end,
);

typedef _c_clang_equalRanges = ffi.Uint32 Function(
  CXSourceRange range1,
  CXSourceRange range2,
);

typedef _dart_clang_equalRanges = int Function(
  CXSourceRange range1,
  CXSourceRange range2,
);

typedef _c_clang_Range_isNull = ffi.Int32 Function(
  CXSourceRange range,
);

typedef _dart_clang_Range_isNull = int Function(
  CXSourceRange range,
);

typedef _c_clang_getExpansionLocation = ffi.Void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _dart_clang_getExpansionLocation = void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _c_clang_getPresumedLocation = ffi.Void Function(
  CXSourceLocation location,
  ffi.Pointer<CXString> filename,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
);

typedef _dart_clang_getPresumedLocation = void Function(
  CXSourceLocation location,
  ffi.Pointer<CXString> filename,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
);

typedef _c_clang_getInstantiationLocation = ffi.Void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _dart_clang_getInstantiationLocation = void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _c_clang_getSpellingLocation = ffi.Void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _dart_clang_getSpellingLocation = void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _c_clang_getFileLocation = ffi.Void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _dart_clang_getFileLocation = void Function(
  CXSourceLocation location,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _c_clang_getRangeStart = CXSourceLocation Function(
  CXSourceRange range,
);

typedef _dart_clang_getRangeStart = CXSourceLocation Function(
  CXSourceRange range,
);

typedef _c_clang_getRangeEnd = CXSourceLocation Function(
  CXSourceRange range,
);

typedef _dart_clang_getRangeEnd = CXSourceLocation Function(
  CXSourceRange range,
);

typedef _c_clang_getSkippedRanges = ffi.Pointer<CXSourceRangeList> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
);

typedef _dart_clang_getSkippedRanges = ffi.Pointer<CXSourceRangeList> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.Void> file,
);

typedef _c_clang_getAllSkippedRanges = ffi.Pointer<CXSourceRangeList> Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
);

typedef _dart_clang_getAllSkippedRanges = ffi.Pointer<CXSourceRangeList>
    Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
);

typedef _c_clang_disposeSourceRangeList = ffi.Void Function(
  ffi.Pointer<CXSourceRangeList> ranges,
);

typedef _dart_clang_disposeSourceRangeList = void Function(
  ffi.Pointer<CXSourceRangeList> ranges,
);

typedef _c_clang_getNumDiagnosticsInSet = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> Diags,
);

typedef _dart_clang_getNumDiagnosticsInSet = int Function(
  ffi.Pointer<ffi.Void> Diags,
);

typedef _c_clang_getDiagnosticInSet = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Diags,
  ffi.Uint32 Index,
);

typedef _dart_clang_getDiagnosticInSet = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Diags,
  int Index,
);

typedef _c_clang_loadDiagnostics = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Int32> error,
  ffi.Pointer<CXString> errorString,
);

typedef _dart_clang_loadDiagnostics = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> file,
  ffi.Pointer<ffi.Int32> error,
  ffi.Pointer<CXString> errorString,
);

typedef _c_clang_disposeDiagnosticSet = ffi.Void Function(
  ffi.Pointer<ffi.Void> Diags,
);

typedef _dart_clang_disposeDiagnosticSet = void Function(
  ffi.Pointer<ffi.Void> Diags,
);

typedef _c_clang_getChildDiagnostics = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> D,
);

typedef _dart_clang_getChildDiagnostics = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> D,
);

typedef _c_clang_getNumDiagnostics = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
);

typedef _dart_clang_getNumDiagnostics = int Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
);

typedef _c_clang_getDiagnostic = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
  ffi.Uint32 Index,
);

typedef _dart_clang_getDiagnostic = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
  int Index,
);

typedef _c_clang_getDiagnosticSetFromTU = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
);

typedef _dart_clang_getDiagnosticSetFromTU = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> Unit,
);

typedef _c_clang_disposeDiagnostic = ffi.Void Function(
  ffi.Pointer<ffi.Void> Diagnostic,
);

typedef _dart_clang_disposeDiagnostic = void Function(
  ffi.Pointer<ffi.Void> Diagnostic,
);

typedef _c_clang_formatDiagnostic = CXString Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  ffi.Uint32 Options,
);

typedef _dart_clang_formatDiagnostic = CXString Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  int Options,
);

typedef _c_clang_defaultDiagnosticDisplayOptions = ffi.Uint32 Function();

typedef _dart_clang_defaultDiagnosticDisplayOptions = int Function();

typedef _c_clang_getDiagnosticSeverity = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticSeverity = int Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticLocation = CXSourceLocation Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticLocation = CXSourceLocation Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticSpelling = CXString Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticSpelling = CXString Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticOption = CXString Function(
  ffi.Pointer<ffi.Void> Diag,
  ffi.Pointer<CXString> Disable,
);

typedef _dart_clang_getDiagnosticOption = CXString Function(
  ffi.Pointer<ffi.Void> Diag,
  ffi.Pointer<CXString> Disable,
);

typedef _c_clang_getDiagnosticCategory = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticCategory = int Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticCategoryName = CXString Function(
  ffi.Uint32 Category,
);

typedef _dart_clang_getDiagnosticCategoryName = CXString Function(
  int Category,
);

typedef _c_clang_getDiagnosticCategoryText = CXString Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticCategoryText = CXString Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticNumRanges = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_getDiagnosticNumRanges = int Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_getDiagnosticRange = CXSourceRange Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  ffi.Uint32 Range,
);

typedef _dart_clang_getDiagnosticRange = CXSourceRange Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  int Range,
);

typedef _c_clang_getDiagnosticNumFixIts = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> Diagnostic,
);

typedef _dart_clang_getDiagnosticNumFixIts = int Function(
  ffi.Pointer<ffi.Void> Diagnostic,
);

typedef _c_clang_getDiagnosticFixIt = CXString Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  ffi.Uint32 FixIt,
  ffi.Pointer<CXSourceRange> ReplacementRange,
);

typedef _dart_clang_getDiagnosticFixIt = CXString Function(
  ffi.Pointer<ffi.Void> Diagnostic,
  int FixIt,
  ffi.Pointer<CXSourceRange> ReplacementRange,
);

typedef _c_clang_getTranslationUnitSpelling = CXString Function(
  ffi.Pointer<CXTranslationUnitImpl> CTUnit,
);

typedef _dart_clang_getTranslationUnitSpelling = CXString Function(
  ffi.Pointer<CXTranslationUnitImpl> CTUnit,
);

typedef _c_clang_createTranslationUnitFromSourceFile
    = ffi.Pointer<CXTranslationUnitImpl> Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Int32 num_clang_command_line_args,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> clang_command_line_args,
  ffi.Uint32 num_unsaved_files,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
);

typedef _dart_clang_createTranslationUnitFromSourceFile
    = ffi.Pointer<CXTranslationUnitImpl> Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  int num_clang_command_line_args,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> clang_command_line_args,
  int num_unsaved_files,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
);

typedef _c_clang_createTranslationUnit = ffi.Pointer<CXTranslationUnitImpl>
    Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> ast_filename,
);

typedef _dart_clang_createTranslationUnit = ffi.Pointer<CXTranslationUnitImpl>
    Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> ast_filename,
);

typedef _c_clang_createTranslationUnit2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> ast_filename,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _dart_clang_createTranslationUnit2 = int Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> ast_filename,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _c_clang_defaultEditingTranslationUnitOptions = ffi.Uint32 Function();

typedef _dart_clang_defaultEditingTranslationUnitOptions = int Function();

typedef _c_clang_parseTranslationUnit = ffi.Pointer<CXTranslationUnitImpl>
    Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  ffi.Int32 num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Uint32 options,
);

typedef _dart_clang_parseTranslationUnit = ffi.Pointer<CXTranslationUnitImpl>
    Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  int num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  int options,
);

typedef _c_clang_parseTranslationUnit2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  ffi.Int32 num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Uint32 options,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _dart_clang_parseTranslationUnit2 = int Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  int num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  int options,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _c_clang_parseTranslationUnit2FullArgv = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  ffi.Int32 num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Uint32 options,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _dart_clang_parseTranslationUnit2FullArgv = int Function(
  ffi.Pointer<ffi.Void> CIdx,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  int num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  int options,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
);

typedef _c_clang_defaultSaveOptions = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _dart_clang_defaultSaveOptions = int Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _c_clang_saveTranslationUnit = ffi.Int32 Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Int8> FileName,
  ffi.Uint32 options,
);

typedef _dart_clang_saveTranslationUnit = int Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Int8> FileName,
  int options,
);

typedef _c_clang_suspendTranslationUnit = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _dart_clang_suspendTranslationUnit = int Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _c_clang_disposeTranslationUnit = ffi.Void Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _dart_clang_disposeTranslationUnit = void Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _c_clang_defaultReparseOptions = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _dart_clang_defaultReparseOptions = int Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _c_clang_reparseTranslationUnit = ffi.Int32 Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Uint32 num_unsaved_files,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 options,
);

typedef _dart_clang_reparseTranslationUnit = int Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  int num_unsaved_files,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int options,
);

typedef _c_clang_getTUResourceUsageName = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 kind,
);

typedef _dart_clang_getTUResourceUsageName = ffi.Pointer<ffi.Int8> Function(
  int kind,
);

typedef _c_clang_getCXTUResourceUsage = CXTUResourceUsage Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _dart_clang_getCXTUResourceUsage = CXTUResourceUsage Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
);

typedef _c_clang_disposeCXTUResourceUsage = ffi.Void Function(
  CXTUResourceUsage usage,
);

typedef _dart_clang_disposeCXTUResourceUsage = void Function(
  CXTUResourceUsage usage,
);

typedef _c_clang_getTranslationUnitTargetInfo = ffi.Pointer<CXTargetInfoImpl>
    Function(
  ffi.Pointer<CXTranslationUnitImpl> CTUnit,
);

typedef _dart_clang_getTranslationUnitTargetInfo = ffi.Pointer<CXTargetInfoImpl>
    Function(
  ffi.Pointer<CXTranslationUnitImpl> CTUnit,
);

typedef _c_clang_TargetInfo_dispose = ffi.Void Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _dart_clang_TargetInfo_dispose = void Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _c_clang_TargetInfo_getTriple = CXString Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _dart_clang_TargetInfo_getTriple = CXString Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _c_clang_TargetInfo_getPointerWidth = ffi.Int32 Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _dart_clang_TargetInfo_getPointerWidth = int Function(
  ffi.Pointer<CXTargetInfoImpl> Info,
);

typedef _c_clang_getNullCursor = CXCursor Function();

typedef _dart_clang_getNullCursor = CXCursor Function();

typedef _c_clang_getTranslationUnitCursor = CXCursor Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _dart_clang_getTranslationUnitCursor = CXCursor Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
);

typedef _c_clang_equalCursors = ffi.Uint32 Function(
  CXCursor arg0,
  CXCursor arg1,
);

typedef _dart_clang_equalCursors = int Function(
  CXCursor arg0,
  CXCursor arg1,
);

typedef _c_clang_Cursor_isNull = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_Cursor_isNull = int Function(
  CXCursor cursor,
);

typedef _c_clang_hashCursor = ffi.Uint32 Function(
  CXCursor arg0,
);

typedef _dart_clang_hashCursor = int Function(
  CXCursor arg0,
);

typedef _c_clang_getCursorKind = ffi.Int32 Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorKind = int Function(
  CXCursor arg0,
);

typedef _c_clang_isDeclaration = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isDeclaration = int Function(
  int arg0,
);

typedef _c_clang_isInvalidDeclaration = ffi.Uint32 Function(
  CXCursor arg0,
);

typedef _dart_clang_isInvalidDeclaration = int Function(
  CXCursor arg0,
);

typedef _c_clang_isReference = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isReference = int Function(
  int arg0,
);

typedef _c_clang_isExpression = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isExpression = int Function(
  int arg0,
);

typedef _c_clang_isStatement = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isStatement = int Function(
  int arg0,
);

typedef _c_clang_isAttribute = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isAttribute = int Function(
  int arg0,
);

typedef _c_clang_Cursor_hasAttrs = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_hasAttrs = int Function(
  CXCursor C,
);

typedef _c_clang_isInvalid = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isInvalid = int Function(
  int arg0,
);

typedef _c_clang_isTranslationUnit = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isTranslationUnit = int Function(
  int arg0,
);

typedef _c_clang_isPreprocessing = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isPreprocessing = int Function(
  int arg0,
);

typedef _c_clang_isUnexposed = ffi.Uint32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_isUnexposed = int Function(
  int arg0,
);

typedef _c_clang_getCursorLinkage = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorLinkage = int Function(
  CXCursor cursor,
);

typedef _c_clang_getCursorVisibility = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorVisibility = int Function(
  CXCursor cursor,
);

typedef _c_clang_getCursorAvailability = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorAvailability = int Function(
  CXCursor cursor,
);

typedef _c_clang_getCursorPlatformAvailability = ffi.Int32 Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Int32> always_deprecated,
  ffi.Pointer<CXString> deprecated_message,
  ffi.Pointer<ffi.Int32> always_unavailable,
  ffi.Pointer<CXString> unavailable_message,
  ffi.Pointer<CXPlatformAvailability> availability,
  ffi.Int32 availability_size,
);

typedef _dart_clang_getCursorPlatformAvailability = int Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Int32> always_deprecated,
  ffi.Pointer<CXString> deprecated_message,
  ffi.Pointer<ffi.Int32> always_unavailable,
  ffi.Pointer<CXString> unavailable_message,
  ffi.Pointer<CXPlatformAvailability> availability,
  int availability_size,
);

typedef _c_clang_disposeCXPlatformAvailability = ffi.Void Function(
  ffi.Pointer<CXPlatformAvailability> availability,
);

typedef _dart_clang_disposeCXPlatformAvailability = void Function(
  ffi.Pointer<CXPlatformAvailability> availability,
);

typedef _c_clang_getCursorLanguage = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorLanguage = int Function(
  CXCursor cursor,
);

typedef _c_clang_getCursorTLSKind = ffi.Int32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorTLSKind = int Function(
  CXCursor cursor,
);

typedef _c_clang_Cursor_getTranslationUnit = ffi.Pointer<CXTranslationUnitImpl>
    Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getTranslationUnit
    = ffi.Pointer<CXTranslationUnitImpl> Function(
  CXCursor arg0,
);

typedef _c_clang_createCXCursorSet = ffi.Pointer<CXCursorSetImpl> Function();

typedef _dart_clang_createCXCursorSet = ffi.Pointer<CXCursorSetImpl> Function();

typedef _c_clang_disposeCXCursorSet = ffi.Void Function(
  ffi.Pointer<CXCursorSetImpl> cset,
);

typedef _dart_clang_disposeCXCursorSet = void Function(
  ffi.Pointer<CXCursorSetImpl> cset,
);

typedef _c_clang_CXCursorSet_contains = ffi.Uint32 Function(
  ffi.Pointer<CXCursorSetImpl> cset,
  CXCursor cursor,
);

typedef _dart_clang_CXCursorSet_contains = int Function(
  ffi.Pointer<CXCursorSetImpl> cset,
  CXCursor cursor,
);

typedef _c_clang_CXCursorSet_insert = ffi.Uint32 Function(
  ffi.Pointer<CXCursorSetImpl> cset,
  CXCursor cursor,
);

typedef _dart_clang_CXCursorSet_insert = int Function(
  ffi.Pointer<CXCursorSetImpl> cset,
  CXCursor cursor,
);

typedef _c_clang_getCursorSemanticParent = CXCursor Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorSemanticParent = CXCursor Function(
  CXCursor cursor,
);

typedef _c_clang_getCursorLexicalParent = CXCursor Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorLexicalParent = CXCursor Function(
  CXCursor cursor,
);

typedef _c_clang_getOverriddenCursors = ffi.Void Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Pointer<CXCursor>> overridden,
  ffi.Pointer<ffi.Uint32> num_overridden,
);

typedef _dart_clang_getOverriddenCursors = void Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Pointer<CXCursor>> overridden,
  ffi.Pointer<ffi.Uint32> num_overridden,
);

typedef _c_clang_disposeOverriddenCursors = ffi.Void Function(
  ffi.Pointer<CXCursor> overridden,
);

typedef _dart_clang_disposeOverriddenCursors = void Function(
  ffi.Pointer<CXCursor> overridden,
);

typedef _c_clang_getIncludedFile = ffi.Pointer<ffi.Void> Function(
  CXCursor cursor,
);

typedef _dart_clang_getIncludedFile = ffi.Pointer<ffi.Void> Function(
  CXCursor cursor,
);

typedef _c_clang_getCursor = CXCursor Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXSourceLocation arg1,
);

typedef _dart_clang_getCursor = CXCursor Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXSourceLocation arg1,
);

typedef _c_clang_getCursorLocation = CXSourceLocation Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorLocation = CXSourceLocation Function(
  CXCursor arg0,
);

typedef _c_clang_getCursorExtent = CXSourceRange Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorExtent = CXSourceRange Function(
  CXCursor arg0,
);

typedef _c_clang_getCursorType = CXType Function(
  CXCursor C,
);

typedef _dart_clang_getCursorType = CXType Function(
  CXCursor C,
);

typedef _c_clang_getTypeSpelling = CXString Function(
  CXType CT,
);

typedef _dart_clang_getTypeSpelling = CXString Function(
  CXType CT,
);

typedef _c_clang_getTypedefDeclUnderlyingType = CXType Function(
  CXCursor C,
);

typedef _dart_clang_getTypedefDeclUnderlyingType = CXType Function(
  CXCursor C,
);

typedef _c_clang_getEnumDeclIntegerType = CXType Function(
  CXCursor C,
);

typedef _dart_clang_getEnumDeclIntegerType = CXType Function(
  CXCursor C,
);

typedef _c_clang_getEnumConstantDeclValue = ffi.Int64 Function(
  CXCursor C,
);

typedef _dart_clang_getEnumConstantDeclValue = int Function(
  CXCursor C,
);

typedef _c_clang_getEnumConstantDeclUnsignedValue = ffi.Uint64 Function(
  CXCursor C,
);

typedef _dart_clang_getEnumConstantDeclUnsignedValue = int Function(
  CXCursor C,
);

typedef _c_clang_getFieldDeclBitWidth = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_getFieldDeclBitWidth = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getNumArguments = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getNumArguments = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getArgument = CXCursor Function(
  CXCursor C,
  ffi.Uint32 i,
);

typedef _dart_clang_Cursor_getArgument = CXCursor Function(
  CXCursor C,
  int i,
);

typedef _c_clang_Cursor_getNumTemplateArguments = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getNumTemplateArguments = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getTemplateArgumentKind = ffi.Int32 Function(
  CXCursor C,
  ffi.Uint32 I,
);

typedef _dart_clang_Cursor_getTemplateArgumentKind = int Function(
  CXCursor C,
  int I,
);

typedef _c_clang_Cursor_getTemplateArgumentType = CXType Function(
  CXCursor C,
  ffi.Uint32 I,
);

typedef _dart_clang_Cursor_getTemplateArgumentType = CXType Function(
  CXCursor C,
  int I,
);

typedef _c_clang_Cursor_getTemplateArgumentValue = ffi.Int64 Function(
  CXCursor C,
  ffi.Uint32 I,
);

typedef _dart_clang_Cursor_getTemplateArgumentValue = int Function(
  CXCursor C,
  int I,
);

typedef _c_clang_Cursor_getTemplateArgumentUnsignedValue = ffi.Uint64 Function(
  CXCursor C,
  ffi.Uint32 I,
);

typedef _dart_clang_Cursor_getTemplateArgumentUnsignedValue = int Function(
  CXCursor C,
  int I,
);

typedef _c_clang_equalTypes = ffi.Uint32 Function(
  CXType A,
  CXType B,
);

typedef _dart_clang_equalTypes = int Function(
  CXType A,
  CXType B,
);

typedef _c_clang_getCanonicalType = CXType Function(
  CXType T,
);

typedef _dart_clang_getCanonicalType = CXType Function(
  CXType T,
);

typedef _c_clang_isConstQualifiedType = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_isConstQualifiedType = int Function(
  CXType T,
);

typedef _c_clang_Cursor_isMacroFunctionLike = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isMacroFunctionLike = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isMacroBuiltin = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isMacroBuiltin = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isFunctionInlined = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isFunctionInlined = int Function(
  CXCursor C,
);

typedef _c_clang_isVolatileQualifiedType = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_isVolatileQualifiedType = int Function(
  CXType T,
);

typedef _c_clang_isRestrictQualifiedType = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_isRestrictQualifiedType = int Function(
  CXType T,
);

typedef _c_clang_getAddressSpace = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_getAddressSpace = int Function(
  CXType T,
);

typedef _c_clang_getTypedefName = CXString Function(
  CXType CT,
);

typedef _dart_clang_getTypedefName = CXString Function(
  CXType CT,
);

typedef _c_clang_getPointeeType = CXType Function(
  CXType T,
);

typedef _dart_clang_getPointeeType = CXType Function(
  CXType T,
);

typedef _c_clang_getTypeDeclaration = CXCursor Function(
  CXType T,
);

typedef _dart_clang_getTypeDeclaration = CXCursor Function(
  CXType T,
);

typedef _c_clang_getDeclObjCTypeEncoding = CXString Function(
  CXCursor C,
);

typedef _dart_clang_getDeclObjCTypeEncoding = CXString Function(
  CXCursor C,
);

typedef _c_clang_Type_getObjCEncoding = CXString Function(
  CXType type,
);

typedef _dart_clang_Type_getObjCEncoding = CXString Function(
  CXType type,
);

typedef _c_clang_getTypeKindSpelling = CXString Function(
  ffi.Int32 K,
);

typedef _dart_clang_getTypeKindSpelling = CXString Function(
  int K,
);

typedef _c_clang_getFunctionTypeCallingConv = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_getFunctionTypeCallingConv = int Function(
  CXType T,
);

typedef _c_clang_getResultType = CXType Function(
  CXType T,
);

typedef _dart_clang_getResultType = CXType Function(
  CXType T,
);

typedef _c_clang_getExceptionSpecificationType = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_getExceptionSpecificationType = int Function(
  CXType T,
);

typedef _c_clang_getNumArgTypes = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_getNumArgTypes = int Function(
  CXType T,
);

typedef _c_clang_getArgType = CXType Function(
  CXType T,
  ffi.Uint32 i,
);

typedef _dart_clang_getArgType = CXType Function(
  CXType T,
  int i,
);

typedef _c_clang_Type_getObjCObjectBaseType = CXType Function(
  CXType T,
);

typedef _dart_clang_Type_getObjCObjectBaseType = CXType Function(
  CXType T,
);

typedef _c_clang_Type_getNumObjCProtocolRefs = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_Type_getNumObjCProtocolRefs = int Function(
  CXType T,
);

typedef _c_clang_Type_getObjCProtocolDecl = CXCursor Function(
  CXType T,
  ffi.Uint32 i,
);

typedef _dart_clang_Type_getObjCProtocolDecl = CXCursor Function(
  CXType T,
  int i,
);

typedef _c_clang_Type_getNumObjCTypeArgs = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_Type_getNumObjCTypeArgs = int Function(
  CXType T,
);

typedef _c_clang_Type_getObjCTypeArg = CXType Function(
  CXType T,
  ffi.Uint32 i,
);

typedef _dart_clang_Type_getObjCTypeArg = CXType Function(
  CXType T,
  int i,
);

typedef _c_clang_isFunctionTypeVariadic = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_isFunctionTypeVariadic = int Function(
  CXType T,
);

typedef _c_clang_getCursorResultType = CXType Function(
  CXCursor C,
);

typedef _dart_clang_getCursorResultType = CXType Function(
  CXCursor C,
);

typedef _c_clang_getCursorExceptionSpecificationType = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_getCursorExceptionSpecificationType = int Function(
  CXCursor C,
);

typedef _c_clang_isPODType = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_isPODType = int Function(
  CXType T,
);

typedef _c_clang_getElementType = CXType Function(
  CXType T,
);

typedef _dart_clang_getElementType = CXType Function(
  CXType T,
);

typedef _c_clang_getNumElements = ffi.Int64 Function(
  CXType T,
);

typedef _dart_clang_getNumElements = int Function(
  CXType T,
);

typedef _c_clang_getArrayElementType = CXType Function(
  CXType T,
);

typedef _dart_clang_getArrayElementType = CXType Function(
  CXType T,
);

typedef _c_clang_getArraySize = ffi.Int64 Function(
  CXType T,
);

typedef _dart_clang_getArraySize = int Function(
  CXType T,
);

typedef _c_clang_Type_getNamedType = CXType Function(
  CXType T,
);

typedef _dart_clang_Type_getNamedType = CXType Function(
  CXType T,
);

typedef _c_clang_Type_isTransparentTagTypedef = ffi.Uint32 Function(
  CXType T,
);

typedef _dart_clang_Type_isTransparentTagTypedef = int Function(
  CXType T,
);

typedef _c_clang_Type_getNullability = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_Type_getNullability = int Function(
  CXType T,
);

typedef _c_clang_Type_getAlignOf = ffi.Int64 Function(
  CXType T,
);

typedef _dart_clang_Type_getAlignOf = int Function(
  CXType T,
);

typedef _c_clang_Type_getClassType = CXType Function(
  CXType T,
);

typedef _dart_clang_Type_getClassType = CXType Function(
  CXType T,
);

typedef _c_clang_Type_getSizeOf = ffi.Int64 Function(
  CXType T,
);

typedef _dart_clang_Type_getSizeOf = int Function(
  CXType T,
);

typedef _c_clang_Type_getOffsetOf = ffi.Int64 Function(
  CXType T,
  ffi.Pointer<ffi.Int8> S,
);

typedef _dart_clang_Type_getOffsetOf = int Function(
  CXType T,
  ffi.Pointer<ffi.Int8> S,
);

typedef _c_clang_Type_getModifiedType = CXType Function(
  CXType T,
);

typedef _dart_clang_Type_getModifiedType = CXType Function(
  CXType T,
);

typedef _c_clang_Cursor_getOffsetOfField = ffi.Int64 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getOffsetOfField = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isAnonymous = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isAnonymous = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isAnonymousRecordDecl = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isAnonymousRecordDecl = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isInlineNamespace = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isInlineNamespace = int Function(
  CXCursor C,
);

typedef _c_clang_Type_getNumTemplateArguments = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_Type_getNumTemplateArguments = int Function(
  CXType T,
);

typedef _c_clang_Type_getTemplateArgumentAsType = CXType Function(
  CXType T,
  ffi.Uint32 i,
);

typedef _dart_clang_Type_getTemplateArgumentAsType = CXType Function(
  CXType T,
  int i,
);

typedef _c_clang_Type_getCXXRefQualifier = ffi.Int32 Function(
  CXType T,
);

typedef _dart_clang_Type_getCXXRefQualifier = int Function(
  CXType T,
);

typedef _c_clang_Cursor_isBitField = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isBitField = int Function(
  CXCursor C,
);

typedef _c_clang_isVirtualBase = ffi.Uint32 Function(
  CXCursor arg0,
);

typedef _dart_clang_isVirtualBase = int Function(
  CXCursor arg0,
);

typedef _c_clang_getCXXAccessSpecifier = ffi.Int32 Function(
  CXCursor arg0,
);

typedef _dart_clang_getCXXAccessSpecifier = int Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getStorageClass = ffi.Int32 Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getStorageClass = int Function(
  CXCursor arg0,
);

typedef _c_clang_getNumOverloadedDecls = ffi.Uint32 Function(
  CXCursor cursor,
);

typedef _dart_clang_getNumOverloadedDecls = int Function(
  CXCursor cursor,
);

typedef _c_clang_getOverloadedDecl = CXCursor Function(
  CXCursor cursor,
  ffi.Uint32 index,
);

typedef _dart_clang_getOverloadedDecl = CXCursor Function(
  CXCursor cursor,
  int index,
);

typedef _c_clang_getIBOutletCollectionType = CXType Function(
  CXCursor arg0,
);

typedef _dart_clang_getIBOutletCollectionType = CXType Function(
  CXCursor arg0,
);

typedef CXCursorVisitor = ffi.Int32 Function(
  CXCursor,
  CXCursor,
  ffi.Pointer<ffi.Void>,
);

typedef _c_clang_visitChildren = ffi.Uint32 Function(
  CXCursor parent,
  ffi.Pointer<ffi.NativeFunction<CXCursorVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _dart_clang_visitChildren = int Function(
  CXCursor parent,
  ffi.Pointer<ffi.NativeFunction<CXCursorVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _c_clang_getCursorUSR = CXString Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorUSR = CXString Function(
  CXCursor arg0,
);

typedef _c_clang_constructUSR_ObjCClass = CXString Function(
  ffi.Pointer<ffi.Int8> class_name,
);

typedef _dart_clang_constructUSR_ObjCClass = CXString Function(
  ffi.Pointer<ffi.Int8> class_name,
);

typedef _c_clang_constructUSR_ObjCCategory = CXString Function(
  ffi.Pointer<ffi.Int8> class_name,
  ffi.Pointer<ffi.Int8> category_name,
);

typedef _dart_clang_constructUSR_ObjCCategory = CXString Function(
  ffi.Pointer<ffi.Int8> class_name,
  ffi.Pointer<ffi.Int8> category_name,
);

typedef _c_clang_constructUSR_ObjCProtocol = CXString Function(
  ffi.Pointer<ffi.Int8> protocol_name,
);

typedef _dart_clang_constructUSR_ObjCProtocol = CXString Function(
  ffi.Pointer<ffi.Int8> protocol_name,
);

typedef _c_clang_constructUSR_ObjCIvar = CXString Function(
  ffi.Pointer<ffi.Int8> name,
  CXString classUSR,
);

typedef _dart_clang_constructUSR_ObjCIvar = CXString Function(
  ffi.Pointer<ffi.Int8> name,
  CXString classUSR,
);

typedef _c_clang_constructUSR_ObjCMethod = CXString Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint32 isInstanceMethod,
  CXString classUSR,
);

typedef _dart_clang_constructUSR_ObjCMethod = CXString Function(
  ffi.Pointer<ffi.Int8> name,
  int isInstanceMethod,
  CXString classUSR,
);

typedef _c_clang_constructUSR_ObjCProperty = CXString Function(
  ffi.Pointer<ffi.Int8> property,
  CXString classUSR,
);

typedef _dart_clang_constructUSR_ObjCProperty = CXString Function(
  ffi.Pointer<ffi.Int8> property,
  CXString classUSR,
);

typedef _c_clang_getCursorSpelling = CXString Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorSpelling = CXString Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getSpellingNameRange = CXSourceRange Function(
  CXCursor arg0,
  ffi.Uint32 pieceIndex,
  ffi.Uint32 options,
);

typedef _dart_clang_Cursor_getSpellingNameRange = CXSourceRange Function(
  CXCursor arg0,
  int pieceIndex,
  int options,
);

typedef _c_clang_PrintingPolicy_getProperty = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> Policy,
  ffi.Int32 Property,
);

typedef _dart_clang_PrintingPolicy_getProperty = int Function(
  ffi.Pointer<ffi.Void> Policy,
  int Property,
);

typedef _c_clang_PrintingPolicy_setProperty = ffi.Void Function(
  ffi.Pointer<ffi.Void> Policy,
  ffi.Int32 Property,
  ffi.Uint32 Value,
);

typedef _dart_clang_PrintingPolicy_setProperty = void Function(
  ffi.Pointer<ffi.Void> Policy,
  int Property,
  int Value,
);

typedef _c_clang_getCursorPrintingPolicy = ffi.Pointer<ffi.Void> Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorPrintingPolicy = ffi.Pointer<ffi.Void> Function(
  CXCursor arg0,
);

typedef _c_clang_PrintingPolicy_dispose = ffi.Void Function(
  ffi.Pointer<ffi.Void> Policy,
);

typedef _dart_clang_PrintingPolicy_dispose = void Function(
  ffi.Pointer<ffi.Void> Policy,
);

typedef _c_clang_getCursorPrettyPrinted = CXString Function(
  CXCursor Cursor,
  ffi.Pointer<ffi.Void> Policy,
);

typedef _dart_clang_getCursorPrettyPrinted = CXString Function(
  CXCursor Cursor,
  ffi.Pointer<ffi.Void> Policy,
);

typedef _c_clang_getCursorDisplayName = CXString Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorDisplayName = CXString Function(
  CXCursor arg0,
);

typedef _c_clang_getCursorReferenced = CXCursor Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorReferenced = CXCursor Function(
  CXCursor arg0,
);

typedef _c_clang_getCursorDefinition = CXCursor Function(
  CXCursor arg0,
);

typedef _dart_clang_getCursorDefinition = CXCursor Function(
  CXCursor arg0,
);

typedef _c_clang_isCursorDefinition = ffi.Uint32 Function(
  CXCursor arg0,
);

typedef _dart_clang_isCursorDefinition = int Function(
  CXCursor arg0,
);

typedef _c_clang_getCanonicalCursor = CXCursor Function(
  CXCursor arg0,
);

typedef _dart_clang_getCanonicalCursor = CXCursor Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getObjCSelectorIndex = ffi.Int32 Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getObjCSelectorIndex = int Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_isDynamicCall = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isDynamicCall = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getReceiverType = CXType Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getReceiverType = CXType Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getObjCPropertyAttributes = ffi.Uint32 Function(
  CXCursor C,
  ffi.Uint32 reserved,
);

typedef _dart_clang_Cursor_getObjCPropertyAttributes = int Function(
  CXCursor C,
  int reserved,
);

typedef _c_clang_Cursor_getObjCPropertyGetterName = CXString Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getObjCPropertyGetterName = CXString Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getObjCPropertySetterName = CXString Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getObjCPropertySetterName = CXString Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getObjCDeclQualifiers = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getObjCDeclQualifiers = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isObjCOptional = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isObjCOptional = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isVariadic = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_isVariadic = int Function(
  CXCursor C,
);

typedef _c_clang_Cursor_isExternalSymbol = ffi.Uint32 Function(
  CXCursor C,
  ffi.Pointer<CXString> language,
  ffi.Pointer<CXString> definedIn,
  ffi.Pointer<ffi.Uint32> isGenerated,
);

typedef _dart_clang_Cursor_isExternalSymbol = int Function(
  CXCursor C,
  ffi.Pointer<CXString> language,
  ffi.Pointer<CXString> definedIn,
  ffi.Pointer<ffi.Uint32> isGenerated,
);

typedef _c_clang_Cursor_getCommentRange = CXSourceRange Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getCommentRange = CXSourceRange Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getRawCommentText = CXString Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getRawCommentText = CXString Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getBriefCommentText = CXString Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getBriefCommentText = CXString Function(
  CXCursor C,
);

typedef _c_clang_Cursor_getMangling = CXString Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getMangling = CXString Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getCXXManglings = ffi.Pointer<CXStringSet> Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getCXXManglings = ffi.Pointer<CXStringSet> Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getObjCManglings = ffi.Pointer<CXStringSet> Function(
  CXCursor arg0,
);

typedef _dart_clang_Cursor_getObjCManglings = ffi.Pointer<CXStringSet> Function(
  CXCursor arg0,
);

typedef _c_clang_Cursor_getModule = ffi.Pointer<ffi.Void> Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_getModule = ffi.Pointer<ffi.Void> Function(
  CXCursor C,
);

typedef _c_clang_getModuleForFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _dart_clang_getModuleForFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _c_clang_Module_getASTFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_getASTFile = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_getParent = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_getParent = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_getName = CXString Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_getName = CXString Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_getFullName = CXString Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_getFullName = CXString Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_isSystem = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_isSystem = int Function(
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_getNumTopLevelHeaders = ffi.Uint32 Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> Module,
);

typedef _dart_clang_Module_getNumTopLevelHeaders = int Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> Module,
);

typedef _c_clang_Module_getTopLevelHeader = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> Module,
  ffi.Uint32 Index,
);

typedef _dart_clang_Module_getTopLevelHeader = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  ffi.Pointer<ffi.Void> Module,
  int Index,
);

typedef _c_clang_CXXConstructor_isConvertingConstructor = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXConstructor_isConvertingConstructor = int Function(
  CXCursor C,
);

typedef _c_clang_CXXConstructor_isCopyConstructor = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXConstructor_isCopyConstructor = int Function(
  CXCursor C,
);

typedef _c_clang_CXXConstructor_isDefaultConstructor = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXConstructor_isDefaultConstructor = int Function(
  CXCursor C,
);

typedef _c_clang_CXXConstructor_isMoveConstructor = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXConstructor_isMoveConstructor = int Function(
  CXCursor C,
);

typedef _c_clang_CXXField_isMutable = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXField_isMutable = int Function(
  CXCursor C,
);

typedef _c_clang_CXXMethod_isDefaulted = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXMethod_isDefaulted = int Function(
  CXCursor C,
);

typedef _c_clang_CXXMethod_isPureVirtual = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXMethod_isPureVirtual = int Function(
  CXCursor C,
);

typedef _c_clang_CXXMethod_isStatic = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXMethod_isStatic = int Function(
  CXCursor C,
);

typedef _c_clang_CXXMethod_isVirtual = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXMethod_isVirtual = int Function(
  CXCursor C,
);

typedef _c_clang_CXXRecord_isAbstract = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXRecord_isAbstract = int Function(
  CXCursor C,
);

typedef _c_clang_EnumDecl_isScoped = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_EnumDecl_isScoped = int Function(
  CXCursor C,
);

typedef _c_clang_CXXMethod_isConst = ffi.Uint32 Function(
  CXCursor C,
);

typedef _dart_clang_CXXMethod_isConst = int Function(
  CXCursor C,
);

typedef _c_clang_getTemplateCursorKind = ffi.Int32 Function(
  CXCursor C,
);

typedef _dart_clang_getTemplateCursorKind = int Function(
  CXCursor C,
);

typedef _c_clang_getSpecializedCursorTemplate = CXCursor Function(
  CXCursor C,
);

typedef _dart_clang_getSpecializedCursorTemplate = CXCursor Function(
  CXCursor C,
);

typedef _c_clang_getCursorReferenceNameRange = CXSourceRange Function(
  CXCursor C,
  ffi.Uint32 NameFlags,
  ffi.Uint32 PieceIndex,
);

typedef _dart_clang_getCursorReferenceNameRange = CXSourceRange Function(
  CXCursor C,
  int NameFlags,
  int PieceIndex,
);

typedef _c_clang_getToken = ffi.Pointer<CXToken> Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  CXSourceLocation Location,
);

typedef _dart_clang_getToken = ffi.Pointer<CXToken> Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  CXSourceLocation Location,
);

typedef _c_clang_getTokenKind = ffi.Int32 Function(
  CXToken arg0,
);

typedef _dart_clang_getTokenKind = int Function(
  CXToken arg0,
);

typedef _c_clang_getTokenSpelling = CXString Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _dart_clang_getTokenSpelling = CXString Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _c_clang_getTokenLocation = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _dart_clang_getTokenLocation = CXSourceLocation Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _c_clang_getTokenExtent = CXSourceRange Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _dart_clang_getTokenExtent = CXSourceRange Function(
  ffi.Pointer<CXTranslationUnitImpl> arg0,
  CXToken arg1,
);

typedef _c_clang_tokenize = ffi.Void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  CXSourceRange Range,
  ffi.Pointer<ffi.Pointer<CXToken>> Tokens,
  ffi.Pointer<ffi.Uint32> NumTokens,
);

typedef _dart_clang_tokenize = void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  CXSourceRange Range,
  ffi.Pointer<ffi.Pointer<CXToken>> Tokens,
  ffi.Pointer<ffi.Uint32> NumTokens,
);

typedef _c_clang_annotateTokens = ffi.Void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<CXToken> Tokens,
  ffi.Uint32 NumTokens,
  ffi.Pointer<CXCursor> Cursors,
);

typedef _dart_clang_annotateTokens = void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<CXToken> Tokens,
  int NumTokens,
  ffi.Pointer<CXCursor> Cursors,
);

typedef _c_clang_disposeTokens = ffi.Void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<CXToken> Tokens,
  ffi.Uint32 NumTokens,
);

typedef _dart_clang_disposeTokens = void Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<CXToken> Tokens,
  int NumTokens,
);

typedef _c_clang_getCursorKindSpelling = CXString Function(
  ffi.Int32 Kind,
);

typedef _dart_clang_getCursorKindSpelling = CXString Function(
  int Kind,
);

typedef _c_clang_getDefinitionSpellingAndExtent = ffi.Void Function(
  CXCursor arg0,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> startBuf,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endBuf,
  ffi.Pointer<ffi.Uint32> startLine,
  ffi.Pointer<ffi.Uint32> startColumn,
  ffi.Pointer<ffi.Uint32> endLine,
  ffi.Pointer<ffi.Uint32> endColumn,
);

typedef _dart_clang_getDefinitionSpellingAndExtent = void Function(
  CXCursor arg0,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> startBuf,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> endBuf,
  ffi.Pointer<ffi.Uint32> startLine,
  ffi.Pointer<ffi.Uint32> startColumn,
  ffi.Pointer<ffi.Uint32> endLine,
  ffi.Pointer<ffi.Uint32> endColumn,
);

typedef _c_clang_enableStackTraces = ffi.Void Function();

typedef _dart_clang_enableStackTraces = void Function();

typedef _typedefC_1 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_clang_executeOnThread = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> fn,
  ffi.Pointer<ffi.Void> user_data,
  ffi.Uint32 stack_size,
);

typedef _dart_clang_executeOnThread = void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> fn,
  ffi.Pointer<ffi.Void> user_data,
  int stack_size,
);

typedef _c_clang_getCompletionChunkKind = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Uint32 chunk_number,
);

typedef _dart_clang_getCompletionChunkKind = int Function(
  ffi.Pointer<ffi.Void> completion_string,
  int chunk_number,
);

typedef _c_clang_getCompletionChunkText = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Uint32 chunk_number,
);

typedef _dart_clang_getCompletionChunkText = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  int chunk_number,
);

typedef _c_clang_getCompletionChunkCompletionString = ffi.Pointer<ffi.Void>
    Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Uint32 chunk_number,
);

typedef _dart_clang_getCompletionChunkCompletionString = ffi.Pointer<ffi.Void>
    Function(
  ffi.Pointer<ffi.Void> completion_string,
  int chunk_number,
);

typedef _c_clang_getNumCompletionChunks = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _dart_clang_getNumCompletionChunks = int Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _c_clang_getCompletionPriority = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _dart_clang_getCompletionPriority = int Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _c_clang_getCompletionAvailability = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _dart_clang_getCompletionAvailability = int Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _c_clang_getCompletionNumAnnotations = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _dart_clang_getCompletionNumAnnotations = int Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _c_clang_getCompletionAnnotation = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Uint32 annotation_number,
);

typedef _dart_clang_getCompletionAnnotation = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  int annotation_number,
);

typedef _c_clang_getCompletionParent = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Pointer<ffi.Int32> kind,
);

typedef _dart_clang_getCompletionParent = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
  ffi.Pointer<ffi.Int32> kind,
);

typedef _c_clang_getCompletionBriefComment = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _dart_clang_getCompletionBriefComment = CXString Function(
  ffi.Pointer<ffi.Void> completion_string,
);

typedef _c_clang_getCursorCompletionString = ffi.Pointer<ffi.Void> Function(
  CXCursor cursor,
);

typedef _dart_clang_getCursorCompletionString = ffi.Pointer<ffi.Void> Function(
  CXCursor cursor,
);

typedef _c_clang_getCompletionNumFixIts = ffi.Uint32 Function(
  ffi.Pointer<CXCodeCompleteResults> results,
  ffi.Uint32 completion_index,
);

typedef _dart_clang_getCompletionNumFixIts = int Function(
  ffi.Pointer<CXCodeCompleteResults> results,
  int completion_index,
);

typedef _c_clang_getCompletionFixIt = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> results,
  ffi.Uint32 completion_index,
  ffi.Uint32 fixit_index,
  ffi.Pointer<CXSourceRange> replacement_range,
);

typedef _dart_clang_getCompletionFixIt = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> results,
  int completion_index,
  int fixit_index,
  ffi.Pointer<CXSourceRange> replacement_range,
);

typedef _c_clang_defaultCodeCompleteOptions = ffi.Uint32 Function();

typedef _dart_clang_defaultCodeCompleteOptions = int Function();

typedef _c_clang_codeCompleteAt = ffi.Pointer<CXCodeCompleteResults> Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Int8> complete_filename,
  ffi.Uint32 complete_line,
  ffi.Uint32 complete_column,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Uint32 options,
);

typedef _dart_clang_codeCompleteAt = ffi.Pointer<CXCodeCompleteResults>
    Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Int8> complete_filename,
  int complete_line,
  int complete_column,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  int options,
);

typedef _c_clang_sortCodeCompletionResults = ffi.Void Function(
  ffi.Pointer<CXCompletionResult> Results,
  ffi.Uint32 NumResults,
);

typedef _dart_clang_sortCodeCompletionResults = void Function(
  ffi.Pointer<CXCompletionResult> Results,
  int NumResults,
);

typedef _c_clang_disposeCodeCompleteResults = ffi.Void Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _dart_clang_disposeCodeCompleteResults = void Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _c_clang_codeCompleteGetNumDiagnostics = ffi.Uint32 Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _dart_clang_codeCompleteGetNumDiagnostics = int Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _c_clang_codeCompleteGetDiagnostic = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
  ffi.Uint32 Index,
);

typedef _dart_clang_codeCompleteGetDiagnostic = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
  int Index,
);

typedef _c_clang_codeCompleteGetContexts = ffi.Uint64 Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _dart_clang_codeCompleteGetContexts = int Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _c_clang_codeCompleteGetContainerKind = ffi.Int32 Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
  ffi.Pointer<ffi.Uint32> IsIncomplete,
);

typedef _dart_clang_codeCompleteGetContainerKind = int Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
  ffi.Pointer<ffi.Uint32> IsIncomplete,
);

typedef _c_clang_codeCompleteGetContainerUSR = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _dart_clang_codeCompleteGetContainerUSR = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _c_clang_codeCompleteGetObjCSelector = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _dart_clang_codeCompleteGetObjCSelector = CXString Function(
  ffi.Pointer<CXCodeCompleteResults> Results,
);

typedef _c_clang_getClangVersion = CXString Function();

typedef _dart_clang_getClangVersion = CXString Function();

typedef _c_clang_toggleCrashRecovery = ffi.Void Function(
  ffi.Uint32 isEnabled,
);

typedef _dart_clang_toggleCrashRecovery = void Function(
  int isEnabled,
);

typedef CXInclusionVisitor = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CXSourceLocation>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_clang_getInclusions = ffi.Void Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.NativeFunction<CXInclusionVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _dart_clang_getInclusions = void Function(
  ffi.Pointer<CXTranslationUnitImpl> tu,
  ffi.Pointer<ffi.NativeFunction<CXInclusionVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _c_clang_Cursor_Evaluate = ffi.Pointer<ffi.Void> Function(
  CXCursor C,
);

typedef _dart_clang_Cursor_Evaluate = ffi.Pointer<ffi.Void> Function(
  CXCursor C,
);

typedef _c_clang_EvalResult_getKind = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getKind = int Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_getAsInt = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getAsInt = int Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_getAsLongLong = ffi.Int64 Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getAsLongLong = int Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_isUnsignedInt = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_isUnsignedInt = int Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_getAsUnsigned = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getAsUnsigned = int Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_getAsDouble = ffi.Double Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getAsDouble = double Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_getAsStr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_getAsStr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_EvalResult_dispose = ffi.Void Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _dart_clang_EvalResult_dispose = void Function(
  ffi.Pointer<ffi.Void> E,
);

typedef _c_clang_getRemappings = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_clang_getRemappings = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_clang_getRemappingsFromFileList = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> filePaths,
  ffi.Uint32 numFiles,
);

typedef _dart_clang_getRemappingsFromFileList = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> filePaths,
  int numFiles,
);

typedef _c_clang_remap_getNumFiles = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_remap_getNumFiles = int Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_remap_getFilenames = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Uint32 index,
  ffi.Pointer<CXString> original,
  ffi.Pointer<CXString> transformed,
);

typedef _dart_clang_remap_getFilenames = void Function(
  ffi.Pointer<ffi.Void> arg0,
  int index,
  ffi.Pointer<CXString> original,
  ffi.Pointer<CXString> transformed,
);

typedef _c_clang_remap_dispose = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_remap_dispose = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_findReferencesInFile = ffi.Int32 Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Void> file,
  CXCursorAndRangeVisitor visitor,
);

typedef _dart_clang_findReferencesInFile = int Function(
  CXCursor cursor,
  ffi.Pointer<ffi.Void> file,
  CXCursorAndRangeVisitor visitor,
);

typedef _c_clang_findIncludesInFile = ffi.Int32 Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Void> file,
  CXCursorAndRangeVisitor visitor,
);

typedef _dart_clang_findIncludesInFile = int Function(
  ffi.Pointer<CXTranslationUnitImpl> TU,
  ffi.Pointer<ffi.Void> file,
  CXCursorAndRangeVisitor visitor,
);

typedef _c_clang_index_isEntityObjCContainerKind = ffi.Int32 Function(
  ffi.Int32 arg0,
);

typedef _dart_clang_index_isEntityObjCContainerKind = int Function(
  int arg0,
);

typedef _c_clang_index_getObjCContainerDeclInfo
    = ffi.Pointer<CXIdxObjCContainerDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getObjCContainerDeclInfo
    = ffi.Pointer<CXIdxObjCContainerDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getObjCInterfaceDeclInfo
    = ffi.Pointer<CXIdxObjCInterfaceDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getObjCInterfaceDeclInfo
    = ffi.Pointer<CXIdxObjCInterfaceDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getObjCCategoryDeclInfo
    = ffi.Pointer<CXIdxObjCCategoryDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getObjCCategoryDeclInfo
    = ffi.Pointer<CXIdxObjCCategoryDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getObjCProtocolRefListInfo
    = ffi.Pointer<CXIdxObjCProtocolRefListInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getObjCProtocolRefListInfo
    = ffi.Pointer<CXIdxObjCProtocolRefListInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getObjCPropertyDeclInfo
    = ffi.Pointer<CXIdxObjCPropertyDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getObjCPropertyDeclInfo
    = ffi.Pointer<CXIdxObjCPropertyDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getIBOutletCollectionAttrInfo
    = ffi.Pointer<CXIdxIBOutletCollectionAttrInfo> Function(
  ffi.Pointer<CXIdxAttrInfo> arg0,
);

typedef _dart_clang_index_getIBOutletCollectionAttrInfo
    = ffi.Pointer<CXIdxIBOutletCollectionAttrInfo> Function(
  ffi.Pointer<CXIdxAttrInfo> arg0,
);

typedef _c_clang_index_getCXXClassDeclInfo = ffi.Pointer<CXIdxCXXClassDeclInfo>
    Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _dart_clang_index_getCXXClassDeclInfo
    = ffi.Pointer<CXIdxCXXClassDeclInfo> Function(
  ffi.Pointer<CXIdxDeclInfo> arg0,
);

typedef _c_clang_index_getClientContainer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXIdxContainerInfo> arg0,
);

typedef _dart_clang_index_getClientContainer = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXIdxContainerInfo> arg0,
);

typedef _c_clang_index_setClientContainer = ffi.Void Function(
  ffi.Pointer<CXIdxContainerInfo> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _dart_clang_index_setClientContainer = void Function(
  ffi.Pointer<CXIdxContainerInfo> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _c_clang_index_getClientEntity = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXIdxEntityInfo> arg0,
);

typedef _dart_clang_index_getClientEntity = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<CXIdxEntityInfo> arg0,
);

typedef _c_clang_index_setClientEntity = ffi.Void Function(
  ffi.Pointer<CXIdxEntityInfo> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _dart_clang_index_setClientEntity = void Function(
  ffi.Pointer<CXIdxEntityInfo> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

typedef _c_clang_IndexAction_create = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> CIdx,
);

typedef _dart_clang_IndexAction_create = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> CIdx,
);

typedef _c_clang_IndexAction_dispose = ffi.Void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _dart_clang_IndexAction_dispose = void Function(
  ffi.Pointer<ffi.Void> arg0,
);

typedef _c_clang_indexSourceFile = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  ffi.Uint32 index_callbacks_size,
  ffi.Uint32 index_options,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  ffi.Int32 num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  ffi.Uint32 TU_options,
);

typedef _dart_clang_indexSourceFile = int Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  int index_callbacks_size,
  int index_options,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  int num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  int TU_options,
);

typedef _c_clang_indexSourceFileFullArgv = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  ffi.Uint32 index_callbacks_size,
  ffi.Uint32 index_options,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  ffi.Int32 num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  ffi.Uint32 num_unsaved_files,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  ffi.Uint32 TU_options,
);

typedef _dart_clang_indexSourceFileFullArgv = int Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  int index_callbacks_size,
  int index_options,
  ffi.Pointer<ffi.Int8> source_filename,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> command_line_args,
  int num_command_line_args,
  ffi.Pointer<CXUnsavedFile> unsaved_files,
  int num_unsaved_files,
  ffi.Pointer<ffi.Pointer<CXTranslationUnitImpl>> out_TU,
  int TU_options,
);

typedef _c_clang_indexTranslationUnit = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  ffi.Uint32 index_callbacks_size,
  ffi.Uint32 index_options,
  ffi.Pointer<CXTranslationUnitImpl> arg5,
);

typedef _dart_clang_indexTranslationUnit = int Function(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> client_data,
  ffi.Pointer<IndexerCallbacks> index_callbacks,
  int index_callbacks_size,
  int index_options,
  ffi.Pointer<CXTranslationUnitImpl> arg5,
);

typedef _c_clang_indexLoc_getFileLocation = ffi.Void Function(
  CXIdxLoc loc,
  ffi.Pointer<ffi.Pointer<ffi.Void>> indexFile,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _dart_clang_indexLoc_getFileLocation = void Function(
  CXIdxLoc loc,
  ffi.Pointer<ffi.Pointer<ffi.Void>> indexFile,
  ffi.Pointer<ffi.Pointer<ffi.Void>> file,
  ffi.Pointer<ffi.Uint32> line,
  ffi.Pointer<ffi.Uint32> column,
  ffi.Pointer<ffi.Uint32> offset,
);

typedef _c_clang_indexLoc_getCXSourceLocation = CXSourceLocation Function(
  CXIdxLoc loc,
);

typedef _dart_clang_indexLoc_getCXSourceLocation = CXSourceLocation Function(
  CXIdxLoc loc,
);

typedef CXFieldVisitor = ffi.Int32 Function(
  CXCursor,
  ffi.Pointer<ffi.Void>,
);

typedef _c_clang_Type_visitFields = ffi.Uint32 Function(
  CXType T,
  ffi.Pointer<ffi.NativeFunction<CXFieldVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _dart_clang_Type_visitFields = int Function(
  CXType T,
  ffi.Pointer<ffi.NativeFunction<CXFieldVisitor>> visitor,
  ffi.Pointer<ffi.Void> client_data,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  CXCursor,
  CXSourceRange,
);

typedef _typedefC_3 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_4 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_5 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_6 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CXIdxIncludedFileInfo>,
);

typedef _typedefC_7 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CXIdxImportedASTFileInfo>,
);

typedef _typedefC_8 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_9 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CXIdxDeclInfo>,
);

typedef _typedefC_10 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<CXIdxEntityRefInfo>,
);
