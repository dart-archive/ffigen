// ignore_for_file: non_constant_identifier_names, unused_import, camel_case_types

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:wasmjsgen`.

import 'dart:async' as dart_async;
import 'dart:convert' as dart_convert;
import 'dart:typed_data' as dart_typed;
import 'package:wasm_interop/wasm_interop.dart' as wasm_interop;

/// Bindings to `headers/example.h`.
class NativeLibrary {
  /// The symbol lookup function.
  T lookup<T>(String name) {
    return _wasmInstance.functions[name] as T;
  }

  wasm_interop.Memory get memory {
    return _wasmInstance.memories['memory']!;
  }

  dart_typed.Uint8List get memView {
    return _wasmInstance.memories['memory']!.buffer.asUint8List();
  }

  int get memBytes => memory.lengthInBytes;
  int get memPages => memory.lengthInPages;
  int get memPageSize => (memBytes / memPages).floor();
  int get memElemByteSize => memView.elementSizeInBytes;

  final wasm_interop.Instance _wasmInstance;
  NativeLibrary(this._wasmInstance);

  // --- sum ---
  /// Adds 2 integers.
  int sum(
    int a,
    int b,
  ) {
    return _sum(
      a,
      b,
    );
  }

  late final int Function(
    int,
    int,
  ) _sum = lookup('sum');

  // --- subtract ---
  /// Subtracts 2 integers.
  int subtract(
    Pointer<Int32> a,
    int b,
  ) {
    return _subtract(
      a.address,
      b,
    );
  }

  late final int Function(
    int,
    int,
  ) _subtract = lookup('subtract');

  // --- multiply ---
  /// Multiplies 2 integers, returns pointer to an integer,.
  Pointer<Int32> multiply(
    int a,
    int b,
  ) {
    return Pointer.fromAddress(
      Int32(
        _multiply(
          a,
          b,
        ),
      ),
    );
  }

  late final int Function(
    int,
    int,
  ) _multiply = lookup('multiply');

  // --- divide ---
  /// Divides 2 integers, returns pointer to a float.
  Pointer<Float> divide(
    int a,
    int b,
  ) {
    return Pointer.fromAddress(
      Float(
        _divide(
          a,
          b,
        ),
      ),
    );
  }

  late final int Function(
    int,
    int,
  ) _divide = lookup('divide');

  // --- dividePercision ---
  /// Divides 2 floats, returns a pointer to double.
  Pointer<Double> dividePercision(
    Pointer<Float> a,
    Pointer<Float> b,
  ) {
    return Pointer.fromAddress(
      Double(
        _dividePercision(
          a.address,
          b.address,
        ),
      ),
    );
  }

  late final int Function(
    int,
    int,
  ) _dividePercision = lookup('dividePercision');
  @override
  String toString() {
    final functions = _wasmInstance.functions.keys.map((x) => '\n     $x');
    final elemSize = memElemByteSize;
    int bytesUsed = 0;
    for (int i = 0; i < memView.length; i += elemSize) {
      if (memView[i] != 0) bytesUsed++;
    }
    return '''Wasm NativeLibrary {
  Memory {
    Page Size:        $memPageSize
    Elem Byte Size:   $elemSize
    Pages:            $memPages
    Bytes Total:      $memBytes
    Bytes Used:       $bytesUsed
  }
  functions: $functions
  functionCount: ${functions.length}
}
''';
  }

  static NativeLibrary? _instance;
  static NativeLibrary get instance {
    assert(_instance != null,
        "need to NativeLibrary.init() before accessing instance");
    return _instance!;
  }

  static Future<NativeLibrary> init(dart_typed.Uint8List moduleData) async {
    final wasm_interop.Instance instance =
        await wasm_interop.Instance.fromBytesAsync(moduleData);
    _instance = NativeLibrary(instance);
    return NativeLibrary.instance;
  }
}

// Base for Native Types and Opaque Structs
class Opaque {
  final int _address;
  int get address => _address;
  Opaque(this._address);
}

// FFI Pointer Replacement
class Pointer<T extends Opaque> {
  final T _opaque;
  Pointer._(this._opaque);
  late final int? size;
  factory Pointer.fromAddress(T opaque) {
    return Pointer._(opaque);
  }
  int get address => _opaque.address;
  bool get isSized => size != null;
}

// Dart FFI Native Types
class Void extends Opaque {
  Void(int address) : super(address);
}

class Uint8 extends Opaque {
  Uint8(int address) : super(address);
}

class Int8 extends Opaque {
  Int8(int address) : super(address);
}

class Int16 extends Opaque {
  Int16(int address) : super(address);
}

class Int32 extends Opaque {
  Int32(int address) : super(address);
}

class Int64 extends Opaque {
  Int64(int address) : super(address);
}

class Uint16 extends Opaque {
  Uint16(int address) : super(address);
}

class Uint32 extends Opaque {
  Uint32(int address) : super(address);
}

class Uint64 extends Opaque {
  Uint64(int address) : super(address);
}

class Float extends Opaque {
  Float(int address) : super(address);
}

class Double extends Opaque {
  Double(int address) : super(address);
}

class IntPtr extends Opaque {
  IntPtr(int address) : super(address);
}

// --- JsBigInt and conversion ---
typedef JsBigInt = String;

// Only reliable way I found to convert JS BigInt to int.
// It is used to convert uint64_t and int64_t.
// Dart int is 64bit (signed). A u64 will not fit if it is larger than max i64.
// However in most scenarios we will not hit this max value.
//   Max u64 is 18,446,744,073,709,551,615
//   Max i64 is  9,223,372,036,854,775,807
// Thus we take a shortcut to avoid having to deal with Dart BigInt.
int jsBigIntToInt(JsBigInt n) {
  return int.parse(n);
}

// --- Pointer<Int8> to Dart String conversion ---
const dart_convert.Utf8Codec utf8Codec = dart_convert.Utf8Codec();
String toDartString(Pointer<Int8> ptr) {
  return _decodeUtf8ListString(NativeLibrary.instance.memView, ptr.address);
}

String _decodeUtf8ListString(dart_typed.Uint8List codeUnits, int address) {
  final end = _end(codeUnits, address);
  return utf8Codec.decode(codeUnits.sublist(address, end));
}

int _end(dart_typed.Uint8List codeUnits, int start) {
  int end = start;
  while (codeUnits[end] != 0) {
    end++;
  }
  return end;
}
